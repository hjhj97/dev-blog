<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[하주헌의 개발 블로그]]></description><link>https://juheon.dev</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 14 Oct 2024 07:58:26 GMT</lastBuildDate><item><title><![CDATA[신분당선의 속도제한]]></title><description><![CDATA[내가 신분당선을 오랫동안 타오면서 매번 느끼는 점은 속도제한 90km…]]></description><link>https://juheon.dev/essay/241013-shinbundang/</link><guid isPermaLink="false">https://juheon.dev/essay/241013-shinbundang/</guid><pubDate>Sun, 13 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;내가 신분당선을 오랫동안 타오면서 매번 느끼는 점은 속도제한 90km를 정말 악착같이 지키려고 한다는 점이다. 신분당선은 무인으로 운영되기 때문에 가속과 감속 방식은 미리 프로그래밍되어 있으리라 추측한다(물론 일부는 사람이 직접 중앙통제 하겠지만). 이 부분에 크게 불편함을 느껴본 적은 없지만 속도제한에 대해서는 시스템상으로 매우 엄격하게 lock 이 걸려있는 것 같다.&lt;/p&gt;
&lt;p&gt;신분당선 객차안에 모니터 상에는 속도가 표시되는데, 90km를 넘기면 곧바로 브레이크를 작동시켜 속도를 떨어뜨린다. 문제는 이 브레이크의 강도가 꽤 세기 때문인지 서있는 사람들은 모두 몸이 휘청일 정도이다. 그렇게 속도를 떨어뜨리고 나서 3초정도 지나면 다시 90km를 넘겨서 브레이크를 작동시켜 또 몸이 휘청인다. 이러한 가속과 감속의 울렁임은 다음 역에 도착할 때까지 계속 반복된다. 예민한 사람이라면 다들 신분당선을 타면서 이러한 불편한 승차감을 직접 체감했을 것이다.&lt;/p&gt;
&lt;p&gt;왜 이런 방식의 로직으로 설계되었는지 의아하다. 90km를 넘기면 정말 엄청난 큰일이라도 나는걸까? 하다못해 브레이크 작동 방식이라도 조금 매끄럽게 수정하면 훨씬 승차감이 나아질텐데 말이다. 만약 열차가 아니라 일반 승용차를 이런 방식으로 운전한다면 실로 비효율적인 운전이 아닐 수 없다. 가속페달을 밟다가 특정 속도에 도달하면 브레이크를 밟으면 그만큼의 동력손실이 생기기 때문이다. 코드 관점으로 가속/감속 방식을 생각해보면 아래 유사코드처럼 가장 단순무식한 형태로 코딩되지 않았을까 싶다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;while(!다음역 도착)
  if(speed &amp;gt;= 90) 브레이크()
  else 가속()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제 현업에서는 내가 모르는 중대한 기술적 문제로 인해 이러한 방식이 불가피할수는 있다.하지만 개발자 입장에서는 떠올리기 쉬운 로직일지는 모르지만, 그 &lt;strong&gt;로직이 적용되고 있는 현장에서는 예상치 못한 불편함이 따라올 수도 있다&lt;/strong&gt;는 점을 항상 명심해야한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[<img>와 background-image 의 차이점]]></title><description><![CDATA[vs background-image HTML상에 이미지를 첨부하는 방법에는 크기  태그와 CSS의  속성을 부여하는 2가지 방법이 있다. 이 둘의 차이점에 대해서 찾아보았다. stackoverflow…]]></description><link>https://juheon.dev/html_css/241009-img-vs-background-image/</link><guid isPermaLink="false">https://juheon.dev/html_css/241009-img-vs-background-image/</guid><pubDate>Wed, 09 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; vs background-image&lt;/h2&gt;
&lt;p&gt;HTML상에 이미지를 첨부하는 방법에는 크기 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 태그와 CSS의 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; 속성을 부여하는 2가지 방법이 있다. 이 둘의 차이점에 대해서 찾아보았다. stackoverflow 에 검색을 해보면 예전에도 비슷한 주제로 여러 사람들이 질문을 올린 글들을 찾아볼 수 있다. 그 중에서 가장 간단명료하게 정리해놓은 답변은 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; : content&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; : design&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 태그는 컨텐츠이고 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt;는 디자인 이라고 생각하면 된다는 뜻이다. 그렇다면 이 둘의 차이는 무엇일까?&lt;/p&gt;
&lt;p&gt;일단 첫 번째로 접근성(accessibility)의 차이가 있다. 스크린리더로 웹페이지를 읽는 경우에 &lt;code class=&quot;language-text&quot;&gt;img&lt;/code&gt; 태그는 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성을 참고하여 정보를 제공할 수 있는데 반해, &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt;는 별도의 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성이 존재하지 않기 때문에 이미지에 대한 정보를 알 수 없다. 따라서 이미지가 페이지의 컨텐츠에 중요한 맥락을 제공하는 경우라면 반드시 &lt;code class=&quot;language-text&quot;&gt;img&lt;/code&gt; 태그를 사용하도록 하자.&lt;/p&gt;
&lt;p&gt;비슷한 원리로 SEO의 측면에서도 차이가 있다. 검색엔진이 이미지의 정보를 가져갈 때 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성을 참고하므로 SEO에 유리한 쪽은 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 라고 할 수 있다. 반면 글의 내용과 관련없이 순전히 디자인 목적으로만 첨부된 이미지들은 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; 로 설정하면 된다고 한다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17288500/img-vs-background-image-css-in-performance&quot;&gt;https://stackoverflow.com/questions/17288500/img-vs-background-image-css-in-performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/492809/when-to-use-img-vs-css-background-image&quot;&gt;https://stackoverflow.com/questions/492809/when-to-use-img-vs-css-background-image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maheshkonne.medium.com/html-img-tag-vs-css-background-image-23f9e2e9c8aa&quot;&gt;https://maheshkonne.medium.com/html-img-tag-vs-css-background-image-23f9e2e9c8aa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[왜 fetch 함수는 await를 2번 해야 하는걸까?]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/js_ts/241008-why-fetch-await-twice/</link><guid isPermaLink="false">https://juheon.dev/js_ts/241008-why-fetch-await-twice/</guid><pubDate>Mon, 07 Oct 2024 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;자바스크립트의 내장함수인 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt;를 사용하여 데이터를 갖고 오기 위해서는 아래 코드와 같이 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 두번 사용해야 한다는 번거로움이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const response = await fetch(&amp;quot;/api&amp;quot;)
const data = await response.json()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;왜 굳이 이렇게 만들었을까 하는 의문이 생긴다. 처음부터 한 번의 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;로 데이터를 갖고오게끔 만들면 더 편리했을텐데 말이다.&lt;/p&gt;
&lt;p&gt;그 이유는 HTTP 요청의 특성을 생각해보면 짐작할 수 있다. HTTP 요청은 header와 body 로 구성되어 있다. header 상에는 요청 메소드의 종류와 응답결과, 상태코드 등이 담겨 있다. 보통 header의 용량이 body의 용량보다 작을 것이므로 더 먼저 응답결과를 받아볼 수 있다는 점을 염두에 두고 아래 공식 문서를 살펴보자.&lt;/p&gt;
&lt;p&gt;mdn의 fetch &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&quot;&gt;공식문서&lt;/a&gt;에서는 아래와 같이 설명하고 있다.&lt;br&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 17.088607594936708%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApklEQVR42j2OQY6DMBRDOUkj2MGCgfyEJB0aCAksuu39z/JGROosLEt+luxmHEecc9glsCwB7z3WWrTW+BCw7onzARFde3demfeISJUxhhACbdvS3CClxDMWXluhlEwpJ8eROPLJ9f6wpZOUds6S2bbIvu+s61o9xkjOmeu6GIaBpu97tAh6npimn/9332VnDUaEaZ7R5pdZPF3X8VCqPvrqzpRS/AG7yWFcqexqqQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;fetch-mdn&quot;
        title=&quot;&quot;
        src=&quot;/static/ee6613d688565dbef2bb20dd711adf2c/f058b/fetch-mdn.png&quot;
        srcset=&quot;/static/ee6613d688565dbef2bb20dd711adf2c/c26ae/fetch-mdn.png 158w,
/static/ee6613d688565dbef2bb20dd711adf2c/6bdcf/fetch-mdn.png 315w,
/static/ee6613d688565dbef2bb20dd711adf2c/f058b/fetch-mdn.png 630w,
/static/ee6613d688565dbef2bb20dd711adf2c/40601/fetch-mdn.png 945w,
/static/ee6613d688565dbef2bb20dd711adf2c/78612/fetch-mdn.png 1260w,
/static/ee6613d688565dbef2bb20dd711adf2c/64639/fetch-mdn.png 1568w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;fetch()&lt;/code&gt; 메소드는 당신이 fetch 하려는 리소스가 있는 경로라는 한 개의 필수적인 인자만 받는다. 그것은 해당 요청을 resolve 할 수 있는 &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt;객체를 내놓는 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 반환한다 - &lt;strong&gt;서버가 header로 응답을 받자마자&lt;/strong&gt; - 설령 서버의 응답이 error 상태라 하더라도.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;fetch()&lt;/code&gt; 는 body는 신경쓰지 않고 일단 header만 도착하게 되면 응답할 수 있는 상태를 준비해준다는 것이다. 그리고 body안에 들어있는 데이터를 받기 위해서는 그때 비로소 &lt;code class=&quot;language-text&quot;&gt;Response.json()&lt;/code&gt;함수를 호출하면 된다는 뜻이다. 또한 만약에 header의 응답결과가 error 로 받았다면 우리는 body 를 아예 받지 않아도 되므로 네트워크 리소스를 절약할 수도 있다.&lt;/p&gt;
&lt;p&gt;이처럼 fetch 메소드는 데이터를 받는 단계를 두 단계로 나눠놓는 이유는 HTTP 요청의 특성을 생각해보면 납득할 수 있다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tomontheinternet.com/why-two-awaits/&quot;&gt;https://tomontheinternet.com/why-two-awaits/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[2024년 반기 회고]]></title><description><![CDATA[부끄럽지만 이전 글이었던 '2023년 회고' 다음으로 쓰는 글이 올해 반기 회고 글이다. 일에 치이다보니 개발 블로그에 글 쓰는 일에 소홀했다. 회사 업무 작년 1…]]></description><link>https://juheon.dev/essay/240805-2024-first-review/</link><guid isPermaLink="false">https://juheon.dev/essay/240805-2024-first-review/</guid><pubDate>Mon, 05 Aug 2024 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;부끄럽지만 이전 글이었던 &apos;2023년 회고&apos; 다음으로 쓰는 글이 올해 반기 회고 글이다. 일에 치이다보니 개발 블로그에 글 쓰는 일에 소홀했다.&lt;/p&gt;
&lt;h2&gt;회사 업무&lt;/h2&gt;
&lt;p&gt;작년 10월에 입사하여 온보딩 기간을 거친 후, 올해 초부터 본격적으로 실제 개발 업무에 투입이 되었다. 처음 맡은 일은 SEO 개선 작업이었다. 개발자도구 Lighthouse 검사를 수백번씩 돌려가면서 점수를 조금씩 올려 나갔다. 마지막으로 SEO 100점을 찍었을 때는 마치 게임에서 최종보스를 잡고 클리어하는 듯한 쾌감을 느꼈다.&lt;/p&gt;
&lt;p&gt;그 다음 태스크는 랜딩페이지 로딩속도 개선이었다. 기존 랜딩페이지는 레거시가 쌓여있어 개발자도구 Network 기준 약 2초 중반대의 로딩속도를 보여주고 있었다. CSR의 특성상 한번에 많은 chunk 데이터를 받아와야 하고, 용량이 큰 이미지들도 받아와야 헸기 때문에 오래 걸릴 수밖에 없었다. 나는 부분적으로 작업하면서 1차적으로는 폰트 리소스의 용량을 줄여 1.2초대까지 줄였고, 2차로 CSR -&gt; SSR(Nuxt) 기반으로 옮기면서 훨씬 더 시간을 줄일 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;이밖에도 유사 인플루언서 추천, 영상 캠페인, 리워드 제안하기 등의 신규 피쳐를 개발했다. 또한 리팩토링과 같은 레거시 정리 작업도 적지 않았다. 둘 중에 어떤 업무가 더 재밌냐고 묻는다면 솔직히, 아니 당연히 신규 피쳐를 개발하는 일이 훨씬 더 재미있다. 예전에 작성된 히스토리조차 알 수 없는 코드를 들여다 보는 일에 썩 재미를 붙이기란 쉽지 않다. 또한 리팩토링이라는 게 아무리 내가 시간을 들여서 열심히 하더라도 사용자 입장에선 차이가 체감되지 않는 경우가 대부분이다(차이를 체감할 수 있는 리팩토링은 둘 중 하나이다. 엄청 잘했거나, 엄청 잘못되었거나).&lt;/p&gt;
&lt;p&gt;특히 영상 캠페인을 작업할 때는 당초 예상했던 개발기간인 한달 반을 훌쩍 넘어서 3달 넘게 진행되었다. 그 중 한달이 넘는 기간동안은 리팩토링을 하는데 할애했다. 기존 코드는 SNS플랫폼의 종류가 인스타그램과 네이버블로그 2종류만 존재했던 과거의 상황에 맞춰져 하드코딩된 부분이 많아 릴스,유튜브,틱톡과 같은 신규 플랫폼을 추가하는 일이 어려웠기 때문이다.&lt;br&gt;
굳이 리팩토링하지 않고서 개발하는 선택지가 있기는 했지만 나는 그로 인한 사이드이펙트가 더 커질 것이라고 판단했다. 앞으로 신규 플랫폼이 추가될 때마다 코드의 복잡성이 기하급수적으로 늘어날 것이기 때문이다. 소위 &apos;모래성 위에 모래성 쌓기&apos;인 상황을 방지하기 위해서 당장은 시간이 더 소요되더라도 리팩토링이 필요하다고 판단했다.&lt;/p&gt;
&lt;p&gt;회사의 프로덕트가 대부분 구독형 B2B Saas 이다보니 개발자와 유저와의 거리가 가까운 편은 아니다. 커머스 같은 서비스라면 외부에서 랜덤하게 유입될 수 있는 잠재 고객이 있겠지만, B2B Saas 프로덕트를 필요로 하는 고객층은 극히 한정되어있고 쓸 사람만 돈 내고 쓰고 안 쓸 사람은 이탈하는 경향이 강하기 때문이다. 그래서인지 나도 어떻게하면 사용자들과 최대한 가까운 거리에서 허들을 낮춰 만날 수 있을지를 고민했던 것 같다.&lt;/p&gt;
&lt;h2&gt;권고사직&lt;/h2&gt;
&lt;p&gt;갑자기 뜬금없는 전개인데 7월 말에 회사로부터 권고사직 통보를 받았다. 실제로 그 소식을 전해들은 나 역시도 어안이 벙벙했다. 경영 악화로 인한 인건비를 감축해야 한다는 것이 이유였다. 회사의 수익구조상 프로덕트는 적자가 계속 누적되고 있었고, 이를 다른팀의 수익으로 메꾸는 상황이 지속되고 있다가 한계에 다다라서 결국 터져버린 것이다. 그렇다고 프로덕트가 완전히 서비스종료 하는 건 아니고 최소한의 유지보수를 위한 개발인원만 남겨두고 나를 포함한 나머지 인원은 모두 짐을 싸야하는 상황이 되었다.&lt;/p&gt;
&lt;p&gt;나도 회사의 사정을 이해하고 덤덤하게 받아들이기로는 했지만 마음이 착잡해지는 건 사실이다. 긴 시간은 아니지만 약 10개월 남짓한 기간동안 프로덕트에 애착을 갖고 노력을 쏟아부었다. 목표기간까지 피쳐를 완성하기 위해서 야근과 주말근무도 했고, 버그 리포트가 나오면 밤이건 쉬는 날이건 할 것없이 집에서 디버깅하고 핫픽스를 배포하기도 했다. 이런 고생이 돈을 더 받는다거나 남들에게 인정을 받기 위해서가 아니다. 내가 관여하고 있는 프로덕트를 조금이라도 더 나은 방향으로 개선하고 싶은 욕심이 있었기 때문이다.&lt;br&gt;
개발자마다 직업의 성취를 느끼는 기준은 각자 다르겠지만 나에게는 프로덕트와 사용자가 맞닿아있는 사이의 지점에서 상호작용하는 순간이 해당된다. 프로덕트에 기여하고 있다는 확신만 든다면 내가 고생하더라도 자부심을 가지고 일할 수 있었다.&lt;/p&gt;
&lt;p&gt;공교롭게도 지난 포스팅에서 이 회사에 들어오게 된 가장 큰 이유는 바로 스타트업의 &apos;낭만&apos;을 좇기 위해서라고 밝혔다. 성공할지 실패할지도 모르는 불확실성이라는 파도에 내 커리어를 맡겨보고 싶었다. 이 무모한 도전이 지금 시점에서는 판정패를 받은 것으로 보인다. 솔직히 말해서 작년 이맘때 쯤 &apos;합격통보를 받은 다른 회사에 들어갔더라면?&apos; 하는 또다른 평행세계를 떠올려 보곤 한다. 최소한 권고사직을 당했을리는 없을테니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다고 이제와서 생각한들 뭐가 달라지겠는가. 지나간 과거를 탓하기보단 거기서 무엇을 얻었는지와 앞으로 어떻게 해야할지를 고민하는 게 정신건강에 더 도움이 된다. 일단 내가 얻은 가장 큰 수확은 동료들과 협업하는 경험을 얻었다. 첫 직장에서는 프론트를 거의 나 혼자서 도맡아서 개발했기 때문에 브랜치 전략이나 커뮤니케이션 방법을 익히기에 한계가 있었지만 이번 회사에서는 프론트 뿐만 아니라 백엔드, 데이터, 마케팅팀과 같이 하면서 이 2가지의 필요성을 절감하고 익힐 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;또한 일회성 개발 성격이 강한 외주 프로젝트가 아닌 회사에서 서비스하는 프로덕트를 개발하다보니 코드퀄리티와 유지보수에도 더 신경쓰게 되고 코드리뷰를 받으면서 내가 미처 신경쓰지 못했던 부분에 대해 다른 개발자들의 피드백을 받을 수 있던 점이 값진 경험이었다.&lt;/p&gt;
&lt;h2&gt;앞으로의 계획&lt;/h2&gt;
&lt;p&gt;앞으로 당분간은 쉬면서 이력서를 정리하려고 한다. 1년 전이나 지금이나 개발자 취업시장은 여전히 어렵기 때문에 긴 호흡을 갖고 여유롭게 생각하는게 마음이 편하다. 무엇보다도 멘탈을 잘 추스려서 멘붕에 빠져있지 않고 다시 달릴 수 있도록 준비해야겠다. 이번 권고사직이 현재 시점에서는 고난일지는 몰라도 개발자 커리어에선 그저 스쳐 지나가는 해프닝에 불과할지도 모른다. 남들은 쉽게 겪어보지 못했던 경험을 해봤으니 내 인생이 더 재밌어졌다고 생각해보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2023년 회고]]></title><description><![CDATA[조금 뒷북이지만 지나간 2023년을 되돌아보고 2024년은 어떻게 보낼 지 정리해보려고 한다. 퇴사 2022년 6월부터 학생 인턴으로 다니기 시작했던 회사는 1년을 다니다가 지난…]]></description><link>https://juheon.dev/essay/240120-review-2023/</link><guid isPermaLink="false">https://juheon.dev/essay/240120-review-2023/</guid><pubDate>Sat, 20 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;조금 뒷북이지만 지나간 2023년을 되돌아보고 2024년은 어떻게 보낼 지 정리해보려고 한다.&lt;/p&gt;
&lt;h2&gt;퇴사&lt;/h2&gt;
&lt;p&gt;2022년 6월부터 학생 인턴으로 다니기 시작했던 회사는 1년을 다니다가 지난 6월에 퇴사하였다. 대단한 이유 때문은 아니고, 단지 내가 더 넓고 깊은 경험이 필요하다고 판단해서였다. 회사의 프로젝트는 시간이 지나고 나의 숙련도는 쌓여갈수록 업무가 점점 단순해지고 기술적으로도 도전해볼만한 여지도 적었다. 만약 내 성향이 안정 지향적이었다면 계속 머물러있기에는 좋은 업무환경일 수는 있었지만, 나는 안정만 추구하려고 개발자가 된 건 아니다.&lt;/p&gt;
&lt;p&gt;개발을 하면서 여러가지 암초에도 부딪히면서 문제를 해결해 나가고, 새로운 기술도 배우면서 자신이 발전해 나가고 있다는 성취감이 개발자로서 느낄 수 있는 가장 큰 매력이라고 생각하며 나 또한 이런 낭만을 추구하기 위해서 개발자라는 진로를 선택했다. 그래서 업무가 익숙해지고 스스로가 정체되었다고 느껴질 때 변화를 줘야겠다고 마음을 먹게 되었다.&lt;/p&gt;
&lt;h2&gt;휴식, 졸업, 공부&lt;/h2&gt;
&lt;p&gt;당초에는 6월에 퇴사를 하고 나서 최대한 빠른 시일 내로 다른 회사로 이직하는 것이 목표였다. 하지만 당장은 꽤나 지쳐있는 상태였다. 몸보다는 오히려 정신이 더 지쳐있는 상태였다. 업무를 하면서도 강박에 시달렸었기 때문에 자기 자신을 괴롭히곤 했다. 그때 나에게는 휴식이 절실히 필요했다.&lt;/p&gt;
&lt;p&gt;그래서 퇴사를 하고나서 1달 동안은 거의 아무 것도 하지 않고 재충전을 하는 데에만 집중했다. 친구들과 여행도 다니고 보고 싶었던 영화들도 이 시기에 다 정주행하는 등 평소에 시간이 없어서 밀려있었던 일들을 모두 해치울 수 있었다.&lt;/p&gt;
&lt;p&gt;그러면서도 틈틈이 이직을 위한 준비도 하고있었다. 나의 이력서는 일주일에 한번씩 고쳐쓰면서 일종의 &apos;이력서 최적화&apos; 작업을 수행하고 있었고, 이 이력서를 바탕으로 꾸준히 회사에도 지원하고 있었다. 그렇다고 막무가내로 공고가 뜨는 모든 회사에 지원하는 건 무의미하다고 생각하였고, 내 나름대로 기준을 설정하여 이에 부합하는 회사 위주로 지원했다. (이직 과정에 대한 상세한 설명은 추후 포스팅에서 소개할 예정이다.)&lt;/p&gt;
&lt;p&gt;그러는 사이 8월이 되었다. 나는 이미 2월에 대학교 졸업 유예를 걸어놓았었고, 다시 한번 유예를 연장할지 아니면 졸업을 확정할 것인지 결정해야 했다. 그 전에 이직을 완료했다면 고민없이 졸업했겠지만 아직까지는 취업(이직)준비생 신분이기 때문에 마음 편하게 한번 더 미루고 싶은 마음도 있었다.&lt;/p&gt;
&lt;p&gt;마음이 오락가락하기를 몇 번 반복하다가 그냥 졸업하기로 마음 먹었다. 졸업을 계속 미루면서 안전영역에 머물러 있으려는 건, 애시당초에 회사를 이직하려는 목적과도 맞지 않았기 때문이다. 이왕 마음을 먹은 김에 아예 배수의 진을 치고 모험을 하는게 맞다고 생각했다. 지금 생각해보면 무모하다 싶을 정도로 배짱이 두둑했는데, 결과적으로 보면 금새 이직은 성공했으니 나름 효과가 있었다고 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;이직&lt;/h2&gt;
&lt;p&gt;새 회사로는 10월에 이직했다. 이전 회사에 퇴사한 지 4달이 지난 후다. 예상보다 오래 걸리긴 했지만 채용시장의 상황이 너무나 차가웠기 때문에 오히려 4달 정도면 선방했다고 생각될 정도다.&lt;/p&gt;
&lt;p&gt;사실 현재 회사(편의상 A로 칭함)로 합격하기 전에 이미 다른 B회사의 최종 합격까지 받았고, 실제로 80%이상 B회사로 마음이 기운 상태였다. 그래서 처음 A회사로부터 1차 면접 제안을 받았을 당시에도 &apos;이미 B를 붙었는데 굳이 봐야하나&apos; 생각이 들었다. 그래도 나를 좋게 봐준 A회사에 대한 최소한의 예의이자, 면접 경험치도 쌓을 겸 해서 가벼운 마음으로 면접에 응했다. 그런데 왠걸, 1차 통과 후 2차 기술면접과 3차 최종면접까지 통과하여 합격을 받았다. 좀 얼떨떨한 기분이었는데 아무튼 선택지로 회사 한 군데가 늘었다는 건 나에게도 호재이다.&lt;/p&gt;
&lt;p&gt;여기서 선택의 갈림길에 서게 되었다. 이전에 합격한 B회사는 인원과 매출규모는 꽤나 큰 편이었고 비즈니스도 나름 안정적인 궤도로 들어선 상태였다. A회사의 규모는 그 보다는 작은 편이었고 비즈니스도 아직 안정적이라기 보다는 그 방향을 향해 열심히 달려나가고 있는 상태였다.&lt;/p&gt;
&lt;p&gt;다만 B회사는 어느정도 연차가 있었고 기술적인 레거시도 쌓여있었다(면접 당시에 면접관에게 질문했던 내용이었다). 그래서 내가 입사하더라도 맡게될 일은 새로운 피쳐를 개발하는 쪽보다는 기존에 잘 돌아가고 있는 시스템을 유지보수하거나 일부 레거시를 개편하는 정도였다.&lt;/p&gt;
&lt;p&gt;반면에 A회사는 이제 막 새로운 피쳐를 치열하게 개발하고 있는 시기였다. 레거시도 전혀 없는 건 아니었지만, 그로 인해 스트레스를 받을 정도는 아닌 상태였다. 따라서 내가 들어간다면 본격적으로 피쳐를 개발할 수도 있고, 새로운 기술도 (도입이 합리적이라면)얼마든지 쓸 수 있는 환경이었다.&lt;/p&gt;
&lt;p&gt;이 두 회사 사이에서 너무나도 고민되었다.결국 이 상황도 요약하자면 &lt;strong&gt;안정적 회사&lt;/strong&gt; vs &lt;strong&gt;도전적 회사&lt;/strong&gt;이었다. 둘 중에서 어느 회사를 선택했는지는 이 포스팅에서 열심히 쌓아올린 빌드업을 보면 눈치챘겠지만, 나는 도전을 택하기로 했다.&lt;/p&gt;
&lt;p&gt;애초에 기존 회사를 퇴사한 이유부터 나는 &apos;안정&apos;을 버리고 &apos;도전&apos;이라는 낭만을 택하기 위해서였다. 현실 앞에서 낭만은 금새 죽어버린다고는 하지만, 그럼에도 나는 미련하게 나의 낭만을 믿어보기로 했다. 설령 내 선택이 잘못되었다고 한들, 그때 다시 일어나면 된다. 지금이 아니면 언제 낭만을 쫓아보겠는가?&lt;/p&gt;
&lt;h2&gt;올해 잘한 점 / 부족한 점&lt;/h2&gt;
&lt;p&gt;2023년에 잘한 점은 아무래도 인생 첫 이직을 잘 마무리 했다는 점이다. 이력서를 수십번 고쳐쓰면서 채용시장이 어려웠음에도 불구하고 몇몇회사는 기술면접을 보고 경험치를 쌓을 수 있었다. 대부분 떨어지기는 했지만 앞으로 내 커리어를 쌓는데에 있어서는 좋은 밑바탕이 되리라고 생각한다. 그 밖에도 주말같은 개인시간에도 공부를 꾸준히 했다는 점 역시 좋은 습관으로 굳힐 수 있어서 다행이다. 남는 시간에 공부든 운동이든 습관을 형성하는 일이 참 중요하다고 느낀다.&lt;/p&gt;
&lt;p&gt;부족한 점을 꼽자면 신체/멘탈 관리였던 것 같다. 사실 몸이 아픈 날은 많지 않았다. 1월 1일부터 코로나 증상(음성이긴 했지만)으로 인해 3~4일 시름시름 앓느라 회사를 빠진 것 말고는 1년 중에서 일을 못할 정도로 아프거나 다친 적은 없었다.&lt;/p&gt;
&lt;p&gt;몸보다는 멘탈을 더 신경써야 할 것 같다. 아직까지도 업무강박 + 욕심이 있어서 그런지 스스로에게 엄격한 잣대를 들이미느라 평일날 퇴근 이후는 물론이고 주말에도 계속 업무생각을 떨쳐내기가 힘들다. 현재 회사는 재택근무를 제약없이 원하는대로 할 수 있음에도 불구하고 나는 꾸준히 사무실 출근을 고집하는 이유도 &apos;일&apos;과 &apos;삶&apos;을 최대한 분리하기 위해서이다. 이를 지키기 위한 가장 중요한 방법이 바로 &apos;일&apos;하는 물리적 공간의 분리라고 생각한다.&lt;/p&gt;
&lt;p&gt;오직 사무실에서만 일하고, 퇴근하고 집에 돌아가면 최대한 일 생각을 하지 않으려고 노력한다. ON/OFF 스위치 마냥 켜고 끄고 싶은데 현실적으로 쉽지는 않다. 그래서 2024년에는 스스로 욕심을 절제해 나가면서 자신의 멘탈을 갉아먹지 않는 게 중요할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[shake! 출제 및 운영 후기]]></title><description><![CDATA[2022-02-20에 작성된 원문을 수정한 버전입니다  지난 1월 15일, '2021 경인지역 6개대학 연합프로그래밍 경시대회'인 shake…]]></description><link>https://juheon.dev/essay/231011-shake-prepare-review/</link><guid isPermaLink="false">https://juheon.dev/essay/231011-shake-prepare-review/</guid><pubDate>Wed, 11 Oct 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2022-02-20에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/209&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0feaf54902a5e9b9c60e0c155c311e11/eea4a/poster.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 141.13924050632912%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgD/2gAMAwEAAhADEAAAAey9NkJjqJ5GZMuP/8QAGxAAAgMAAwAAAAAAAAAAAAAAAAECESEQMUH/2gAIAQEAAQUC02z0uXD6qQxxtI//xAAWEQEBAQAAAAAAAAAAAAAAAAARABD/2gAIAQMBAT8BNb//xAAWEQADAAAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8BI//EABgQAAIDAAAAAAAAAAAAAAAAABAgITGx/9oACAEBAAY/Aloxqf/EAB0QAAMAAgIDAAAAAAAAAAAAAAABESFBMVFh0eH/2gAIAQEAAT8htPOxYG3gSeeUMOpYJfFG52TVIbTwEEbKcPR//9oADAMBAAIAAwAAABBIFQH/xAAXEQEAAwAAAAAAAAAAAAAAAAABABAR/9oACAEDAQE/ECNLf//EABcRAQEBAQAAAAAAAAAAAAAAAAARATH/2gAIAQIBAT8QqmdR/8QAIBABAAICAgEFAAAAAAAAAAAAAQARITFBUWGRobHR4f/aAAgBAQABPxBMjk51KNlZzNIha0J9Q6UUzMpu8C7ltLmb/QZc1l1mOkyqp8S0g66k95pRT0g5UAwjU3VZTWSfE//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;poster&quot;
        title=&quot;&quot;
        src=&quot;/static/0feaf54902a5e9b9c60e0c155c311e11/828fb/poster.jpg&quot;
        srcset=&quot;/static/0feaf54902a5e9b9c60e0c155c311e11/ff44c/poster.jpg 158w,
/static/0feaf54902a5e9b9c60e0c155c311e11/a6688/poster.jpg 315w,
/static/0feaf54902a5e9b9c60e0c155c311e11/828fb/poster.jpg 630w,
/static/0feaf54902a5e9b9c60e0c155c311e11/0ede0/poster.jpg 945w,
/static/0feaf54902a5e9b9c60e0c155c311e11/3ac88/poster.jpg 1260w,
/static/0feaf54902a5e9b9c60e0c155c311e11/eea4a/poster.jpg 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;지난 1월 15일, &apos;2021 경인지역 6개대학 연합프로그래밍 경시대회&apos;인 shake! 가 열렸다. 지금 글을 쓰는 시점과는 시간이 꽤 흐르긴 했는데 나름대로 &lt;del&gt;고통스러운&lt;/del&gt; 흥미로운 경험을 하기도 했고, 회고할 만한 일도 있었다고 생각하기에 지금이 되어서야 후기를 남기게 되었다.&lt;/p&gt;
&lt;h2&gt;배경&lt;/h2&gt;
&lt;p&gt;내가 소속된 아주대학교 소학회 A.N.S.I.는 2015년부터 shake! 대회를 주관하고 있다. 내가 입학한 2017년 이전에는 잘 모르겠지만, 2017년 이후로는 A.N.S.I.의 회장이 shake!의 대회 운영을 맡는 게 관례였다.&lt;br&gt;
다만 회장이 shake! 대회에 참가를 하게 되는 경우, 운영 과정이 매끄럽지 않을 수도 있다는 점이 우려되어 이런 경우에는 별도의 인원이 대신 대회 운영을 맡을 수밖에 없었다. 이번 대회가 정확히 이 케이스에 해당되었고 결국 내가 대회 운영을 맡게 되었다. 전년도(2020년)에 회장직을 맡다가 도중에 군 입대로 인해 회장직의 소임을 다하지 못하고, 나 대신 고생해준 다른 분들에게 미안함과 책임감 때문이라도 내가 맡는 게 맞다고 생각했다.&lt;/p&gt;
&lt;h2&gt;시작&lt;/h2&gt;
&lt;p&gt;원래 이상적인 방향대로라면 나는 운영 파트만 담당하고 출제 파트는 (내가 포함되지 않은) 출제진들이 담당하는 것이다. 하지만 이렇게 진행할 경우 큰 문제가 하나 있다. 그건 바로 학교로부터 &apos;운영 업무에 대한 급여&apos;를 받을 수 없다는 것이다. 정확한 학교 사정은 모르겠지만, 예전부터 오직 &apos;운영&apos;업무 만으로는 급여를 받을 수 없다는 안내를 받았기 때문에 어쩔 수 없이 나는 &lt;strong&gt;운영도 하면서 출제도 해야하는&lt;/strong&gt;, 양다리를 걸칠 수밖에 없는 상황이다(출제진은 급여가 나오기 때문이다).&lt;/p&gt;
&lt;p&gt;그렇다면 누군가 &apos;운영도 하면서 출제 하는 게 뭐가 힘듦?&apos;이라고 되물을 수도 있겠다. 하지만 shake!는 운영 난이도가 그리 호락호락 하지가 않다. 사실 난이도가 어렵다기보다는 자잘하게 신경써야 할 일이 정말 많다. 왜냐하면 6개 대학이 합쳐서 하나의 대회를 만드는 특수성때문에 하나의 사안을 두고도 각 학교의 대표인들에게 동의를 구해야만 진행할 수 있다. 즉 하나의 의사결정 과정을 처리함에 있어서 단순 교내 프로그래밍 경시대회보다도 훨씬 복잡하고 시간도 많이 소요된다.&lt;/p&gt;
&lt;p&gt;게다가 더 큰 산이 하나 더 남아있었으니, 바로 대회 &lt;strong&gt;후원사를 섭외해야한다&lt;/strong&gt;는 점이다. 교내 대회인 APC는 학교 자체 후원으로 진행되었지만 shake!는 대대적으로 &apos;산학 연계&apos;라는 기조로 이어져왔기 때문에 매년 후원사를 두세군데 섭외해왔다. 후원사가 먼저 &apos;저희가 대회 후원해드릴게요~&apos; 먼저 나서주면 좋으련만 안타깝게도 그런 사례는 거의 없었다.&lt;/p&gt;
&lt;p&gt;지금까지는 대부분 대회 운영 담당자(나 같은 포지션)가 이곳저곳에 후원 제안 메일을 뿌리면서 직접 맨땅에 헤딩하는 식으로 업체를 섭외해왔다. 물론 아무 업체에 제안을 한 건 아니고 주로 졸업하신 선배분들의 직장을 위주로 메일을 보냈기 때문에 섭외 성공 확률이 조금은 높았을 수는 있겠으나 거절도 적잖게 당했었다. 아무튼 운영 담당자는 후원 업체를 섭외하는 데도 부담스러울 수 밖에 없는 노릇이었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/34c7a3210487077a87a49c3d84098dd9/21b4d/manage-structure.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.16455696202532%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtUlEQVR42o2TyXKcQBBE57Ns/53u/hTfffNRB5/GjtBs0iyYbVgbaGgYtueotqTQjHRwRVQARVWSldksuIm2bWmaxqYxhrIsUUrRXS78Tyzmeb4qdF2H1prT6UScJIRBwDn0GQYBnLjtfwd4WxiGwbIsy4I8S6m1xolqzqqHGea3+RFgXdd2PbkKM2Fompq0rFm6KWnVEsY/CJM7jPnKMGbPox8zXWRZhuu6VifP84iiiM3qgd+HP/x8inh0f+G5n3BOXwiDz4TpPcpAVGoK072DXgg7EV4YvmShcupa4yUFl76jqr5x8O9I8++4UUKoNLluqEzHPF3rak2ZpsmunSQJrTHEqiSvDWGmyFVBlhmOUYPpoWsNge/juS55lrE/HDgej1b7V1NEt91uZ1PcfYwKtmeFd45Zrx9wnCOX52MzjiNKFYRhSBAExHGM7/v0ff8PUNhJk7zY7/cW/CWkLpqKWcM4Xokvm+V5TpqmdkaeJRer1YrNZsN6vWa5XOI4DuM0UWltP7Ddbqmq6gpMjJR+MVNSekT7V1NkwJpRFJaNhNTFdQGVP+YWUFYW9pJyL2dXAP8CsRxJiRhBrVsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;manage&quot;
        title=&quot;&quot;
        src=&quot;/static/34c7a3210487077a87a49c3d84098dd9/f058b/manage-structure.png&quot;
        srcset=&quot;/static/34c7a3210487077a87a49c3d84098dd9/c26ae/manage-structure.png 158w,
/static/34c7a3210487077a87a49c3d84098dd9/6bdcf/manage-structure.png 315w,
/static/34c7a3210487077a87a49c3d84098dd9/f058b/manage-structure.png 630w,
/static/34c7a3210487077a87a49c3d84098dd9/40601/manage-structure.png 945w,
/static/34c7a3210487077a87a49c3d84098dd9/78612/manage-structure.png 1260w,
/static/34c7a3210487077a87a49c3d84098dd9/21b4d/manage-structure.png 1280w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;내가 해야할 일은 위와 같았다&lt;/p&gt;
&lt;p&gt;그래도 뭐 어쩌겠는가. 결국에는 내가 해야한다. &apos;하다보면 어떻게든 되겠지&apos;라는 심정으로 시작했다.&lt;/p&gt;
&lt;h2&gt;출제를 하자&lt;/h2&gt;
&lt;p&gt;기왕 출제를 맡게 되었으니 즐거운 마음으로 하고자 마음을 먹었다. 출제진은 약 (2021년) 10월 초에 꾸려졌으며, 지난 대회 수상자와 타 대학 출제진으로 나를 포함해 총 5명으로 이루어졌다. 나도 APC 출제 경험이 있고 다들 출제 경험이 어느정도 있었기에 수월하지 않을까라고 예상했다.&lt;/p&gt;
&lt;p&gt;출제 프로세스는 먼저 2주 간격으로 3번씩 선제를 진행하여 문제 pool을 모으고 이 중에서 대회에 출제할 문제를 확정 짓는다. 문제를 확정 짓고 나면 각자 본인이 맡은 문제를 대회 출제 플랫폼인 polygon 에서 데이터를 작업한다. 데이터 작업이 완료되면 대회 플랫폼인 BOJ의 대회 준비 플랫폼인 BOJ stack에 문제를 옮긴 후 최종적으로 문제를 다듬은 뒤에 검수를 맡기면 된다.&lt;/p&gt;
&lt;p&gt;다만 출제 과정이 쉽지 않다. 지난 두 번의 APC 출제에서 익히 경험했었다. 가장 큰 난관은 내가 &apos;어떤 문제를 내야할까&apos;이다. 사람마다 문제를 내는 성향도 각기 다르다.&lt;br&gt;
보통 두 부류로 나뉘는데 하나는 상황을 먼저 생각한 뒤에 문제화 시키는 방식과, 반대로 문제를 먼저 생각한 뒤에 상황을 끼워 맞추는 방식이 있다. 둘 중 어느 방식이 더 좋다고는 말은 못하겠으나 나 같은 경우에는 주로 후자의 방식으로 출제해왔다. 나는 특정 자료구조나 알고리즘같은 틀을 하나 생각해놓고 이 틀에 맞는 상황을 위에 덧씌우는 방식으로 한다.&lt;/p&gt;
&lt;p&gt;보통은 출제 기간 전부터 &apos;이 분야를 출제하고 싶다&apos;로 마음 속에 염두에 두는 몇 문제가 있었는데, 이번 대회는 교내 대회인 APC가 끝난 직후에 바로 출제에 들어가다보니 쉽지가 않았다. 이미 내 머릿속에 있는 문제 pool은 고갈된 상태였는데 여기서 억지로 문제를 짜내야 하는 상황이었다. 그렇게 계속 머리를 굴려보다가 수직선상에서의 선분을 겹치는 문제를 내보고 싶다는 생각이 강하게 들어서 이쪽으로 방향을 틀었다.&lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;union-find&lt;/code&gt; 를 활용한 선분겹치기 문제를 내고 싶어서 문제 상황을 만들어봤는데, 나중에 선제 과정에서 얘기를 하면서 굳이 &lt;code class=&quot;language-text&quot;&gt;union-find&lt;/code&gt;를 쓰지 않고도 더 쉬운 풀이가 있다는 걸 알았다. 그래서 이 문제를 고수할 지 다른 새로운 문제를 만들지를 결정해야했다. 평소대로라면 새로운 문제를 만들려고 시도해봤을텐데 이번엔 그러질 못했다.&lt;br&gt;
아무래도 출제뿐만 아니라 다른 업무도 겸해야하고, 무엇보다 머릿속에 문제가 완전 고갈된 상태였기 때문에 자신이 없었다. 그래서 처음 나온 문제를 디벨롭하기로 결정했다.&lt;/p&gt;
&lt;p&gt;10월 말에 1차 선제를 진행했다. 대회 전체 문제수는 통상적으로 8문제를 내는데 여기서는 예상보다 많은 13문제나 나왔다. 선제 과정에서는 출제진들끼리 각 문제를 두고 문제의 솔루션이나 난이도, 그리고 대회장에서 참가자들이 어떻게 받아들일지를 토의한다. 그래서 어떤 문제는 너무 typical 하다거나, 혹은 디스크립션이 이해하기 어렵다거나 하는 식으로 피드백을 주고 받는다.&lt;/p&gt;
&lt;p&gt;1차 선제는 가장 처음으로 하는 토의고 출제진간의 시각 차이가 크므로 이 과정이 길어질 수밖에 없다. 이 과정에서 나의 (문제를 만든)발상과 나의 워딩이 다른 사람들에게 어떻게 전달되는지를 파악할 수 있는 좋은 기회라고 생각한다.&lt;br&gt;
예를 들어 본인 입장에선 멋진 발상으로 만든 문제인 줄 알았는데 알고보니 뻔한 문제였다라든가, 문제 설명만 보고 누구나 다 이해할 줄 알았는데 실제로는 난해하다는 평을 받기도 한다.&lt;/p&gt;
&lt;p&gt;그렇게 2차,3차 선제를 거듭하면서 문제 pool중에서 출제할 만한 &apos;옥석&apos;같은 문제을 가리고 다듬는 과정이 반복하면서 최종적으로 9문제가 선정되었다. 문제 선정까지 완료되면 출제 플랫폼인 polygon에서 문제 데이터를 위한 또다른 업무가 시작된다. 이 과정 역시 사람들의 학교 시험기간이 겹치면서 2주가량 소요되었다.&lt;/p&gt;
&lt;p&gt;출제상의 오류는 없는지 확인하기 위해서 외부인의 검수 과정도 필요하다. 데이터 작업까지 모두 끝나고나서 검수를 시작할 수도 있지만, 시간이 촉박했기 때문에 데이터 작업과 검수를 동시에 시작했다. 문제의 디스크립션 상의 모호한 점이나, 대회의 체감 난이도, 데이터의 엣지 케이스와 카운터 케이스를 미리 피드백 받을 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;이 험난한 과정을 거친 뒤에 나온 문제들은 아래에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/detail/2984&quot;&gt;출제된 문제 (BOJ)&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;후원사를 구해야한다&lt;/h2&gt;
&lt;p&gt;12월 초중순쯤 되자 데이터 작업도 완료하며 출제 프로세스는 어느 정도 막바지에 이르렀다. 이제 본격적으로 후원 업체를 섭외하러 가야한다. 그 전에 다행히도 몇 가지 희소식이 있었다. 첫 번째는 11월에 내가 네이버 D2에 대회 후원 요청 메일을 보냈는데, 후원해줄 의향이 있다고 답장이 온 것이다! D2는 지난 대회에서도 여러번 후원해준 사례도 있었고 대체로 대학생 행사 후원에 대해서 상당히 호의적이다.&lt;/p&gt;
&lt;p&gt;그리고 두 번째는 소학회 담당 교수님께서 우리만 괜찮다면 네트워크를 활용하여 후원기업을 섭외를 도와주실 수도 있다고 말씀해주셨다. 나는 당연히 교수님께 도움을 요청드렸고 덕분에 한시름 놓을 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;그래도 가만히 앉아서 안주하고 있기에는 혹시나 섭외가 틀어질 수도 있는 상황을 대비해야 했기에 다른 업체 한 곳만 더 찾아보기로 했다. 여러 업체가 물망에 올랐는데(대부분 졸업 선배와 연계된 곳) 작년 대회를 후원해준 업체에 한번 더 요청을 드리기로 했다.&lt;/p&gt;
&lt;p&gt;이곳 역시 졸업 선배님이 계신 곳이었기 때문에, 페이스북 메신저로 개인적으로 연락을 드려봤는데 안타깝게도 답장이 없으셨다(아마 확인을 못하셨던 것 같다). 그리고 그 무렵에 학교로부터 (교수님이 말씀하신대로) 후원기업을 찾았다는 연락을 받았기 때문에 우선 대회를 개최할 수 있는 최소한의 후원 기업은 확보되었다. 그래서 그냥 그만둘까 싶기도 했는데 그래도 혹시 모르는 심정으로 회사 대표 메일로 &apos;후원 제안 메일&apos;을 보냈다.&lt;/p&gt;
&lt;p&gt;회사의 정문을 내가 쿵쿵 두드린 것과 마찬가지인 행위여서 좀 무모했다고 생각했다. 선배님께 직접 이 메일이 닿게 될 지도 확신할 수 없었다.며칠동안 답장이 없어서 그냥 거절당했구나 생각했다.&lt;br&gt;
그러다가 일주일 만에 답장을 받았다! 다행히 회사에 계신 선배님까지 닿아서 직접 연락할 수 있게 되었다. 회사도 후원에 대해서 긍정적이라는 뜻을 전달받고 학교 측과 연결해주었다. 정말 다행이다 싶었다. 메일을 보내길 잘한 것 같다.&lt;/p&gt;
&lt;h2&gt;수 많은 잡다한 일&lt;/h2&gt;
&lt;p&gt;12월 말쯤 되었을 땐 후원사 섭외랑 출제 부분같은 큼직한 부분은 해결이 되었지만 아직 수많은 작고 작은 일들이 산적해있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이제 학교별 대회 참가자 명단을 받아야 한다. 그리고 감독해줄 각 학교별 스태프도 구해야한다.&lt;/li&gt;
&lt;li&gt;대회 포스터도 만들어야 한다. 사실 처음부터 만든 건 아니고 작년에 쓰던 포스터 시안을 내가 살짝만 바꿨다. 썸네일에 걸려있는 포스터가 내가 바꾼 버전이다.&lt;/li&gt;
&lt;li&gt;BOJ에 문제의 최종 버전을 확인받고 대회용 계정을 받아야한다.&lt;/li&gt;
&lt;li&gt;참가자들에게 대회 안내 메일을 발송해야 한다.&lt;/li&gt;
&lt;li&gt;온라인 대회이므로 zoom 을 통한 회의실 배정과 대회 매뉴얼도 만들어서 공지해야한다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shake.codes&quot;&gt;대회 페이지&lt;/a&gt;를 수정해야 한다.&lt;/li&gt;
&lt;li&gt;후원사 등장 문제를 만들어야 한다. 조금 늦게 결정되는 바람에 새로운 문제를 만들 여력은 없었고, 내가 기존에 출제했던 문제의 디스크립션을 각색하는 방향으로 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;대회 당일, 사회자&lt;/h2&gt;
&lt;p&gt;대회 당일이 되었다. 나는 그 날 대회 개회식의 사회자 역할을 맡게 되었다. 살다보니 이런 날도 온다. 개회식은 온라인 생방송으로 진행되고 대회 참가자들과 교수님들이 참석하시는 나름 부담감 넘치는 자리이다. 이런 곳에서 내가 사회를 해야 한다니... 처음에는 아무렇지 않을 줄 알았는데 생방송 시간이 다가오니 살짝 떨리더라.&lt;br&gt;
물론 스크립트가 있고 나는 그냥 따라 읽으면 되는 간단한 역할이기는 한데 생방송이기도 하고 참가자들 앞이 아니라 카메라 앞에서 하려니깐 더 긴장되었던 것 같다. 차라리 오프라인으로 하는 게 훨씬 편할 것 같다.&lt;/p&gt;
&lt;p&gt;그렇게 무사히 개회식이 끝나고 약간의 휴식시간 뒤에 대회가 시작되었다. 대회가 진행되는 도중에는 &apos;제발 문제에 출제오류가 없기를...&apos;하면서 계속 빌고 있었다. 아무리 검수를 거친다고는 하지만, 검수 과정에서도 필터되지 않은 오류가 있기도 마련이다. 그 오류가 제발 이번 대회만큼은 피해가기를 빌었다. 다행히 대회가 끝날 때까지 아무런 오류는 없었다. 그리고는 스코어보드를 공개하며 수상자를 발표했고 대회의 모든 일정이 마무리되었다. 다 끝나고나니 긴장이 싹 풀리면서 안도의 한숨을 내쉬었다. 지난 3달간 바쁘게 달려온 행사가 드디어 막을 내리게 된 것이다.&lt;/p&gt;
&lt;h2&gt;대회가 끝난 뒤&lt;/h2&gt;
&lt;p&gt;대회가 끝나고 난 뒤에도 여전히 할 일은 남아있다. 대회 스태프와 검수진들의 급여를 지급하기 위한 각종 서류들을 취합해서 학교에 전달해야 한다. 그리고 대회 수상자 목록도 정리해서 알려줘야 하고, 출제진들이 각자 출제한 문제들의 풀이를 슬라이드로 만들고 나는 이것들을 한꺼번에 모아서 merge한 후에 배포해야 한다. 마지막으로 참가자들에게 대회 종료 및 결과 안내 전체 메일을 발송하면 내가 할 일은 모두 마무리 된다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;h4&gt;1. 서류지옥,서류지옥...&lt;/h4&gt;
&lt;p&gt;작성해야할 서류가 정말 어마무시하게 많다. 덕분에 한동안 내 컴퓨터의 바탕화면은 서류파일로 가득 차 있었다.&lt;/p&gt;
&lt;h4&gt;2. 코로나 이슈&lt;/h4&gt;
&lt;p&gt;기존에는 프로그래밍 대회가 오프라인으로 진행되었지만, 최근 2년동안에는 코로나로 인해서 모두 온라인 대회로 전환되었다. 나도 지난 APC에서 이미 온라인 대회를 치룬 적이 있었기 때문에 이번 대회 운영이 그렇게 생소하지는 않았으나 여전히 온라인 대회에는 어려운 점이 많다.&lt;/p&gt;
&lt;p&gt;그 중 하나는 부정행위와 관련된 사안이다. 오프라인 대회 시절에는 강의실에서 참가자들이 모여서 진행하기 때문에 관리 감독하기에 용이했지만 온라인 대회에서 우리가 참가자들을 볼 수 있는 건 오직 zoom을 통해 송출되는 화면 뿐이다. 나 말고도 감독스태프가 있기도 하고, 참가자들의 양심을 신뢰해야겠지만 만약 소수의 악의적인 참가자가 온라인 대회의 특성을 악용하는 게 아닐까 하는 불안한 마음이 대회 진행 내내 머릿속에 맴돌았다(그런 사람이 절대 없기를 바란다).&lt;/p&gt;
&lt;p&gt;그리고 도중에 참가자가 모르는 사이에 캠이 꺼져서 스태프가 화면을 볼 수 없는 경우도 생기는데, 이럴 경우에 일정 시간내에 재접속하지 않으면 실격처리된다. 이 또한 일일이 공지하고 신경쓰느라 애를 먹었던 부분이다.
또한 부차적인 문제이지만 온라인 대회라서 그런지 오프라인 대회보다 중도 포기자가 훨씬 더 많이 발생해서 아쉬운 마음이 들었다.&lt;/p&gt;
&lt;h4&gt;3. 일정 관리&lt;/h4&gt;
&lt;p&gt;이번 대회는 1월 15일에 열렸고, 프로세스는 10월 중순 쯤 시작했으니 약 3달 동안의 준비기간이 있었다. 3달이 그렇게 촉박한 시간까지는 아니었을 수 있으나 위에서도 얘기했듯이 한 사람이 &lt;strong&gt;출제&lt;/strong&gt; + &lt;strong&gt;운영&lt;/strong&gt; + &lt;strong&gt;섭외&lt;/strong&gt; 업무를 동시에 담당해야 한다는 점을 감안한다면 결코 넉넉치는 않은 시간이었다.&lt;/p&gt;
&lt;p&gt;그래서 이번에는 특히 일정 관리에 주의를 기울였던 것 같다. 3가지 요소 중에서 어느 하나라도 진도가 뒤쳐지면 대회에 차질이 생기기 때문에 각 요소별로 &apos;언제까지는 이만큼을 만들어놓자&apos; 식으로 타임라인을 정해가면서 준비했던 게 주효했다.&lt;/p&gt;
&lt;p&gt;또한 각 학교별로 참가자 명단 같은 정보들을 취합해야 하는 경우가 많았는데, 이런 타입의 업무는 내가 열심히 한다고 끝나는 일이 아니라, 각 사람이 모두 협조를 해주어야만 끝날 수 있기 때문에 특히 더 시간적으로 예민해졌다. 이때 가장 중요하다고 생각하는 게 사람들에게 &apos;나는 지금 이러이러한 일을 처리해야하기 때문에, 여러분들은 OO일 OO시까지 이 업무가 완료되도록 해야한다&apos; 는 의사전달을 확실히 표현해야한다는 점이다. 여기서 강조하고 싶었던 것은,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내가 어떤 일을 해야하는 이유와 배경&lt;/li&gt;
&lt;li&gt;그래서 상대방이 해야할 일&lt;/li&gt;
&lt;li&gt;그 일의 마감시간 이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;모든 일을 처리할 때에 있어서 항상 3가지 원칙을 상대방에게 전달하고자 했으며, 이를 통해 상호간 일의 능률이 향상된다는 점을 몸소 체험했다.&lt;/p&gt;
&lt;h4&gt;4. 설문조사 결과&lt;/h4&gt;
&lt;p&gt;대회가 끝나고 난 뒤, 참가자들이 실시한 설문조사 결과를 받았다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/faf76aef5bfe3d5dbf7295a0627947a0/1b1d5/survey.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.632911392405056%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABbUlEQVR42n2SO0sDQRSFR21EG5ukE6wsBBt/gH/BJrV2drbpBSuxsDDBR7ASwTRWFgEtBC0sRRAViY9AonGza7KJcZ6fuERhY+I0w3CH75577hFKKXzfp1bzCYKAsBHieR7Vtzd8v4bUiv+Oc/G3aIYh5XKFeiNEa41SGikln59tlPzAWYt1FmNNP2QcaK3FGIPrbtX56GJq3B+csqCVjsREwH4drW7D5Ro7RynmjhY4eTzuVOPQSimg+vpKvd7oA3Q2uvTpIqwLNrJjiEyCZC7JwUM+qhlnfs1rPpxxe33FR1v2AHZgBDeY7RHYHOBkN0Fia5qJ5SmWVtPRAN8qf8YvPt1RLBbxvBrWum5gx/iXC1xWwOYg9dwwl5lJSukZqispnFGx9UpPoaWi1WpFPoqeGZDvsD8JuVFcbhh2hiAj4Hw+PkmP09dDnguwNx4ptVmBO5zFheU/4evevPg3ra0y3OehVADT7pm7boVfDOzoDXr6p9oAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;survey&quot;
        title=&quot;&quot;
        src=&quot;/static/faf76aef5bfe3d5dbf7295a0627947a0/f058b/survey.png&quot;
        srcset=&quot;/static/faf76aef5bfe3d5dbf7295a0627947a0/c26ae/survey.png 158w,
/static/faf76aef5bfe3d5dbf7295a0627947a0/6bdcf/survey.png 315w,
/static/faf76aef5bfe3d5dbf7295a0627947a0/f058b/survey.png 630w,
/static/faf76aef5bfe3d5dbf7295a0627947a0/1b1d5/survey.png 876w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;문제 난이도 &apos;적절함&apos; 72.4%, &apos;어려움&apos; 24.1%&lt;/p&gt;
&lt;p&gt;설문에 여러가지 항목이 있었는데 내가 가장 관심있는 항목은 참가자들이 느끼는 문제 난이도였다. 대회 문제의 난이도 세팅은 내가 대회를 앞두고 가장 조마조마했던 부분이었다. 지금까지 출제한 대회(그리고 대부분의 프로그래밍 대회)에서 출제 회의 당시에 문제의 예상 난이도를 책정하는데, 출제진은 참가자들보다 문제의 난이도를 하향평가하는 경향이 짙기 때문이다(2021 APC에서 제대로 경험했다).&lt;/p&gt;
&lt;p&gt;따라서 참가자들에게 적절한 난이도를 제공하기 위해서는 출제 당시에는 &apos;조금 쉬울 것 같다&apos; 라는 느낌이 들어야 출제진과 참가자들의 체감 난이도 간극을 좁힐 수 있다고 생각했다. 그래서 이번 출제 과정에서도 문제 난이도 배정과 관련하여 출제진들과 신경써서 많은 얘기를 나눴었는데, 실제 대회에서도 제대로 반영된 것 같아서 다행이었다.&lt;/p&gt;
&lt;p&gt;그리고 그 밖의 대회에서 아쉬웠거나 보완되었으면 하는 점도 응답을 받았는데 다음과 같은 의견들이 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대회 일정, 규칙 공지를 더 빨리 해 주었으면 좋겠다. (7명)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이건 명백한 내 잘못이었다. 대회 사이트와 각 학교 대표진들에게는 미리 공지를 하긴 했었는데 참가자들에게 직접적으로 전달하는 방식이 아니었기에 확인하지 못한 참가자는 대회 공지를 늦게 확인할 수 밖에 없었을 것이다.&lt;/p&gt;
&lt;p&gt;다음부터는 조금 더 여유있고 직접적인 방식으로 참가자들에게 안내를 할 수 있도록 바꿔야겠다. 대회 규칙 또한 온라인대회이다 보니 참가자 입장에서도 어떤 행위가 허용되는지 안되는지 혼란스웠을 것이다. 나 역시도 온라인 대회 운영은 익숙치 않다보니 규칙을 제정함에 있어서도 놓치거나 서툴렀다. 다음부터는 대회 규칙을 사전에 자세하게 안내할 수 있도록 해야겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대면으로 진행되었으면 좋겠다.(2명)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저두요...&lt;/p&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;10월 중순부터 대회 당일날까지 꽤나 바쁘게 살았다. 처음 내가 운영을 맡고자 했을 땐 &apos;누군가가 해야할 일이라면 내가 하는게 낫다&apos;라는 심정으로 나섰다. 출제도 몇 번 해봤겠다, 내친김에 대회 운영까지도 못할 게 뭐가 있겠냐 싶어서 달려든 마음도 있었던 것 같다.&lt;/p&gt;
&lt;p&gt;그런데 운영은 출제와는 다른 운영만의 어려움이 있다. 출제에서 필요한 역량과 운영에서 필요한 역량은 확연히 다르다. 결이 다르다고나 할까? 그래서 대회를 운영하면서 나한테 부족했던 역량을 확인하고, 또 내가 잘 처리할 수 있는 업무는 무엇인지 확인할 수 있게 되었다.&lt;br&gt;
그리고 다양한 위치와 입장에 있는 사람들과 컨택을 해보면서 그 사람에게 필요한 것, 그 사람이 요구 하는 것, 그리고 내가 그 사람에게 해줄 수 있는 것이 무엇인지 빠르게 파악하는 능력이 중요하는 것도 깨달았다.&lt;/p&gt;
&lt;p&gt;지금 이 글이 shake!의 차기대회를 준비하게 될 누군가, 또는 프로그래밍 경시 대회를 준비하는 누군가에게 조금이나마 도움이 될 수 있기를 바란다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[nextTick()은 언제쓸까?]]></title><description><![CDATA[nextTick()이란? Vue를 공부하다보면 Global API의 한 종류로서 이라는 함수를 접하게 된다.
Vue 공식문서에서는 이렇게 설명하고 있다. When you mutate reactive state in Vue, the resulting…]]></description><link>https://juheon.dev/vue/230906-nexttick/</link><guid isPermaLink="false">https://juheon.dev/vue/230906-nexttick/</guid><pubDate>Wed, 06 Sep 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;nextTick()이란?&lt;/h2&gt;
&lt;p&gt;Vue를 공부하다보면 Global API의 한 종류로서 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;이라는 함수를 접하게 된다.
&lt;a href=&quot;https://vuejs.org/api/general.html#nexttick&quot;&gt;Vue 공식문서&lt;/a&gt;에서는 이렇게 설명하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you mutate reactive state in Vue, the resulting DOM updates are not applied synchronously. Instead, Vue buffers them until the &quot;next tick&quot; to ensure that each component updates only once no matter how many state changes you have made.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt; can be used immediately after a state change to wait for the DOM updates to complete. You can either pass a callback as an argument, or await the returned Promise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue에서 반응형 변수의 값을 변경할 때, 그 결과는 DOM에 동기적으로 반영되지 않는다. 대신 Vue는 각 컴포넌트가 몇번이나 변경되었느냐와 상관없이, &quot;next Tick&quot;까지 버퍼에 담아놓아서 반드시 한번만 업데이트 됨을 보장한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;은 DOM의 업데이트가 완료될 때까지 기다리는 데 사용할 수 있다. 콜백함수나 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 await할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;쉽게 얘기해서, &apos;코드 상에서 데이터가 바뀌더라도 DOM에는 즉각적으로 반영되지 않으니 강제로 반영하고 싶다면 이 함수를 호출해라&apos; 라는 의미다.&lt;/p&gt;
&lt;p&gt;스크립트단에서 적용된 코드가 곧바로 DOM에 반영되지 않는다는 사실은 vue뿐만 아니라 react를 접해본 사람이라면 생소한 얘기는 아닐 것이다. 최적화를 위하여 화면을 그리는 렌더링 과정은 batch로 처리되기 때문이다. 그래서 react, vue 라이브러리를 처음 공부하는 시기에는 내가 생각했던 렌더링 결과와 다르게 나와서 당황했던 경험이 다들 한번씩은 있을 것이다. 그래서 이런 불편한 상황을 해결하기 위하여 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수가 존재하는 것이다.&lt;/p&gt;
&lt;h2&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;사실 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수의 사용빈도가 많지는 않지만, 가끔씩 필요한 상황은 있기 때문에 이런 함수의 존재여부를 알고있다는 자체만으로도 도움이 된다. 지금까지의 경험상 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;이 필요한 상황은 다음과 같았다.&lt;/p&gt;
&lt;h4&gt;비동기로 데이터를 받아온 후에 container의 size를 조정해야할 때&lt;/h4&gt;
&lt;p&gt;아래와 같이 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt; 라는 비동기 함수를 통해 데이터를 받아와서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;에 보여주는 상황을 생각해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;textarea class=&amp;quot;container&amp;quot; v-model=&amp;quot;data&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  const data = ref(&amp;quot;&amp;quot;)
  const fetchData = () =&amp;gt; {...}

  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 data가 담기는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt; 에는 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;width, height, overflow-y:scroll&lt;/code&gt;가 있어 정해진 사이즈로만 렌더링되어야 하는 제약이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.container {
  width: 200px;
  height: 100px;
  overflow-y: scroll;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;에 스크롤이 생긴 채로 보이게 된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ce8cdb47ae2eb1144b9e8d5e2647600f/05fb0/before.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 67.72151898734178%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAvElEQVR42u2PywqDMBBF8///5gNNsWnSoNCqpIILH9X6uGUCQil0Eemiiw5cZhKYwxk2TRPG8YGu73G55kiOAkkiIE4S6qxhbjensK7r0LYtmqZBXdeoqgp5UdhO//dhcArzfR8Uz/MQBAEOnCNNU5RliWVZ4FosiiKEYQghBDjnds6yDMYYzPPsDiQ7KaUFxnEMpZQNnbvLUGttjQhKp252BFzX1R1IS2SyLb93Z+DrYy/kI/Ab9Qf+IPAJHwtIUyVwItwAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;before&quot;
        title=&quot;&quot;
        src=&quot;/static/ce8cdb47ae2eb1144b9e8d5e2647600f/f058b/before.png&quot;
        srcset=&quot;/static/ce8cdb47ae2eb1144b9e8d5e2647600f/c26ae/before.png 158w,
/static/ce8cdb47ae2eb1144b9e8d5e2647600f/6bdcf/before.png 315w,
/static/ce8cdb47ae2eb1144b9e8d5e2647600f/f058b/before.png 630w,
/static/ce8cdb47ae2eb1144b9e8d5e2647600f/40601/before.png 945w,
/static/ce8cdb47ae2eb1144b9e8d5e2647600f/05fb0/before.png 1138w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 한가지 요구사항을 추가해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;의 길이에 따라서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;의 높이가 자동적으로 조정되어야 한다. 즉 스크롤이 생기지 않고 한 화면에 모든 텍스트가 다 들어와야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단순하게 생각해보면 css에 &lt;code class=&quot;language-text&quot;&gt;{height : fit-content}&lt;/code&gt;속성을 추가해주면 될 것 같지만 실제로는 작동하지 않는다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 비동기로 받아오기 때문에 &lt;strong&gt;화면을 렌더링하는 시점에는 아직 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;의 길이를 알 수 없기 때문&lt;/strong&gt;이다.&lt;br&gt;
따라서 우리는 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 받아오고 난 후(=길이가 얼마인지 알 수 있는 시점)에 DOM에 다시 접근하여, 그 길이에 맞춰서 다시 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;의 높이를 &lt;code class=&quot;language-text&quot;&gt;JS&lt;/code&gt;를 통해 조절해야 한다.&lt;/p&gt;
&lt;p&gt;그래서 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;scrollHeight&lt;/code&gt;값을 받아와서 직접 높이값을 설정해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;textarea class=&amp;quot;container&amp;quot; v-model=&amp;quot;data&amp;quot; ref=&amp;quot;textRef&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  ...
  const textRef = ref(null);
  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
    const scrollHeight = textRef.value?.scrollHeight; // scrollHeight 설정!
    textRef.value.style.height = scrollHeight + &amp;#39;px&amp;#39;;
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 받아올 때 까지 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 걸어주었으니 높이가 딱 맞게 조정될 것 같다. 하지만 실제로 실행해보면 결과는 여전히 위와 동일하다. 왜 반영되지 않은 것일까?&lt;/p&gt;
&lt;p&gt;그 이유는 글 초반부에 설명했다시피, &lt;strong&gt;스크립트단에서 적용된 코드가 곧바로 DOM에 반영되지 않기 때문&lt;/strong&gt;이다.&lt;br&gt;
즉 &lt;code class=&quot;language-text&quot;&gt;data.value = await fetchData()&lt;/code&gt;라는 코드가 실행된 직후라도, 실제로는 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;가 DOM에는 반영되지 않은 것이다!&lt;/p&gt;
&lt;p&gt;그렇다면 우리에게 필요한 것은? 드디어 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수가 등장할 차례이다. 해당 코드 다음 줄에 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수를 호출하면 &lt;em&gt;&apos;지금까지의 변경사항을 DOM에 적용해줘!&apos;&lt;/em&gt; 라고 요청하는 것과 같은 의미이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;...&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  ...
  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
    await nextTick(); // DOM에 곧바로 반영!
    const scrollHeight = textRef.value?.scrollHeight; // scrollHeight 설정!
    textRef.value.style.height = scrollHeight + &amp;#39;px&amp;#39;;
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;그러면 이제 요구사항처럼 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;가 스크롤 없이 텍스트 길이에 맞춰서 높이가 조정된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1d8ff32cbbdea79a415644ce34f2f29c/f43e4/after.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 74.68354430379746%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA0ElEQVR42u2STQuCQBRF/f9/zIWKn6iomSFEo4maOTg6cuMNtGnVRLt6cLirOdzHG0MIASklFiEwzxznC8OhPCqO1QmsaTHdZ9ym+1sYfd9jGAZQdl2nuF47NE2DmXNsUmphpGmKMAwRBIHKOI6RZRnatsWyLNAdI4oimKYJ27bh+z4cx4FlWajrGuu66gtJ4rou8jyH53mqIVGW5WdCWi9JElBTyqIowBgDHeujlanNU1RVFcZxxL7vSsg51xfS41foG23bplJbiC/PX/gLwgf5FZZu4quhjwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;after&quot;
        title=&quot;&quot;
        src=&quot;/static/1d8ff32cbbdea79a415644ce34f2f29c/f058b/after.png&quot;
        srcset=&quot;/static/1d8ff32cbbdea79a415644ce34f2f29c/c26ae/after.png 158w,
/static/1d8ff32cbbdea79a415644ce34f2f29c/6bdcf/after.png 315w,
/static/1d8ff32cbbdea79a415644ce34f2f29c/f058b/after.png 630w,
/static/1d8ff32cbbdea79a415644ce34f2f29c/40601/after.png 945w,
/static/1d8ff32cbbdea79a415644ce34f2f29c/f43e4/after.png 1120w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[내가 대학교에서 배운 것]]></title><description><![CDATA[대학생활 회고(라 쓰고 '추억팔이'로 읽는다) 지난 주에 드디어 대학교를 졸업했다. 2017년 2월에 입학한 나의 대학생활은 장장 6년…]]></description><link>https://juheon.dev/essay/230901-what-i-learn-in-college/</link><guid isPermaLink="false">https://juheon.dev/essay/230901-what-i-learn-in-college/</guid><pubDate>Fri, 01 Sep 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;대학생활 회고(라 쓰고 &apos;추억팔이&apos;로 읽는다)&lt;/h2&gt;
&lt;p&gt;지난 주에 드디어 대학교를 졸업했다. 2017년 2월에 입학한 나의 대학생활은 장장 6년 6개월에 걸친 여정 끝에 막을 내리게 되었다. 이대로 나의 대학 생활이 아득한 추억 속에서 휘발되기에는 아쉽다고 생각해서 내가 대학교에 다니면서 들었던 강의들, 그 외에 의미있었던 활동들을 기억 깊숙한 곳에서 끄집어내서 박제하려고 한다. 전공과목 여부와 상관없이 나의 대학 생활에서 의미있는 영향을 끼친 강의들과, 어떤 방식으로 영향을 끼쳤는지를 중점적으로 소개하려고 한다.&lt;/p&gt;
&lt;h2&gt;유난히 독특했던 한 컴공생...&lt;/h2&gt;
&lt;p&gt;내가 들었던 강의들이 다른 컴공과 학생보다 유별난 구석이 있다. 특히나 교양과목에서 두드러지는데, 나는 교양과목을 선택할 때 나름의 철칙이 있었다. 바로 전공과 관련없는 분야의 학문의 강의를 많이 들으려고 했다는 점이다.&lt;/p&gt;
&lt;p&gt;사람마다 대학교에서 얻으려는 목표는 각기 다를 수 있다. 누군가는 졸업장만 필요할 수 있고, 누군가는 높은 학점을 받아서 좋은 회사나 대학원을 가는 게 목표일 수 있다. 하지만 나의 경우에 그보다 더 중요시 여긴 목표는 &lt;strong&gt;내가 모르는 세상을 최대한 많이 접해보자&lt;/strong&gt; 였다.&lt;/p&gt;
&lt;p&gt;우리는 대부분 초중고등학교부터 항상 점수에 얽매인 인생을 살아왔다. 그리고 흔히들 대학교에 가면 시험으로부터 해방된다, 마음대로 해도 된다는 이야기를 하는데 막상 대학교에 와서도 크게 달라진 게 없다는 인상을 받았다. 대학교에서 와서도 또다른 학점 경쟁, 수강신청 경쟁을 하고 있는 내 자신의 모습에서 현타가 느껴지면서 회의감을 품게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6871354038a99bf11656a7fd6ab12baa/9568a/graduate.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAH/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAGLzjCoMSdxaabgUIf/xAAeEAABBAIDAQAAAAAAAAAAAAACAAEDERMhEiIxMv/aAAgBAQABBQKCTGcr22l9lZKPQl0ALycVL7G1C6//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAYEQEBAAMAAAAAAAAAAAAAAAAAEQEhQf/aAAgBAgEBPwHa5cR//8QAHxAAAQMDBQAAAAAAAAAAAAAAAAEQIREicTFRkaGx/9oACAEBAAY/AtxeSCLsCw3hk07arf/EAB0QAQEBAAMAAwEAAAAAAAAAAAERACExQWFxgZH/2gAIAQEAAT8hS4nhM6w99XclimB6gPgTJQ1O45hlD7MrJw3hrQOUAS51YhBysd+P5v/aAAwDAQACAAMAAAAQfDUx/8QAFxEBAQEBAAAAAAAAAAAAAAAAABEBQf/aAAgBAwEBPxCJjqv/xAAYEQEBAQEBAAAAAAAAAAAAAAABABEhUf/aAAgBAgEBPxB8WXCEEWL/xAAfEAEAAgEEAwEAAAAAAAAAAAABABEhMUFRYXGBkbH/2gAIAQEAAT8QpiMbFvfG8ETbc6FO0FXIalEoJDsMh48w6mXCGL6ufWsl7gKDAQ1efUrCKMiXeMzEAChK4+RqyqnMrpKTkKr9YrRTRwn/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;졸업식&quot;
        title=&quot;&quot;
        src=&quot;/static/6871354038a99bf11656a7fd6ab12baa/828fb/graduate.jpg&quot;
        srcset=&quot;/static/6871354038a99bf11656a7fd6ab12baa/ff44c/graduate.jpg 158w,
/static/6871354038a99bf11656a7fd6ab12baa/a6688/graduate.jpg 315w,
/static/6871354038a99bf11656a7fd6ab12baa/828fb/graduate.jpg 630w,
/static/6871354038a99bf11656a7fd6ab12baa/0ede0/graduate.jpg 945w,
/static/6871354038a99bf11656a7fd6ab12baa/3ac88/graduate.jpg 1260w,
/static/6871354038a99bf11656a7fd6ab12baa/9568a/graduate.jpg 3024w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;그래서 나는 대학생활만큼은 정말 &apos;즐겜&apos; 하고 싶었다. 점수에 연연하지 말고 내가 정말 듣고 싶은 과목, 궁금한 분야의 과목을 들어보고 싶었다. 어차피 컴공이 전공이기 때문에 컴퓨터 관련과목은 실컷 듣게 될테니, 교양과목은 완전히 반대되는 분야인 인문/사회 계열을 듣고 싶었다. 단순히 그 분야의 지식이 궁금했기 때문이기도 하지만, 더 궁금했던 건 그 분야를 &lt;strong&gt;몇십년동안 연구했던 학자들이 세상을 바라보는 시선&lt;/strong&gt;을 알고 싶었기 때문이다.&lt;/p&gt;
&lt;p&gt;한 분야를 오랫동안 공부한 사람은 자연스럽게 세상을 바라보는 시선 또한 자신의 분야에 맞춰져서 바라보는 경향이 짙어진다.일반인의 시선으로는 발견하지 못했던 부분들도 연구자에게는 다르게 보이기 마련이다. 마치 카메라에 색깔 필터를 적용하면 세상이 온통 그 색깔로만 보이는 것처럼 말이다. 나는 세상을 하나의 필터로만 바라보고 싶지 않았다. 나에게는 여러 종류의 필터가 있었으면 하는 바람이 있었다.&lt;/p&gt;
&lt;p&gt;대학교에서 등록금을 내고 수업을 듣는다는 건, 그 연구자의 시선으로 세상을 바라보는 방법을 조금이나마 배울 수 있는 기회를 제공받는다고 생각한다. 대학교는 이러한 다양한 분야의 연구자들을 한 곳에 모아둔 공간이고 인생에서 몇 안되는 값진 기회이기 때문에 나는 이 기회를 충분히 활용하고 싶었다.&lt;/p&gt;
&lt;h2&gt;기억에 남는 강의&lt;/h2&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;글쓰기&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;1학년 신입생들은 반드시 들어야하는 강의였다. 대부분의 이과생들에게 &apos;글쓰기&apos;란 물과 기름처럼 친해질래야 친해질 수 없는 관계이다. 나 역시도 처음에는 글쓰기와 거리가 먼 사람이라고 단정지어왔다. 하지만 이 강의를 들으면서 그 생각이 조금씩 바뀌게 되었다.&lt;/p&gt;
&lt;p&gt;일단 교수님이 딱딱하지 않고 유쾌하신 분이었다. 내가 대학교 입학 전에 생각했던 &apos;대학교수&apos;하면 떠오르는 이미지는 엄격하고 보수적인 사람이었는데, 내가 만난 교수님은 학생들과 같이 농담도 나누면서 그 고정관념을 어느정도 깨주셨다. 그리고 &apos;글쓰기&apos;라는 행위에 대해서도 너무 어렵게 접근할 필요없이 &apos;자신이 가장 흥미를 가질만한 분야&apos;를 토대로 글을 작성하면 된다는 식으로 학생들이 갖고있는 글쓰기에 대한 막연한 두려움을 없애기 위해서 계속 우리를 격려해주셨다.&lt;/p&gt;
&lt;p&gt;그리고 중간고사로 과제가 하나 주어졌는데, 아무 주제를 하나 선정해서 1000자 이내의 글을 하나 작성하는 것이었다. 처음 글을 쓸 당시에는 이렇게 쓰는게 맞는지 긴가민가 했다. 머릿속에는 분명 얘기하고 싶은 주제가 있었는데, 그 내용을 텍스트로 옮기려고하면 연기처럼 사라져버렸다. 나의 생각을 텍스트로 실체화하여 변환하는 작업에는 손실이 생기게 되는데, &apos;글쓰기&apos;란 최대한 그 손실을 줄이면서 텍스트로 옮겨내는 과정이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그렇게 내가 쓴 글을 계속 지웠다 썼다를 반복해나가면서 자연스럽게 읽힐 때까지 퇴고했다. 과제를 제출하는 마지막 순간까지도 내 글이 과연 남들에게 어떻게 읽힐지에 대해 불안한 마음을 숨길 수 없었다. 하지만 예상을 뒤엎고 내 글은 교수님으로부터 호평을 받게 되었다. 무엇보다 자신의 이야기를 가감없이 솔직하게 드러냈다는 점이 인상깊었다는 의견을 주셨다.&lt;br&gt;
이 일을 계기로 &lt;code class=&quot;language-text&quot;&gt;&apos;나 생각보다 글쓰기에 소질이 있을지도...?&apos;&lt;/code&gt;하는 자신감을 얻게 되었고 지금의 개발 블로그를 운영하게 되는 시작점이 될 수 있었다고 생각한다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;영화의 세계&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;내가 입학해서 처음으로 선택한 교양과목이라 기억에 남는다. 강의는 이름 그대로 여러가지 영화를 보면서 분석해보고 어떤 의도가 숨겨져 있는지 알아보는 과목이다. 그 당시에 내가 영화 보는 걸 좋아하기도 했고, 보면서 느꼈던 점을 다른사람들과 공유해보고 싶다는 생각이 들어서 신청했다. 나름 인기있는 과목이라 수강신청이 치열했었다.&lt;/p&gt;
&lt;p&gt;중간고사는 단편영화 하나를 보고 분석하는 글을 쓰고, 기말고사는 조별로 영화 한 편을 선정하여 직접 분석해야했다. 내가 있었던 조는 &apos;컨택트&apos;라는 영화를 선정했다. 외계생명체가 지구를 침략하는 내용이었는데,. 그 영화 분석하느라고 당시에 20번 정도 돌려봤다. 지금 생각해보면 교양 과목 하나에 뭐 그렇게 시간을 많이 쏟았나 싶기는 한데, 열정 가득한 1학년 시절이다보니 가능했었던 일인 것 같다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;컴퓨터 구조&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;운영 체제&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;수업도 수업이지만 과제가 어렵기로 유명한 두 과목이다. 아직도 기억에 남는 건 컴퓨터 구조의 첫 번째 과제였는데, C언어로 MIPS Processor를 구현하는 것이었다. 과제 기한은 3주정도 주었는데, 다른 과목이라면 3주가 엄청 널널한 기간이었겠지만, 컴구에서는 과제의 내용을 이해하는데 1주정도 걸리고, 구현하는데 1주가 걸렸었던 기억이 난다.&lt;/p&gt;
&lt;p&gt;과제는 어려웠던 대신에 교수님의 강의력이 뛰어났기 때문에 수업시간에 딴짓하지 않고 100% 강의에 집중하면서 들었던 과목이었다. 컴퓨터의 프로세서, 메모리 구조, 연산 원리, 가상메모리에 대해서 배웠던 기억이 난다. 배울 당시에는 이 지식들을 언제 써먹나 싶었지만 지금 생각해보니 CS지식의 근간을 세우는데 큰 도움이 되고 있어 여러모로 열심히 공부해두길 잘 했다고 생각한 과목이었다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;웹 시스템 설계&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;내가 개발자의 진로를 프론트엔드 개발자로 선택하게된 결정적인 계기가 된 과목이었다. 웹 페이지를 하나 개발하는 프로젝트성 강의였는데, 공교롭게도 이 강의에서 사용한 라이브러리가 &lt;code class=&quot;language-text&quot;&gt;vue.js&lt;/code&gt;였다. 이 라이브러리가 4년이 지난 지금 나의 메인 기술스택이 되리라곤 상상치도 못했다.&lt;/p&gt;
&lt;p&gt;사실 이 과목을 들을 당시에는 내가 웹개발에 대한 경험이 거의 전무하다시피했다. 그래서 DOM이 무엇인지, &lt;code class=&quot;language-text&quot;&gt;vue.js&lt;/code&gt;가 무엇인지 그 때 처음 알게 되었다. 조금 늦게 시작하긴 했지만 그 전까지 내가 공부하던 C,C++와는 완전히 다른 세계였다.맨날 운영체제같은 low-level만 다루는 코딩을 하다가, 처음으로 사용자가 직접 맞닿는 영역에서 개발을 접해보니 신세계였다. 내가 몰랐던 세상 중에서도 이렇게 재밌는 분야가 있었구나, 하는 신선한 충격을 받게 되었다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;정수론&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;많은 사람들은 왜 컴공이 정수론 강의를 들었냐고 물어보겠지만, 그 질문에 대한 나의 답변은 그냥 &apos;궁금해서&apos;이다. 정확히 얘기하자면 당시의 나는 알고리즘 소학회에서 마침 정수론과 관련된 지식(페르마 소정리, 중국인 나머지 정리)들을 공부하고 있었는데 겸사겸사 수학과 강의로 열리니 한번 들어보자는 호기심이 발동해서였다.&lt;/p&gt;
&lt;p&gt;학교를 다니면서 처음으로 타학과의 전공 강의를 들어보았는데, 수학과의 수업은 컴공의 그것과는 상당히 분위기가 달랐다. 가장 결정적인 차이는 수학과는 강의실의 자리가 앞에서부터 채워진다는 점이다. 그리고 강의실의 모든 사람들이 수업에 집중하면서 듣는다는 점도 놀라웠다. 어찌보면 당연한 얘기일 수도 있지만, 컴공과 수업은 보통 자리가 뒤에서부터 채워지고 수업도 일부 듣는 사람만 듣기 때문이다.&lt;/p&gt;
&lt;p&gt;이것이 수학과의 위엄인가...? 나랑 다른 세상에 살고 있는 사람들 같았다. 이 강의를 듣는 내내 수학과 학생들과 교수님이 모두 존경스러웠다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;영화와 사회심리&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;나는 교양과목 중에서 심리학 관련 강의를 유독 좋아했다. 인간은 어떻게 움직이는가, 그리고 인간의 내면을 들여다본다는 점에서 나의 평소 관심사와 상통하는 부분이 있기 때문이다. 그래서 여러 심리학 강의를 들어보았는데 아직까지도 이 강의가 기억에 남는다.&lt;/p&gt;
&lt;p&gt;강의에서는 기본적으로 &apos;사회심리학&apos;관련 이론들을 가르쳐주는데 학생들의 이해를 돕기위해 영화의 한 장면을 예시로 들어서 보여준다는 점이 독특하다. 강의 내용도 심리학 이론을 어렵지 않게 잘 풀어냈기 때문에 재밌게 느껴지기도 했었고, 무엇보다 교수님이 정말 열정적으로 강의해주시는 게 인상적이었다.&lt;/p&gt;
&lt;p&gt;자신의 전공 분야에 있어서 자부심을 느끼면서 강의를 하시는 모습이 듣는 사람에게도 전달될 정도였다. 어쩌면 내가 위에서 언급했던 &apos;세상을 바라보는 시각을 배우기 위해서&apos;라는 취지에 가장 알맞은 강의가 아니었을까 싶다. 나뿐만 아니라 모든 학생들이 그렇게 느끼는건지 강의 평가도 매우 높은 편에 속했고 수강신청 난이도도 어려운 과목이었다.&lt;/p&gt;
&lt;h2&gt;아쉬웠던 점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;책을 많이 못 읽었다.&lt;/strong&gt;&lt;br&gt;
대학교 다니면서 내 나름의 목표 중 하나는 한달에 책 한권씩 읽기였다. 통학할 때 왕복으로 2시간이 넘게 걸렸기 때문에 시간이 그냥 버려지는게 아쉬워서 책을 읽기 시작했다. 1,2학년에는 시간이 널널해서 책을 읽을만한 여유가 있었지만, 3학년부터는 과제와 취업준비에 치이면서 독서에 소홀했었던 점이 아쉽다.&lt;/p&gt;
&lt;p&gt;졸업할 때쯤 대출이력을 살펴보니 약 50권정도 빌린 것으로 나타났는데, 이 중에는 기술서적이나 강의 교재도 포함되어 있어서 실질적으로는 독서를 위한 책은 40권 정도이다.&lt;br&gt;
40권 중에서는 소설이 가장 많았다. 공대생이기 때문에 오히려 정반대 분야의 책을 읽는 게 삶의 균형을 맞추는데 도움이 될 거라고 생각했다. 실제로도 소설을 읽을 때에는 공부할 때와는 다른 뇌의 영역이 활성화되는 느낌이었다(과학적인 근거는 없다). 가장 재미있게 읽은 책은 무라카미 하루키의 &lt;em&gt;&apos;해변의 카프카&apos;&lt;/em&gt; 였다. 나머지는 주로 내가 관심있는 분야인 심리학과 진화학 관련 분야의 책을 빌렸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;더 다양한 사람들을 만나보고 싶었다.&lt;/strong&gt;&lt;br&gt;
나 자신이 지나치게 안전영역(safe area)에만 안주해있었던 게 아닐까 되돌아보게 된다. 개인 성격상 새로운 사람을 만나기 위해 애써 나서지 않는 성격이다보니 항상 아는 사람만 만나게 되었다. 이게 꼭 나쁜 것만은 아니지만 인생에서 &apos;대학교&apos;라는 시기만큼은 조금 더 외향적인 성격으로 나아갔어도 최소한 손해볼 일은 없었을 것이라 생각한다. 하지만 누구나 그렇듯, 자신의 성격은 바꾸기란 쉬운 일은 아니었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개발분야를 좀 더 빨리 접해보고 싶었다.&lt;/strong&gt;&lt;br&gt;
내가 대학교 때 했던 코딩의 90%는 알고리즘과 PS(Problem Solving)이었을 것이다. 어떻게 보면 나의 코딩이 지나치게 PS에 overfitting 되어있었고, 개발이라는 분야는 3학년 후반이 되어서야 처음 접하게 되었다. 늦은 시기는 아니었지만 조금만 일찍 개발을 접했더라면 프론트,백엔드,모바일,ML 등 여러 분야를 두루두루 공부해보면서 내 진로를 찾기까지 충분한 시간이 주어졌더라면 하는 아쉬움이 남는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;이제는 사회 초년생으로&lt;/h2&gt;
&lt;p&gt;대학교는 이제 막 졸업했지만 사회인으로는 아직 병아리에 불과하다. 좀 얼떨떨한 기분이다. 내가 진짜로 사회인이 될 준비가 되어 있는걸까? 세월이 절벽 앞에 서있는 나의 등을 떠미는 바람에 억지로 밀려난 기분이다.&lt;/p&gt;
&lt;p&gt;사회인은 사회인으로서 요구되는 역량이 대학생과 달라지기 때문에 나는 또 다시 공부해야한다. 특히나 내가 가장 걱정인건 금융/재테크 관련 분야이다. 사실 나 이 분야에 관해서는 정말 문외한이다. 내 주변 친구들은 요즘 금리가 어떻고, 주식이 어떻고에 대해서 토론하던데 나는 무슨 소리인지 하나도 모르겠다. 개발자로서는 개발 공부도 해야하지만, 더 큰 범주에서 나는 사회인이기에 이쪽 분야의 공부도 결코 소홀히 할 수 없는 처지이다.&lt;/p&gt;
&lt;p&gt;결국에 내 지식이 다시 초기화되었다. 대학교에 처음 입학했을 때 느꼈던 기분과 유사하다. 이제 좀 대학 생활에 익숙해졌다 싶으니깐 졸업해버리고 새로운 타이틀을 달게 되었다. 인생은 항상 불완전함의 연속이다. 언제쯤되면 나도 사회인으로서 익숙해질 수 있을지 가늠조차 되지 않는다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[개발자가 된 이유]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/essay/230812-why-i-become-developer/</link><guid isPermaLink="false">https://juheon.dev/essay/230812-why-i-become-developer/</guid><pubDate>Sat, 12 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;아주 단순한 계기&lt;/h2&gt;
&lt;p&gt;어린 시절에 나는 컴퓨터를 아주 좋아하는 아이였다. 당연히 주 컨텐츠는 게임이었다. 메이플스토리, 카트라이더, 그랜드체이스를 열심히 했던 기억이 난다. 하지만 그 무렵 대부분의 내 또래가 그렇듯 하루에 사용할 수 있는 컴퓨터 시간은 정해져 있었다. 그래서 나는 어떻게 하면 컴퓨터를 원하는만큼 할 수 있을까 고민에 빠지다가 문득 한가지 생각이 뇌리를 스쳤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로그래머가 된다면 하루종일 컴퓨터를 할 수 있지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 단순무식한 발상이 내가 개발자가 되기로 마음을 먹은 최초의 계기다.&lt;br&gt;
이때 내 나이는 중2(15살), 2011년이었다.&lt;/p&gt;
&lt;p&gt;그날부로 프로그래머라는 직업에 대해서 조사하기 시작했다.&lt;br&gt;
당시에는 프로그래머(개발자)라는 직업에 대한 인식이 지금처럼 좋지만은 않았다. 대부분 야근은 많이하면서 박봉을 받는 일명 3D 직군에 속했기 때문이다. 하지만 중2 시절의 나에게는 겨우 그런 이유들 따위로 꿈을 꺾을 수는 없었다. 오히려 너무 어린 나이였기 때문에 아직 현실의 높은 벽을 마주해보지 못했기
때문일 수도 있다.&lt;/p&gt;
&lt;p&gt;다음으로 개발자가 되기 위해서는 어떻게 해야하는지 찾아 보았다.&lt;br&gt;
&lt;em&gt;&apos;프로그래머는 기본적으로 프로그래밍 언어를 사용하면서 컴퓨터와 상호작용을 하는 직업이다. 그 중에서도 가장 기본은 C언어이다.&apos;&lt;/em&gt;&lt;br&gt;
라는 맥락의 글을 읽었다. 곧바로 나의 다음 목표는 &apos;C언어 마스터&apos;로 정해졌다.&lt;/p&gt;
&lt;h2&gt;프로그래밍과의 첫 만남&lt;/h2&gt;
&lt;p&gt;요즘이야 서점이든 온라인 강의든 C언어를 비롯한 각종 프로그래밍 언어를 학습할 수 있는 방법이 널리고 널렸지만, 그 당시에 프로그래밍 입문자가 독학으로 공부할 수 있는 방법은 거의 전무했다. 그렇지만 나 같은 입문자를 구원해준, 가뭄에 콩 나듯 출시된 입문서가 한 권 있었으니 그 책이 &apos;윤성우의 열혈 C프로그래밍&apos;이었다(이 글을 쓰며 교보문고에서 검색을 해보았는데 놀랍게도 아직까지 절판되지 않고 판매량에서도 상위권에 위치하고 있었다).&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/669cd/c-book.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.54430379746836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHQklEQVR42h3PaVOTBwLA8WdmX9ROV0WqVURAtAgCchguCUeQU4TIIaByWBQU0FYEqxaP2larFVBOuQIkhMskBGISckCOJwFBqKuuttMPsDP7Zr/Df2f6+wY/obMph77SRGazIxjPCEMlO4Qq9SCqvGiUskP0x/kzkBzMkOwQAzlHGEoPYbQgFsWpJIZPShguSUJRlIBCnsBAfS7Ck4YsxiQhiElROPf7shTggzVsH57yfGy+W7Ds+gyb3xdY21qwHIvCnJuG8WwRttx07JHB2CKDsB+Lwh0dwkxpMkKTPJYO/+2sPGzD0nqZ+VA/ZnOkuAc7MUoOMicJwyQ5jLFCjiXAB3thJgNtF3jadZ3BaxUsf1PBG62KpeI85muyEc5nhPL06wBWj0ViTY3BcXgvr/NScFUUIKYcQZnow5DUB/2hzxBjDuCVxiCW5bNyt5XltDjEbCmrN6/ibjiP6dsyhJqMMDqD9/ImxA/n7i3YA7biCvfHfiQIi+QQr2K+QnciGktWHJ7IYETpUTyp8YjxUYh5x3EW52OvLMV5rgTbpSKE81nh9Pr5ok+PQJtyGFtEIOqSfAySUKw5SThP5eCODWUh5QDaBD+M4b5oEwN4GReELjuC+ZPx6EpTcWQcY7m+GKFaFkZvsD+W7HgWEsOw+f4De0YihuNxLKZGsRwbwv18f56lfYU9KQRbdhwWWRSLecksHI9mXi5jMSsOpyQSsakMoSr5AJ2piYh11YjXLmEtPcFYVhSXW3IwTimxnS1k6MUTxu82Y+l5juX+DzhjQnFIInDLjmG98z3OTCliTBjrrbUIlemH6Y8Nx9FQw9rUBEOXiqj/qZKB6X5a2mtQjP7ImtHEqn0RjV6HRjXC5q/3EMsKsKXFY5Nns5ydiisplvd3riCck4UzLo1D3L8De8wBpi6Wo5zq42FvM7k/JfBwug3NrIZRpYIVrxuTwcTbDx9xjQ5hvlqPtTAX97XLeJsb+VffQ4TyxGAGM9Nw5KVgjghk4vtGiu+kcaGjjNJHGTxR3+XNymu8XjeTUyrahpr5afwWhokRFr9rxFFdjrexFs/9m7wfeIpwWhJEb1oyrpITLMaGMvzoJoX3pNQ8K6FD+4DVDTfv3v3Onx8/0TJWT9XzPDoMP/NtezmbFhPutlZWup6w1HSRT4/vIhRJghgKD8H24A6mK5fpqSvhWtdltAszzExO/d1cXfXgcNmp6ZNjEGf433/+i84xi8k4x3L/cxwXqnBkpPDX818Q5JL9jO7bjS1Tiu32dSbPn2Gss52+7m5criV6ersYGOjnrz/+pFFRRYf+Ae//2KRn5gmiuIzFpMdx+zpmWTIfXzxFKIrcS09sDM4zp7DKs7C3XEG0LSJ63ayvr7KxsYbVasbjcmPyzFPVXUh5ey7NPfV8eLvB5rvXuFuvYiwp5H3fY4RT4X4MHYnAdjQU69OHOO1WPBYT9iUb42MKJtVKXq940SxM0TX9mD5NOx0TD9HNzeB02vndZUV/6zpLTZfY/PkGgjxsNyNfB2M/fRLnrJr1zXXcohOPx8Xqay/z8zpMRiNK9SiPx+/TMfELI/pebnQ38VT9G5teJ5bpcUwNdbiuVCPkH9qFoqKcpcpiPEO9mK0WbFYzoujE63ExN6dBOa5ArVJiMZtYe+3BajVgWjIweKOOxfs/4BgbQF99hsWWOoS80D2MV1ViPnuK5fZHrK2vMtLXw/DwwN9dlXKM3p4uXr2aZ33dy8ePb7GYDbzUzrJQW8tCpgzj4x/RFORgaLmIkOm/lcHkZAz1VegqS9hYEXkjOrCYX6F9Oc2bNQ/zOg1e0cEfH9/hWLbyrOM3Bgf7ML3SoysqQJsrw66fQl11CkEW4MPAnl2YEg6jLcpluq+bjc01NNNqlGMKpmanMS/bmdFqePfhLRurIrZFI3arCY9nmYkMKdrjyczVnkOdFoMg9fehb58fev8daIJ3Y+7r4s2nf2NzOVlcNDHT/hh1ZQUTjZcwDvVjftHNy7ER9HotNpuZ2Xu3mfuuAXWODHViKELcl5/z/MsdTCdLmE6KwdDxCFPzFV4V5GJsqkcjz0d3Mo/B4EAmMtOZv3OLrooyZqcnWRZdWKaUqGtK0Vw6h0oWjXBkvx9DBdlMnz7Jywo5nemRzFaXYSg/zVxFKbOZaczEx6IoLkD1TRWGpnqUcTGoG+qYOnuaiRPpKAI+R5EUhqqxEkGelcTYnZsstDYxV3sGbUw47uEXrHmc6DLTmaw5x0xZMdq68+hav0N97Sqje3cztnULqoA9TMaGoTi4k4mLZxjOkSLUyhP4taGazt1fMBwRhCoyEFWgL1OHAxkL8GUkLJjhfbtQfLmNkSOhDO/xZXzndkZ3fMGw7zbGd25D6fNPxlMS6dm5HaE8OZCz0iCayxO5VhjNzdPx3C6L40ZhJD+USbgqC6YpJYjWzFCuZxykOTmImylfc18WRlvCfm5F7eVetD8PDvhw72gQ/wfRzRgw0GFfuAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;열혈 C프로그래밍&quot;
        title=&quot;&quot;
        src=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/f058b/c-book.png&quot;
        srcset=&quot;/static/9645d17b5cbef2076daa1e3b88e113fd/c26ae/c-book.png 158w,
/static/9645d17b5cbef2076daa1e3b88e113fd/6bdcf/c-book.png 315w,
/static/9645d17b5cbef2076daa1e3b88e113fd/f058b/c-book.png 630w,
/static/9645d17b5cbef2076daa1e3b88e113fd/40601/c-book.png 945w,
/static/9645d17b5cbef2076daa1e3b88e113fd/78612/c-book.png 1260w,
/static/9645d17b5cbef2076daa1e3b88e113fd/669cd/c-book.png 3024w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;em&gt;내가 처음으로 구입한 열혈 C프로그래밍. 아직도 고이 보관 중이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;나는 조금의 고민도 없이 바로 책을 사서 공부하기 시작했다. 그 당시에 C언어로 프로그래밍 처음 공부하는 사람들은 공감하겠지만 초기 환경 세팅하기까지 거쳐야하는 난관이 상당했다. 우스갯소리로 가장 먼저 배우는 &lt;code class=&quot;language-text&quot;&gt;&quot;Hello World!&lt;/code&gt;를 출력하기만 하면 프로그래밍 공부 고비의 절반은 넘었다는 말이 있을 정도였다.&lt;/p&gt;
&lt;p&gt;그 이유는 우선 비주얼 스튜디오를 설치해야 했는데 설치 파일이 상당히 무거울뿐더러 게임이나 일반인을 대상으로 하는 상업용 소프트웨어와 달리, 개발자를 대상으로 하는 프로그램이다보니 설치 과정이 썩 친절하기 못한 걸로 기억한다. 게다가 왠만한 컴퓨터 사양이 좋지 않고서는 실행하는데에도 시간이 1분 가까이 걸리기도 한다. 아무튼 여러 우여곡절을 겪으며 설치를 완료하고 나면 새 프로젝트(단축키 Ctrl + Shift + N) -&gt; 새 소스코드(Ctrl + Shift + A) -&gt; &lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt; 파일을 생성하면 모든 준비를 마치게 된다.&lt;/p&gt;
&lt;p&gt;이제 드디어 코드를 작성할 수 있게 된다. 아주 유명한 코드인 &lt;code class=&quot;language-text&quot;&gt;printf(&apos;Hello World!&apos;);&lt;/code&gt; 를 작성하고나서 &apos;실행&apos;버튼을 누르면서 두근두근했던 심정, 콘솔창이 뜨면서 &lt;code class=&quot;language-text&quot;&gt;Hello World!&lt;/code&gt;가 적혀있는 걸 확인했을 때의 그 짜릿한 순간의 기억은 아직까지도 생생하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 때 나는 이 일을 직업으로 삼아야 되겠다고 확신하게 되었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그렇게 책의 내용을 하나씩 습득해나갔다. 아무도 내게 공부하라고 시킨 적도 없고 알려주지도 않았지만 프로그래밍 공부가 정말 재미있었다. 내가 작성하는 코드에 따라서 컴퓨터가 이를 해석하고 결과가 나오는 일이 신기하다고 느껴졌다. 나는 이 매력에 빠져서 주말마다 게임 대신에 C언어 공부를 했다.&lt;br&gt;
비록 포인터를 공부할 때 살짝 위기가 찾아오기는 했지만 이해가 안 될때는 두번 세번이고 반복하면서 익숙해질 때까지 연습했다. 나에게 프로그래밍 공부는 억지로 해야하는 &apos;숙제&apos;가 아니었다. 내 인생에서 처음으로 찾은 &apos;내가 하고 싶은 공부&apos;였기 때문이다.&lt;/p&gt;
&lt;p&gt;이 책은 여전히 나의 책장 한 켠에 꽂혀있다. 비록 본인이 웹 개발자라는 이유로 인해 각종 자바스크립트 서적에 둘러싸여 있어서 펼쳐볼 일이 거의 없지만, 나의 개발자 커리어의 첫 스타트를 끊어주었다는 기념비적인 책이기 때문에 앞으로 내가 개발자로서 어떤 커리어를 선택하더라도 이 책을 위한 공간은 항상 남겨두려고 한다.&lt;/p&gt;
&lt;h2&gt;장래희망 : 개발자&lt;/h2&gt;
&lt;p&gt;초중고에서는 매년 학기 초에 장래희망 조사를 했었다. 보통 초등학교까지는 정말 순수한 마음으로 자기가 좋아하는 일, 커서 하고싶은 일을 적기 마련이지만, 중고등학교부터는 현실과 마주함에 따라 장래희망마저 자신의 꿈을 양보하게 된다. 그리고 그 자리는 안정적이거나 사회적 지위가 높은 직업으로 획일화 되기 마련이다.&lt;/p&gt;
&lt;p&gt;그럼에도 나는 중3부터 고3에 이르기까지 장래희망 조사칸을 모두 &apos;개발자&apos;라고 적었다. 내 주변에 장래희망을 개발자라고 적은 친구들은 매우 드물었다. 지금처럼 중고등학교에서 코딩이 교육과정으로 포함되어 있지 않았기 때문에 그만큼 프로그래밍에 대한 학생들의 인식이 높진 않았다. 무엇보다 부모님조차도 개발자라는 직업을 썩 탐탁치 않게 여기셨다. 위에서 언급했다시피 3D 직종이고 생소한 분야이다보니 나에게 다른 직업도 권유하셨지만 나는 확고했다.&lt;/p&gt;
&lt;p&gt;그 나이의 대부분의 남자아이들이 그렇듯, 나 역시도 하나에 꽂히면 끝을 보는 성격이다. 나는 아래와 같은 근거를 준비해서 열심히 부모님을 설득했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 지금 C언어를 공부하고 있고...나는 이 공부가 재밌고...몇 년 뒤에는 개발자가 유망한 직종이 될 거고...그래서 남들보다 앞서갈 수 있고....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나의 간절함이 통했는지 부모님은 일단 잠정적으로는 허락해주셨다. 그리고 내가 부모님에게 요구한 조건 한 가지, 바로 &lt;strong&gt;&apos;앞으로 컴퓨터 사용시간에 간섭하지 않기&apos;&lt;/strong&gt; 이다. 부모님께는 프로그래밍을 공부해야한다는 핑계로 대충 얼버무리면서 말했는데 이 요구를 수용해주셨다. &lt;em&gt;(솔직히 그 시간동안 공부만 하지는 않았다. 부모님께는 공부한다 말하고 실제로는 몰래몰래 게임을 했다....)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이로써 나는 개발자가 되기 위한 모든 만반의 준비를 갖추게 되었다.&lt;/p&gt;
&lt;img height=&quot;500&quot; src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/Essay/230812-why-i-become-developer/high-school.png&quot;&gt;
&lt;p&gt;&lt;em&gt;당시 고등학교 생활기록부. 고1까지는 아직 부모님을 100% 설득시키지는 못하였다...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;고등학교에 와서는 정말 입시공부로 인해 프로그래밍 공부를 할 여유가 없어졌다. 다행히 교내 방과후 프로그램의 일종으로 프로그래밍 교실이 있어 신청해서 들을 수 있었다. 이미 내가 공부했던 C언어 기초 내용을 복습하는 수준이었지만 갈증을 해결해 줄 수는 있었다. 이 시절에는 하루빨리 입시공부 때려치우고 대학교에 가서 컴퓨터 공부나 하고 싶다는 생각밖에 없었다.&lt;/p&gt;
&lt;p&gt;하지만 고3 현역 때 수능을 망치는 바람에 모의고사보다 훨씬 못한 성적표를 받아야했다. 여기서도 갈등이었다. 나는 가고자하는 전공이 확고하다보니 대학교의 네임밸류를 포기하더라도, 학과 공부와 개발 공부 열심히 하면 충분히 개발자로서 경쟁력이 있을 수 있다 생각했다.&lt;br&gt;
다른 한편으로는 불안감도 지울 수 없었다. 대학은 평생을 따라다닐 이름표인데 1년 정도는 시간을 더 투자할만 하지 않을까? 여기서 멈춰버리면 너무 아깝지 않을까?&lt;/p&gt;
&lt;p&gt;결국에 재수를 선택하게 되었고 나는 1년을 더 공부했다. 다행히 재수생때는 수능을 그럭저럭 보고 나름 괜찮은 성적을 받았다. 나는 묻지도 따지지도 않고 컴퓨터공학(소프트웨어)학과에만 정시 원서를 넣었다. 사실 학과를 바꾸면 더 높은 학교로 진학할 수 있는 선택지도 있었지만 나에게는 오직 단 하나의 목표, 컴퓨터를 전공하고 싶은 마음 뿐이었다.&lt;/p&gt;
&lt;h2&gt;소프트웨어 전공생&lt;/h2&gt;
&lt;p&gt;그리고 나는 마침내 소프트웨어 전공생이 되었다. 이제 지긋지긋한 &apos;공부를 위한 공부&apos;는 때려치우고 &apos;나를 위한 공부&apos;를 할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;사실 컴공(소웨)으로 대학에 들어오더라도 1학년부터 대단한 프로그래밍을 하진 않는다. 1,2학년은 C프로그래밍, 자료구조, 네트워크, 컴퓨터구조, 운영체제 등을 배우며 기본적인 CS지식의 기반을 다지는 단계이다. 그래서 저학년에는 코드를 작성하는 시간보다는 강의자료를 보면서 필기하는 데 더 많은 시간을 투자했다.&lt;/p&gt;
&lt;p&gt;그래서 나는 코딩을 하고 싶었다. 갓 입학한 컴공과 학생이 해볼만한 코딩 중 한가지는 바로 프로그래밍 문제를 푸는 일이다. 그래서 나는 학과의 알고리즘 소학회에 가입하게 된다. 여기서부터 본격적으로 나의 6년동안의 문제풀이(소위 &apos;PS&apos;라고 부른다) 인생이 시작되었다. 그 소학회의 C언어 스터디의 커리큘럼이 조금 빡센 편이었는데, 나는 중고등학교 시절의 예습을 한 덕분인지 그럭저럭 따라갈 수 있었다.&lt;/p&gt;
&lt;p&gt;이후 2,3학년이 되어서도 남들보다 쪼금 더 알고리즘 공부에 시간을 투자했다. 그 덕분에 전국 대학생 프로그래밍 경시대회인 ACM-ICPC 에 출전해보고, 소학회의 회장직을 맡아서 100명 이상의 사람들이 모인 커뮤니티 운영하며 C언어 기초 스터디의 강의(무려 3년이나)도 맡아보고, 그리고 교내 프로그래밍 경시대회의 문제 출제도 해볼 수 있었다.&lt;/p&gt;
&lt;p&gt;이 시간은 대학 생활에서 값진 경험을 가져다 주었다. 그 경험의 교훈은 단순히 문제를 어떻게 푸는 지에 대한 방법보다 훨씬 더 귀중한 것이었다.
내가 생각해낸 풀이를 남들이 쉽게 이해할 수 있도록 설명하는 방법, 다른 사람이 생각해낸 풀이에 귀 기울이는 방법, 많은 사람들이 모인 커뮤니티를 운영하는 방법, C언어 스터디를 진행하며 포인터를 쉽게 설명하는 방법, 내 의견을 포기하고 남의 의견을 받아들이는 방법을 배웠다. 또한 축적된 경험이 알게 모르게 개발 공부를 하면서도 탄탄한 밑거름이 되어주었다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(알고리즘 문제 풀이가 개발실력에 도움을 줄 수 있느냐는 사람들마다 의견이 갈리는 주제이지만 나의 의견, 그리고 같이 알고리즘을 공부한 선배들의 의견들은 모두 만장일치로 &apos;도움이 된다&apos;는 의견이다. 다익스트라 알고리즘이나 DP가 실무의 문제를 직접적으로 해결해주지는 않지만 &apos;데이터를 효율적으로 처리하는 방식&apos;에 대한 직관력을 키울 수 있다.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;내 대학 생활의 또 다른 특이점 중 하나는 (필수)전공과목 말고도 다른 학과의 강의를 많이 들었다. 개인적으로 흥미가 있었던 정수론, 사회심리학, 진화론과 같은 강의들을 들었다. &lt;em&gt;&apos;대학교 때 아니면 언제 이런 강의 들어보겠어? 재밌을 것 같은데 한번 들어보자&apos;&lt;/em&gt; 라는 생각을 갖고 있었다. 내가 궁금한 건 단순히 그 과목에서 가르치는 지식보다, 그 분야를 수십년동안 연구했던 교수님들이 세상을 바라보는 시선을 알고 싶었기 때문이었다. 대학교에서 마저도 중고등학교처럼 점수따기에 목숨 걸 필요는 없다고 생각했다.&lt;/p&gt;
&lt;p&gt;나는 그렇게 3학년까지 학교를 다니다가 군 입대를 하게 된다. 보통 1학년 마치고 다녀오는 게 일반적인데 나는 타이밍을 놓쳐서 시간이 흐르다가 결국 그제서야 가게 되었다. 그나마 다행인 건 특기병으로 지원했기 때문에 야전으로 가지는 않았지만, 교대근무를 하며 하루종일 컴퓨터를 보는 일을 맡아 군생활의 1/4를 밤 새는 일로 보냈다 (평생 할 밤샘을 군대에서 다 했다).&lt;/p&gt;
&lt;p&gt;군 복무 중에도 그냥 흘러만 가는 시간이 아까웠다. 그래서 부대 내 컴퓨터를 사용할 수 있는 사이버 지식 정보방(일명 &apos;사지방&apos;)에서 나는 알고리즘 문제를 풀었다. 주로 코드포스에서 문제를 풀었는데 군 복무 기간동안 대략 400문제 정도 풀었다. 사지방 컴퓨터에는 로컬 IDE 설치가 불가능 했기 때문에 온라인 IDE를 찾아 헤매면서 코딩했던 기억이 난다. 게다가 정말 기막힌 우연 중 하나는, 같은 생활관의 후임 중 한명이 PS를 하는 친구였다. 나만큼 혹은 나보다도 더 문제 풀이에 진심인 친구였기 때문에 외롭지 않게 코딩할 수 있었다.&lt;/p&gt;
&lt;h2&gt;FE 개발자의 길&lt;/h2&gt;
&lt;p&gt;군대를 전역하고 복학하니 4학년이 되어있었다. 이제 나도 본격적으로 취업 전선에 뛰어들 준비를 해야한다. 보통 개발자로 취준을 한다면 먼저 진로를 선택하기 마련이다. 마치 RPG 게임에서 초보자가 직업을 선택할 때 전사/마법사/궁수/도적으로 전직하는 것처럼 개발자도 마찬가지이다. 일반적으로 프론트엔드/백엔드/모바일/ML 중에서 본인의 진로를 정하게 된다.&lt;/p&gt;
&lt;p&gt;내 주변의 컴공 전공생들은 80% 이상이 백엔드로 진로를 선택하는 경우가 많았다. 백엔드 분야가 전공자로서의 이점을 가장 잘 살릴 수 있으면서 대부분의 회사에서 널리 필요한 직종이었기 때문이다. 모바일은 처음 공부를 시작하기 위한 허들이 조금 있는 편이고, ML은 대학원이 90% 필수였다. 그리고 프론트엔드는 상당히 애매한 포지션에 위치한다. 4개 분야 중에서 그나마 CS 지식을 덜 필요로한다는 인식이 있기 때문에 비전공자나 디자인 파트에서 전향하는 사례가 꽤 있는 편이다.나도 그 당시에 프론트엔드와 백엔드를 두고 고민을 많이 했다. 전공자의 이점을 살릴 수 있는 백엔드를 선택할 수도 있었다.&lt;/p&gt;
&lt;p&gt;하지만 프론트엔드는 개발하는 과정이 너무 재미있었다. 마치 중2때 처음 C를 접하고 코딩했었던 기억과 흡사했다. 내가 만든 결과물(웹페이지)이 다른 사람들에게 어떻게 보여질지 상상해면서 코딩을 하는 과정이 행복했고, 그 힘이 마치 무한동력처럼 작용해서 밤을 새서 코딩을 해도 힘들지가 않았다. 비록 프론트엔드 개발자의 진로가 상대적으로 치열하더라도, 내가 하고 싶은 일을 선택하는게 나중에 후회할 일을 만들지 않을 것이라고 생각했다.&lt;/p&gt;
&lt;p&gt;이제 막 FE개발자 경력 1년을 채운 시점에서 돌이켜보자면 1년 전보다 상황이 더 치열해진 건 사실이다. 솔직히 &apos;만약 내가 백엔드 개발자였다면?&apos;을 몇 번 생각해 본 적도 있다.&lt;br&gt;
그래도 후회는 하지 않는다. 인생을 살아가는 나만의 신조 중 하나는 &lt;em&gt;&apos;내가 내린 선택에 대해서는 절대 의심하지 말자&apos;&lt;/em&gt; 이다. 1년 전으로 다시 돌아가도 나는 (조금 고민은 하겠지만)프론트엔드 개발자를 선택할 것이다.&lt;/p&gt;
&lt;p&gt;내가 선택한 길이니 모든 책임은 나의 몫이다. 내가 더 열심히하면 극복할 수 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/5510b/profile-graduate.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAMEBQEC/8QAFwEBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAABj7bqpJUPWeb10BL/xAAbEAABBQEBAAAAAAAAAAAAAAACAAEDERIhI//aAAgBAQABBQKsIz0LRcyNcKWiWkz+ul//xAAWEQEBAQAAAAAAAAAAAAAAAAAQARH/2gAIAQMBAT8Bwp//xAAZEQACAwEAAAAAAAAAAAAAAAAAEQECEDH/2gAIAQIBAT8BYyvJz//EABwQAAMAAQUAAAAAAAAAAAAAAAABESEQEjFB4f/aAAgBAQAGPwKbmQWRYTGpIeHWnCP/xAAbEAEAAwEBAQEAAAAAAAAAAAABABEhQVFhkf/aAAgBAQABPyFbMHyJTKt2WNUsvZQVjuRzIdR5IHIt5+Ion25mH//aAAwDAQACAAMAAAAQE/CD/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/EG5E0sL/xAAZEQADAAMAAAAAAAAAAAAAAAAAAREQIVH/2gAIAQIBAT8QWjJ5iU//xAAfEAEBAAICAQUAAAAAAAAAAAABEQAhMUFRYXGBkdH/2gAIAQEAAT8QPEwuht+Zkc6K4fb0y8vCBUuEsgCovnrIsIUQNmtGXAMAB16zcVt4AUqr7ytAg0c/uf/Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;profile graduate&quot;
        title=&quot;&quot;
        src=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/828fb/profile-graduate.jpg&quot;
        srcset=&quot;/static/d059a7dc2274b3319003d03e50db9fcd/ff44c/profile-graduate.jpg 158w,
/static/d059a7dc2274b3319003d03e50db9fcd/a6688/profile-graduate.jpg 315w,
/static/d059a7dc2274b3319003d03e50db9fcd/828fb/profile-graduate.jpg 630w,
/static/d059a7dc2274b3319003d03e50db9fcd/0ede0/profile-graduate.jpg 945w,
/static/d059a7dc2274b3319003d03e50db9fcd/5510b/profile-graduate.jpg 1179w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;어떤 개발자가 될 것인가&lt;/h2&gt;
&lt;h4&gt;1. 나만의 서비스를 제로베이스부터 개발해서 출시해보고 싶다.&lt;/h4&gt;
&lt;p&gt;나만의 서비스를 처음부터 개발하여 세상에 출시해보고 싶은 바람이 있다. 마치 요리사가 몇년동안 식당에서 일을 하다가 경력이 쌓이면 본인의 식당을 차리듯이 말이다. 창업일 수도 있고 사이드 프로젝트일 수도 있겠지만 형식에는 연연하지 않는다. 그렇다고 이 서비스가 반드시 성공해야 한다는 사명감을 갖고 시작하려는 것도 아니다. 단지 &apos;세상에 이런 서비스를 만든다면, 사람들은 어떻게 이용할까?&apos; 라는 근본적인 호기심으로부터 시작되었다.&lt;/p&gt;
&lt;p&gt;나는 고객(사용자)과 직접 맞닿아서 개발할 때 가장 재미있고, 내가 서비스를 직접 만들면서 이 서비스의 &lt;code class=&quot;language-text&quot;&gt;기획-디자인-개발-출시-유지보수&lt;/code&gt; 같은 라이프사이클을 모두 겪어보면서 동고동락할 수 있다면 그야말로 개발자를 하면서 얻을 수 있는 최고의 성취감이라고 생각한다.&lt;br&gt;
하지만 이를 위해서는 요구되는 역량도 고려해야 한다. 프론트엔드뿐만 아니라 백엔드나 데브옵스 또한 어느정도 다룰 수 있는 역량을 갖춰야 할 것이다. 상황에 따라서는 기획과 디자인과 같은 기술 외적인 분야에서도 신경써야 할 일이 많을 것이다.&lt;/p&gt;
&lt;h4&gt;2. 교육 컨텐츠를 만들고 싶다.&lt;/h4&gt;
&lt;p&gt;최근에 인프런이나 유튜브에서 여러 강의를 보면서 느낀 점은 나도 나중에 어느 분야에 대해 전문가가 된다면 꼭 강의를 만들어보고 싶다는 것이다.&lt;br&gt;
나는 대학교에서 알고리즘 소학회를 입학할 때부터 시작하여 졸업할 때까지 (총 6년 6개월)활동했었다. 이 기간 동안 스터디 활동을 하면서 내가 남들로부터 지식을 얻기도 했지만, 내가 가진 지식을 남에게 알려주기도 했다. 이 경험을 통해 남에게 가르쳐주는 일이 재밌고 의외로 나랑 잘 맞는 일이구나를 깨닫게 되었다. 특히나 많은 사람들이 이해하기에 어려운 개념이 있을 수 있는데, 내가 직접 가르칠 때는 사람들이 어떤 점을 어려하는지를 파악하고 그 부분에 대해서 쉽게 풀어서 설명하는 것에 자신이 있다.&lt;/p&gt;
&lt;h2&gt;지금의 나&lt;/h2&gt;
&lt;p&gt;우리 사회에서 개인의 직업이 정해지는 과정이 그렇게 필연적이기는 어렵다. 자신이 좋아하는 일을 직업으로 삼기는 현실적으로 어렵기 때문이다. 꿈을 쫓다보면 대개 현실적인 제약에 부딪히기 마련이다. 그러다보니 많은 사람들은 어쩔 수 없이 점수에 맞춰서 들어간 대학교와 학과에 따라서 직업이 정해지는 경우가 부지기수이다.&lt;/p&gt;
&lt;p&gt;하지만 나에겐 &apos;개발자&apos;라는 직업의 의미는 결코 가볍지 않다. 27살이 된 지금, 프로그래머가 되고자 처음으로 마음을 먹었던 15살을 기점으로 12년동안 간직해온 꿈이고 그 꿈을 직업으로 삼을 수 있다는 점에서 나는 프로그래밍을 하고 있는 순간이 너무나 소중한 기회라 여기고 있다. 내가 살아온 인생의 여정에서 개발자라는 직업은 너무나도 강하게 결합되어 있다.&lt;/p&gt;
&lt;p&gt;내가 남들보다 더 훌륭하다거나 돈을 더 많이 버는 개발자는 아닐 수도 있지만 한 가지는 확신할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 일을 내가 하고 싶은 일이다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[모바일 환경에서 모달 닫기]]></title><description><![CDATA[2023-03-0…]]></description><link>https://juheon.dev/vue/230803-vue-modal-close/</link><guid isPermaLink="false">https://juheon.dev/vue/230803-vue-modal-close/</guid><pubDate>Thu, 03 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/222&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;모달 닫기&lt;/h2&gt;
&lt;p&gt;모바일 환경에서 모달창이 떠 있는 상태에서 모달을 닫는 방법은 여러가지가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;첫 번째 방법은 모달 창 내부에 별도의 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 표시해서 이 영역을 터치하면 닫히게 하는 방법이 있다. 가장 직관적인 방법이지만 버튼을 위한 별도의 공간을 확보해야 하기 때문에 디자인상 의도치 않은 공간을 차지한다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;이런 단점을 해결하기 위한 두 번째 방법은 모달 바깥의 영역을 터치를 감지했을 때 모달을 닫는 방법이 있다. 다만 이 방법 역시 명시적인 &apos;닫기&apos;버튼이 보이지 않기 때문에 이러한 UI/UX가 낯선 사용자에게는 모달을 어떻게 닫아야 하는지 헤맬 수도 있다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;세 번째 방법은 (안드로이드 환경에서) 뒤로가기 버튼을 눌렀을 때 모달이 닫히게 하는 방법이다. 이 방법의 경우, 모달창과 직접적인 상호작용이 일어나지 않으므로 개발자 입장에서는 뒤로가기 이벤트를 감지해야 하는 등 꽤나 까다로운 작업이다. 이번 글에서는 그 방법에 대해서 설명하겠다.&lt;/p&gt;
&lt;h2&gt;뒤로가기&lt;/h2&gt;
&lt;p&gt;&apos;뒤로가기&apos;를 눌렀을 때 모달창이 닫히게 만들기 위해서는, 모달창이 열려있는 상태를 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;객체의 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 저장(push)해야 한다. 이때 사용하는 함수가 &lt;code class=&quot;language-text&quot;&gt;window.history.pushState()&lt;/code&gt;함수이다. 이 함수에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&quot;&gt;자세한 설명&lt;/a&gt;은 MDN을 참고하기 바란다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pushState()&lt;/code&gt;함수의 첫 번째 인자로는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;를 전달해야 하는데, 정해진 양식이 있는 것이 아니라 개발자가 식별할 수 있는 정보를 담아서 객체 형태로 넘기기만 하면 된다. 나는 &lt;code class=&quot;language-text&quot;&gt;{state : &apos;modal&apos;}&lt;/code&gt; 객체를 넣었다. 두 번째 인자는 아무 의미는 없지만 생략할 수는 없으므로 빈 문자열이나 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;를 넣으면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;openModal&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;Modal @close-modal=&amp;quot;closeModal&amp;quot; /&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const isModalOpen = ref(false);

  const openModal = () =&amp;gt; {
    isModalOpen.value = true;
  };
  const closeModal = () =&amp;gt; {
    isModalOpen.value = false;
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이전 포스팅에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;안의 코드는 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;라는 별도의 컴포넌트로 분리해두었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);
  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
  });
  const closeModal = () =&amp;gt; {
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이제 버튼을 누르면 모달이 열리면서 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;이 추가됨을 확인할 수 있다. 하지만 여기서 뒤로가기를 누르더라도 모달이 닫히지는 않는다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;isModalOpen&lt;/code&gt;값은 여전히 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;이기 때문이다. 따라서 &apos;뒤로가기&apos;가 실행되면 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수가 실행되게끔 만들어야 한다.&lt;/p&gt;
&lt;h2&gt;popstate&lt;/h2&gt;
&lt;p&gt;자바스크립트에서 뒤로가기 이벤트를 감지하려면 &lt;code class=&quot;language-text&quot;&gt;popstate&lt;/code&gt;라는 함수를 이벤트리스너에 등록해야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;함수에 아래와 같이 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;onMounted(() =&amp;gt; {
  window.history.pushState({ state: &amp;quot;modal&amp;quot; }, undefined)
  window.addEventListener(&amp;quot;popstate&amp;quot;, closeModal)
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &apos;뒤로가기&apos;를 누르면 모달창도 닫힌고, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;도 다시 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 아직 한 가지 문제점이 남아있다.&lt;/strong&gt; &apos;뒤로가기&apos;를 누르지 않고 그냥 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫게 되면 모달을 닫히지만, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;되지 못하고 쌓여있게 된다. 즉 모달은 닫혀 있지만 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;를 찍어보면 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;인 상태로 남아있다는 것이다.&lt;/p&gt;
&lt;p&gt;즉 모달이 닫힐 때 &apos;뒤로가기&apos;를 눌러서 닫힌 건지,&lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫힌 건지 구분해주어야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수의 인자로 뒤로가기가 눌렸는지를 확인하는 인자를 받도록 수정한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const closeModal = (isBackward = false) =&amp;gt; {
  if (!isBackward) {
    history.back()
  }
  emit(&amp;quot;close-modal&amp;quot;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;버튼을 눌러서 닫았다면 &lt;code class=&quot;language-text&quot;&gt;isBackward&lt;/code&gt;값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;로 들어오고 &lt;code class=&quot;language-text&quot;&gt;history.back()&lt;/code&gt;를 호출하여 상태를 한단계 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;해주면 된다. 작동하는 모습은 아래와 같다.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/vue-modal-backward.gif&quot;&gt;
&lt;p&gt;완성된 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;코드는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal(false)&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);

  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
    window.addEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  onUnmounted(() =&amp;gt; {
    window.removeEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  const closeModal = (isBackward = false) =&amp;gt; {
    if (!isBackward) {
      history.back();
    }
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;생각&lt;/h2&gt;
&lt;p&gt;사실 웹뷰 환경에서 모달창이 열려있는 상태를 굳이 &apos;뒤로가기&apos;를 통해서 닫히게 동작해야 할까에 대해 고민이 많았다. 웹뷰는 웹만의 고유한 동작 방식이 있기 때문에 네이티브 앱을 흉내내는 일에 대해서는 회의적이었다. 하지만 개발자가 아닌 일반 사용자 입장에서는 자신이 사용하는 앱이 웹 기반인지 네이티브 기반인지는 별 관심은 없을 것이고, 개인마다 여러 앱을 사용해오면서 축적되어온 경험(&apos;뒤로가기&apos;하면 모달이 닫힘)이 그대로 적용되리라는 기대를 할 것이다.&lt;/p&gt;
&lt;p&gt;그래서 이번 개발을 계기로 유명하다싶은 앱은 모두 다운받아서 과연 &apos;모달창이 뒤로가기로 닫히는가&apos;를 시험해보았다(족히 30개의 앱으로 확인해보았다). 대략 90%의 앱이 네이티브 기반이었고, 이 앱들은 전부 다 뒤로가기를 통해 모달이 닫힘을 확인하였다. 나머지 10%의 웹뷰 기반 앱은 반반이었다. 어떤 앱은 뒤로가기를 누르면 모달이 닫힘과 함께 아예 이전 페이지로 이동해버리는 문제가 있었고, 이 경우의 사용자 예상과 다른 결과로 인하여 사용성이 떨어진다는 인상을 받았다.&lt;/p&gt;
&lt;p&gt;그래서 내가 내린 결론은 웹뷰는 사용자의 경험을 해치지 않는 선에서는 네이티브처럼 동작하게끔 최소한의 기대되는 동작은 구현해줘야 한다는 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue로 모달 구현하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert…]]></description><link>https://juheon.dev/vue/230802-vue-modal-open/</link><guid isPermaLink="false">https://juheon.dev/vue/230802-vue-modal-open/</guid><pubDate>Wed, 02 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/224&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert창과 같은 형태이다. 이를 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 어떻게 구현하는지 살펴보자.&lt;/p&gt;
&lt;h2&gt;모달 구현&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 모달을 구현하는 방법에는 여러가지가 있을 수 있다. 가장 간단한 형태는 하나의 파일 안에 모달을 다 집어넣는 방식일 것이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// MyModal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;
  @import url(&amp;#39;.../modal.css&amp;#39;)
&amp;lt;/style&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* modal.css */
.modal {
  position: fixed;
  z-index: 10;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}
.modal .modal-content {
  position: absolute;
  width: 600px;
  height: 400px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이 방식의 경우 아래 사진과 같이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;태그는 기존 화면이 위치하고 있는 DOM노드 하위에 종속될 수 밖에 없다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/09262/vue-modal-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.15189873417721%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKklEQVR42u2QOW+DQBBG+dm+D7kx6SzZLty4sP2DUkUpcsiQQATsggPmCPCihRSOIkPKFBnpSSvtN29mV+t2u3Q6HcbjcSOTyYThcMh8Psd8MghlwDmKieKEWJEkJHGK1ia6FA4GA/QbHfvZ4mQHhH5IHqdclqaCv2E6nTIajdB1HSkkgXBxrEfO0iHPc8qirIX9fp9er9eKyqmvmc1mWJaFY1gY97fYT3ccH45YLwIpArTFYsFyuWS1WrFerxtRmc1mUwnFq4eUktN78MWJKIrQTNMkDEOyLKOpyrJ+kuu6vBk26TkhKzOyPCPNUz6Kul/zPK86FEVRNV1D3atyHAfXceshlD8Ga0KIbxu0baiETT3/wr8o3G63HA4H9vt9K7vdrsr6vn9V+AkSCeMgVSbvcAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;vue modal 1&quot;
        title=&quot;&quot;
        src=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/f058b/vue-modal-1.png&quot;
        srcset=&quot;/static/0c5a515adca3dad3771e9cb5257a6a8d/c26ae/vue-modal-1.png 158w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/6bdcf/vue-modal-1.png 315w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/f058b/vue-modal-1.png 630w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/40601/vue-modal-1.png 945w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/78612/vue-modal-1.png 1260w,
/static/0c5a515adca3dad3771e9cb5257a6a8d/09262/vue-modal-1.png 1896w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 한 가지 아쉬운 점이 생긴다. modal 창은 기존의 화면과 구분되는 속성인데 DOM 노드상에서도 이를 구분할 수 없을까? 즉 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;app&quot;&gt;&lt;/code&gt;과 같은 레벨로 끌어올릴 수 없을까? 하는 생각을 품게된다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;이를 해결하기 위해 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt; 기능을 적용해보자. &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;란 &lt;a href=&quot;https://ko.vuejs.org/guide/built-ins/teleport.html#basic-usage&quot;&gt;공식문서&lt;/a&gt;상에서는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;컴포넌트 템플릿의 일부를 해당 컴포넌트의 DOM 계층 외부의 DOM 노드로 &quot;이동&quot;할 수 있게 해주는 빌트인 컴포넌트입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라고 설명하고 있다. 간단하게 요약하자면 기존에 보여지고 있던 화면과 논리적/기능적으로 구분된 또다른 화면을 표시해야할 때, 기존의 DOM 노드가 아닌 별도의 DOM노드로 마치 teleport(순간이동)할 수 있는 기능이다.&lt;/p&gt;
&lt;p&gt;이를 사용하기 위해서는 일단 DOM이 그려지는 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt;안에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이라는 새로운 태그를 추가한다. (id 대신에 class를 사용하더라도 작동은 정상적으로 하지만, 중복 문제를 피하기 위해 관습적으로 id를 사용하는 듯 하다.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    ...
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;noscript&amp;gt; ... &amp;lt;/noscript&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 기존에 있던 &lt;code class=&quot;language-text&quot;&gt;MyModal.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;한 겹을 벗겨내고 대신에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport to=&quot;#modal&quot;&gt;&lt;/code&gt;을 넣어주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;id&quot;&gt;&lt;/code&gt;와 DOM상에서 같은 레벨에 생성된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/361a6186f39d39e599866d8b3fe8a390/60c1e/vue-modal-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.25316455696203%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIUlEQVR42s2RQWvCQBCF869FSEg8eFD/kp4NXkqtlhQFaQPRkBijZndrTPKVDRU8GLRQSh98MPCGtzM7RqvVQmPb9l0cx8E0TaZPU7J0z35/YHcUHDJBJgSHY4ahmzQPBdoOpmXy+jxHhRnHOKOQiqosqaoKLePy8iN0Op06cPYyYxdErBbvfKx8wiAkiROEFBh6hUexLIt2u403fyMXJ9RZ8Xk+IXOFOknKqsTo9XoMBgP6/f5ddF+322W5WNbrXda8luF5Huv1mjRNUUohpbyJEII8zwmCgM1m0xwYx3Gjea2LnyQJYRg2B26327oovy/VhPZ/FPjrE/7fwCiK6qIoivqfmtC+lj7i3044Go1wXZfxeHyXyWTCcDjE9/3GwC/7wOThxMZt/AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;vue modal 2&quot;
        title=&quot;&quot;
        src=&quot;/static/361a6186f39d39e599866d8b3fe8a390/f058b/vue-modal-2.png&quot;
        srcset=&quot;/static/361a6186f39d39e599866d8b3fe8a390/c26ae/vue-modal-2.png 158w,
/static/361a6186f39d39e599866d8b3fe8a390/6bdcf/vue-modal-2.png 315w,
/static/361a6186f39d39e599866d8b3fe8a390/f058b/vue-modal-2.png 630w,
/static/361a6186f39d39e599866d8b3fe8a390/40601/vue-modal-2.png 945w,
/static/361a6186f39d39e599866d8b3fe8a390/78612/vue-modal-2.png 1260w,
/static/361a6186f39d39e599866d8b3fe8a390/60c1e/vue-modal-2.png 1866w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;모달 열고 닫기&lt;/h2&gt;
&lt;p&gt;그렇다면 이제 이 모달을 동적으로 열고 닫을 수 있어야 한다. 방법은 예상하다시피 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;
나 &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하면 된다. 하지만 사용 방식에는 조금 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에는 오직 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;만 사용할 수 있고, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;는 작동하지 않는다. &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;하위의 최상단 root노드에 걸어야만 작동한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;는 값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;일 경우 렌더링 시점에서 아예 제외되므로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에 걸면 하위의 모든 노드들이 렌더링되지 않지만, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;의 경우에는 일단 렌더링하고나서 값에 따라 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;으로 처리하는데 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;html&lt;/code&gt; 태그가 아닌 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 기능에 불과하므로 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;이 걸리지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;isModalOpen = true&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
          &amp;lt;button @click=&amp;quot;isModalOpen = false&amp;quot;&amp;gt;close&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  import { ref } from &amp;#39;vue&amp;#39;;
  const isModalOpen = ref(false);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[두 번째 프로젝트 회고]]></title><description><![CDATA[1. pinia와 typescript…]]></description><link>https://juheon.dev/essay/230712-second-project-review/</link><guid isPermaLink="false">https://juheon.dev/essay/230712-second-project-review/</guid><pubDate>Wed, 12 Jul 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. pinia와 typescript의 도입&lt;/h2&gt;
&lt;p&gt;이번 프로젝트(커머스)에서 드디어 벼르고 벼르어왔던 기술을 도입하게 되었다. 바로 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;원래는 더 빨리 도입하고 싶었으나, 이전 프로젝트가 생각보다 늘어짐 + 숙련도 이슈로 인하여 늦어진 감이 있다. 하지만 그만큼 더 철저하게 준비해서 도입 안하느니만 못한 상황이 벌어지지 않게끔 신경썼다. 여기서 &apos;도입 안하느니만 못한 상황&apos;이란 기껏 타입스크립트 도입해놓고 모든 타입을 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;로 정의한다든가, 에러 해결을 못해서 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 회귀한다든가 하는 상황이다. 도입 초반부에는 이런 일이 실제로 벌어질 위기가 몇 번 있었으나, 그때마다 구글링하고 공식문서 열심히 읽다보니 어찌어찌 해결은 할 수 있었다.&lt;/p&gt;
&lt;p&gt;도입해놓고 나서 느낀 점은 확실히 타입스크립트가 개발경험을 엄청나게 개선시켜준다. VScode에서 제공해주는 자동완성 기능을 맛보면 헤어나올 수가 없다. 특히나 내가 진행한 커머스는 그 특성상 프론트에서 다뤄야할 데이터가 많다. 하나의 상품 데이터 하나에도 그 속성이 20개가 넘고, 이 상품을 주문 로직을 태우려면 또 다시 주문을 위한 데이터 20여개가 추가된다.&lt;/p&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 개발을 했다면 40개가 넘는 데이터 중에서 하나라도 오타가 나거나 타입이 어긋나면 직접 시연해보며 그 에러를 찾는데 시간이 잡아먹혔겠지만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 사용함으로써 런타임 이전 시점에 어디서 문제가 생기는지 쉽게 찾을 수 있게 되었다.&lt;br&gt;
왜 사람들이 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 제대로 쓸 줄 알기 시작하면 쓰기 이전으로 돌아갈 수 없다고 말하는지 깨달았다. 아직 내가 &apos;제대로 쓴다&apos;라고 말하기엔 어설프긴 하다만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;학습 허들의 고비점은 넘긴 느낌이다.&lt;/p&gt;
&lt;p&gt;또 다른 기술 도입은 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 vue 커뮤니티에서 출시한 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신할 새로운 전역 상태관리 라이브러리이다. 사실 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신한다고는 해도, 그 개발진 대부분이 옮겨간 수준이라 크게 달라진 점은 없다.&lt;br&gt;
기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 사용하면서 느꼈던 불편한 점들, 그리고 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;와의 호환성 증대로 인하여 서로의 시너지를 극대화시킬 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에 대한 도입기는 &lt;a href=&quot;https://juheon.dev/vue/230704-start-pinia/&quot;&gt;이전 포스팅&lt;/a&gt;에 자세히 적어놓았다.&lt;/p&gt;
&lt;h2&gt;2. 페이지 / 컴포넌트 구조에 대한 고민&lt;/h2&gt;
&lt;p&gt;개발을 시작한지 얼마 되지 않은 초창기의 개발 스타일은 가급적이면 한 페이지에 내에 많은 기능을 압축적으로 집어넣으려고 했다. 개발이 익숙하지 않을 시기에는 파일을 여러 개로 쪼개는 것에 대한 부담감(두려움)도 있고, 상대적으로 규모가 작은 프로젝트를 맡았었기에 &apos;페이지,컴포넌트 구조론&apos;에 대해 고민이 깊지는 않았다.&lt;br&gt;
하지만 프로젝트의 규모가 점점 커질수록 페이지,컴포넌트의 개수가 많아지게 되고, 여러 파일을 다루는 일도 익숙해지면 자연스레 이 파일들을 어떤 기준으로 나눠야 효율적일지 고민하게 되었다.&lt;/p&gt;
&lt;p&gt;일단 &lt;strong&gt;페이지&lt;/strong&gt;란 사용자가 서비스에서 제공하는 특정한 기능 &lt;strong&gt;한 가지&lt;/strong&gt;를 수행하기 위해 만들어진다. 커머스 서비스로 예를 들자면 상품 전시, 결제, 장바구니, 주문조회와 같은 기능에는 모두 고유한 페이지가 존재한다. 그리고 페이지는 각자마다 고유한 &lt;code class=&quot;language-text&quot;&gt;path(url)&lt;/code&gt;를 부여받는다. 이 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;가 사용자와 개발자간의 접점이 되어서 상호작용이 가능한 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컴포넌트&lt;/strong&gt;는 그 페이지를 구성하고 있는 일종의 부속품이다. 컴포넌트에는 버튼이나 헤더,푸터, input창 하나하나도 개발자의 판단에 따라서 컴포넌트가 될 수도 있다. 컴포넌트를 분리하는 기준은 저마다 다를 수 있지만 나같은 경우에는 프로젝트 내에서 반복적으로 사용되는 여부와 기능을 구성하는 최소한의 단위를 따져서 만들게 된다.&lt;br&gt;
즉 하나의 페이지 안에도 수십개의 컴포넌트가 존재할 수 있고, 이 말은 곧 작은 기능을 담당하는 부품(컴포넌트)이 여러개가 합쳐짐에 따라 기능을 수행할 수 있게 되는 것이다.&lt;/p&gt;
&lt;p&gt;그래서 내가 페이지를 나누는 기준은 사용자의 행동 단위를 큼직하게 잘라서 구성하는데, 이 기준이 칼로 두부자르듯이 항상 말끔하게 구분되지는 않고 애매모호한 지점이 생긴다. 때로는 특정 행동에서 파생된 기능을 다뤄야 할 때가 있다.
예를 들어 &apos;주문조회&apos; 페이지에서 &apos;배송조회&apos;라는 파생기능이나, &apos;상품 주문&apos;페이지에서 &apos;주소 검색&apos;같은 기능들이다. 이러한 파생기능을 구현하려면 둘 중 하나의 방식을 선택해야 한다.&lt;/p&gt;
&lt;h4&gt;1. 메인 페이지에 녹여내기&lt;/h4&gt;
&lt;p&gt;가장 간단한 방법은 한 페이지에 두 기능을 다 표시하면 된다. 하지만 2가지의 별도의 행동을 하나의 페이지 안에 모두 보여주기에는 부담이 있다. 위에서 언급했던 &lt;strong&gt;페이지&lt;/strong&gt;의 정의와 같이 하나의 페이지 안에서는 &lt;strong&gt;한 가지&lt;/strong&gt; 기능만 수행하도록 하는 원칙에 위배되기 때문이다. 파생된 기능을 욱여넣음으로써 그 페이지만의 맥락을 모호하게 만들고 싶지는 않았다.&lt;/p&gt;
&lt;h4&gt;2. 별도의 페이지(&lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;)로 만들기&lt;/h4&gt;
&lt;p&gt;1번의 방법이 싫다면 페이지 자체를 분리하면 된다. 하지만 페이지를 남발하게 되면 그 만큼 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;의 수가 많아지게 된다. 한 페이지 내에서 파생 기능이 10가지라면 새로운 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt; 10가지가 추가된다는 뜻인데 과연 이게 효율적인 방법인지는 고민해봐야 한다.&lt;br&gt;
무엇보다 페이지를 쪼개면 메인 페이지 =&gt; 파생 페이지 로 데이터를 전달하기가 난처해진다. 페이지 =&gt; 컴포넌트 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;를 통해 전달할 수 있지만, 페이지 =&gt; 페이지 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;전달이 불가능하다. 따라서 상태관리의 힘을 빌린다거나, 파생 페이지에서 다시 새로운 데이터를 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt;해야하는 비효율적인 문제가 발생한다.&lt;/p&gt;
&lt;p&gt;결국 방법 1,2 중 완벽한 방법은 없다. 하나의 페이지라는 제한적인 공간(맥락)안에서도 여러가지 파생된 기능을 넣어야 한다. 나는 이를 해결하기 위해서 &lt;strong&gt;모달&lt;/strong&gt;을 사용하였다. 모달은 별도의 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;를 부여하지 않더라도 공간을 분리시킬 수 있다. 평소에는 메인페이지를 보여주고 있다가 사용자가 파생 기능을 선택했을 때에만 모달이 기존 화면을 덮음으로써 공간을 분리할 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 결론을 얘기하자면 이번 프로젝트에서는 모달을 적극적으로 사용하였다. 모달은 &apos;페이지와 컴포넌트 사이 고민&apos;의 산물이다. 나는 페이지는 가능한 적게 만들면서 컴포넌트는 최대한 쪼갤 수 있을만큼 쪼개는 방식을 선호하다보니 이런 고민을 하게 된 것 같다.&lt;/p&gt;
&lt;h2&gt;3. 셀프 코드리뷰(클린 코드)&lt;/h2&gt;
&lt;p&gt;셀프 코드리뷰라는 말이 이상하게 들릴 수 있다. 하지만 회사에 프론트 개발자가 나 혼자밖에 없으니 누군가에게 코드 리뷰를 부탁하기 어려운 상황이다. 그래서 나는 회사에 다니는 동안 &apos;좋은 코드&apos;란 무엇일까에 대해 고민을 많이 할 수밖에 없었다. 그리고 이번 프로젝트에서 주안점으로 둔 3가지는,&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;시간이 지난 뒤에 다른 사람이 읽어도 자연스럽게 읽히는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;내가 짤 때는 나름 잘 짠 것 같은데, 나중에 다른사람이 내 코드를 읽고서 읽기 어렵다는 피드백을 들은 적이 있었다.
내가 보기에 잘 짠 것 같은 코드는 아무 의미가 없다. 모두가 이해할만한 보편적인 코드를 짜야한다.
특히 변수명과 함수명을 잘 짓는 일이 중요하다고 생각한다. 이름이 좀 길어지더라도 해당 변수(함수)가 하는 역할이 이름만 보고도 짐작할 수 있어야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;버그가 발생했을 때, 어느 부분을 고쳐야 하는지 직관적으로 찾을 수 있는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;버그가 발생하지 않는 방향으로 코드를 작성하는 게 가장 바람직하겠지만, 코드를 작성하다보면 버그 발생은 불가피하다. 그래서 버그가 발생하지 않도록 하는 일만큼 중요한 게 &apos;버그를 얼마나 쉽게 고칠 수 있느냐&apos;이다.&lt;br&gt;
대개 해결하기 어려운 버그들의 공통점은 하나의 코드 안에서 여러 로직들이 이어폰줄처럼 엉켜있을 때 발생한다. 어떤 부분을 고치면 이곳에 의존하고 있던 또 다른 함수에게 사이드이펙트가 전파되어서 또 다른 버그가 발생하고 만다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;한 번에 한 가지만 신경쓰는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;세 번째 정의가 어쩌면 첫 번째, 두 번째 조건을 모두 만족시키기 위한 대전제일 수 있다.&lt;br&gt;
&lt;strong&gt;단일책임원칙&lt;/strong&gt;이라는 객체 지향 프로그래밍의 원칙 중 하나이기도 한데, 하나의 객체는 딱 한 가지의 역할만 담당해야 한다는 원칙이다. 프론트엔드 코드가 엄밀한 객체지향 코드라고 하긴 어렵지만, 이 원칙 하나만큼은 신경써서 개발하는 게 도움이 된다.&lt;/p&gt;
&lt;p&gt;그 점 때문인지 이번 프로젝트는 이전 프로젝트보다 파일의 개수,디렉토리의 개수, 함수의 개수 등이 월등히 많아지게 되었다. 이전 프로젝트에서는 귀찮다거나, 코드의 양을 줄이는 게 무조건적인 미학이라 생각해서 하나의 함수 안에서 여러가지 일을 동시에 처리하는 경우가 많았었는데, 이번에는 그런 로직은 철저히 배제하였다.&lt;/p&gt;
&lt;h2&gt;4. 효율적인 소통 방식&lt;/h2&gt;
&lt;p&gt;마지막은 개발 외적인 이야기이다. &lt;a href=&quot;https://juheon.dev/230625-project-review/&quot;&gt;첫 번재 프로젝트 회고&lt;/a&gt;에서도 언급했다시피 프로젝트에서 가장 어려운 문제는 개발이 아니라 사람과 사람간의 소통의 문제인 경우가 더 많다. 특히나 프론트엔드 개발자는 그 특성상 기획/디자인/백엔드 모든 분야에 다리를 걸치고 있다보니 소통의 중요성이 더욱 강조될 수밖에 없다.&lt;/p&gt;
&lt;p&gt;이 중요성을 간과하고 무지성 개발만 하다보면 참사가 일어나기도 하는데 예를 들어 일주일 동안 열심히 개발/디자인 해놓았는데 나중에 보니 필요없는 기능이었다던지, 동료에게 특정 기능 하나를 요청했는데 나중에 보니 내 요청사항을 이해하지 못해서 기대와 다른 결과물을 받기도 한다. 그래서 이번 프로젝트에서는 내가 어떻게해야 조금 더 효율적으로 일할 수 있을 지에 대해서 먼저 고민해보았다.&lt;/p&gt;
&lt;h4&gt;첫 번째는 기획자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;내가 기획자에게 가장 많이 물어본 질문은 아마 &apos;나중에 이 기능이 추가될 수도 있나요?&apos;일 것이다. 개발 초기에 특정 기능을 배제하고 만들어놓았는데, 프로젝트 중간에 기획자가 &apos;이 기능 추가해주세요&apos;하는 사태가 벌어지면 상당히 곤란해진다.&lt;br&gt;
그래서 기획자와 개발자 사이에 서로의 상황을 이해하고 있어야 한다. 개발자는 기획자가 어떤 기능을 넣고 싶어하는지 파악해야하고, 반대로 개발자는 기획자에게 어떤 기능은 넣을 수 있고, 어떤 기능은 넣기 어려운지 분명하게 알려야 한다. 각자의 상황을 잘 알고 있어야만 나중에 &lt;code class=&quot;language-text&quot;&gt;이거 빼기로 했잖아요&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;이거 넣기로 했잖아요&lt;/code&gt; 사태를 방지할 수 있다.&lt;/p&gt;
&lt;h4&gt;두 번째는 디자이너와의 소통이다.&lt;/h4&gt;
&lt;p&gt;이전 프로젝트에서는 대부분 디자이너가 디자인 작업과 퍼블리싱 작업까지 도맡아서 한 뒤에, 나는 퍼블리싱의 최종 결과물 위에서 프론트엔드 개발을 시작했었다. 이 방식의 경우 디자이너와 프론트 개발자의 역할 부담이 완전히 나뉘어져 있는 방식인데, 이 경우 내가 프론트 개발을 하다가 디자이너에게 돌아가서 다시 물어봐야 하거나, 아니면 퍼블리싱된 코드가 개발하기에는 적합하지 않아 코드를 지우고 처음부터 다시 짜야하는 경우가 있었다.&lt;/p&gt;
&lt;p&gt;따라서 이번 프로젝트에서는 기초적인 디자인 작업과 퍼블리싱 단계에서부터 같이 참여했다. 기본적인 페이지 구조부터 컴포넌트를 어떤 단위로 쪼갤 것인지부터 고민했다. 그리고 자주 사용될만한 컴포넌트는 퍼블리싱 단계부터 미리 공통화를 시켜놓고 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값에 따라서 다르게 동작하도록 하였다.&lt;br&gt;
이렇게 작업한 결과, 이전보다 프론트엔드를 개발하면서 느꼈었던 모호함이 사라지고 1달이라는 비교적 빠른 시일 내에 서비스의 프로토타입을 개발할 수 있게 되었다.&lt;/p&gt;
&lt;h4&gt;세 번째는 백엔드 개발자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;예전에는 프론트에 어떤 API가 필요한 상황이면 백엔드 개발자에게 두루뭉실하게 &apos;이러이러한 기능하는 API 만들어주세요&apos;라고 전달했었다. 구체적으로 말하지 않더라도 &apos;무슨 말 하는지 이해하겠지?&apos;라는 마인드여서 그랬었는데 이는 역시 나의 착각이다.&lt;/p&gt;
&lt;p&gt;백엔드 개발자는 내가 무엇을 필요로 하는지 정확히 이해하기 힘들다. 반대의 경우도 마찬가지이다. 그래서 요청사항을 전달하는 방식을 바꿨다. 일단 &apos;프론트에 이런 기능이 필요한데&apos;로 시작하여 상대방에게 내가 해결하고자 하는 문제상황을 납득시켜야한다. 그 다음에 &apos;프론트에서 이 엔드포인트로 요청을 보내면, 반환값 형식 이렇게 해서 보내주세요&apos; 라고 전달한다.&lt;br&gt;
여기서 중요한 점은 반환값 형식은 내가 우선적으로 제안을 해야한다. 백엔드에서 다루는 데이터 형식이 프론트의 그것과 상당 부분 다르기 때문에, 내가 원치 않은 형식으로 받게 될 수도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;그리고 상품별로, 혹은 주문별로 상태코드를 정의해야 했다. 백엔드는 물론이고 프론트에서도 상태에 따라서 화면에 보여줘야 할 데이터가 다르기 때문이다. 이 과정 또한 백엔드와 같이 상의하면서 &apos;어떤 상태에서는 어떤 데이터를 보내줘야 하는지&apos;에 대한 일종의 규약을 만들었다.&lt;/p&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;나느 매 프로젝트를 진행하면서 스스로에게 미션을 부여한다. 처음 프로젝트를 맡았을 때는 &lt;code class=&quot;language-text&quot;&gt;vue2&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;vue3&lt;/code&gt;로 마이그레이션 하는 미션을, 이번 프로젝트에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;를 도입하는 미션이었다.&lt;/p&gt;
&lt;p&gt;이런 식으로 조금씩 내가 도전해볼만한, 개척의 여지를 찾아나감으로써 스스로 레벨업하고 있다는 느낌을 찾고 싶어서다. 누가 시켜서 하는 게 아니다. 그냥 기존에 쓰던 기술스택 그대로 써도 아무 문제 없다. 오히려 당장 개발할 때는 익숙할테니 버그도 덜 발생하고, 개발 기간도 더 짧을 수도 있다. 하지만 장기적인 관점에서, 그리고 유지보수의 관점에서는 기술을 도입함으로써 얻을 수 있는 이점이 훨씬 더 크다고 믿고 있다.&lt;/p&gt;
&lt;p&gt;다음 프로젝트에는 꼭 &lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Nuxt.js&lt;/code&gt;를 이용해서 SSR을 도입하고 싶다. 얼마 전에 살짝 찍먹해봤는데 쉽지 않을 것 같다.서버에 대한 이해도가 어느정도 갖춰져 있어야 할 것으로 보인다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TS 개념 정리]]></title><description><![CDATA[인덱스 시그니쳐 객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다. 유니온타입 인터섹션 타입 타입 alias enum 숫자형 enum 문자형 enum const enum 기본적인 enum…]]></description><link>https://juheon.dev/js_ts/230703-index-signature/</link><guid isPermaLink="false">https://juheon.dev/js_ts/230703-index-signature/</guid><pubDate>Wed, 05 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;인덱스 시그니쳐&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  [name: string]: string
}

const phone: Phone = {
  cpu: &amp;quot;A15&amp;quot;,
  sim: &amp;quot;eSIM&amp;quot;,
  brand : &amp;quot;Apple&amp;quot;,
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다.&lt;/p&gt;
&lt;h2&gt;유니온타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone | Laptop) {
  // device는 Phone과 Laptop 중 어떤 타입인지 정해져있지 않기 때문에
  // 두 인터페이스가 공통으로 갖고 있는 속성만 접근 가능하다.

  console.log(device.cpu) // ✅
  console.log(device.sim) // ❌

  // typeof나 in 연산자를 이용하여 타입을 필터링해주면 접근이 가능해진다.
  if (&amp;quot;sim&amp;quot; in device) {
    console.log(device.sim)
  }
  if (&amp;quot;gpu&amp;quot; in device) {
    console.log(device.gpu)
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;인터섹션 타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone &amp;amp; Laptop) {
  // device는 Phone과 Laptop 의 속성을 모두 만족시켜야 한다.
  console.log(device.cpu) // ✅
  console.log(device.sim) // ✅
}

getDevice({ cpu: &amp;quot;Intel&amp;quot;, sim: &amp;quot;eSIM&amp;quot; }) // ❌, Laptop이 갖고 있는 속성도 만족시켜야함.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;타입 alias&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Phone = {
  cpu: string
  sim: string
}
const myPhone: Phone = {
  cpu: &amp;quot;A16&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}
// type은 연산자를 이용한 확장 가능
type Device = Phone | Laptop&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;enum&lt;/h2&gt;
&lt;h4&gt;숫자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Count {
  ZERO,
  ONE,
  TWO,
}
// 별도로 값을 지정하지 않으면 0부터 1씩 증가하면서 값이 배정된다
console.log(Count.ZERO) // 0
console.log(Count.ONE) // 1
console.log(Count.TWO) // 2&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;문자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Color {
  PRIMARY = &amp;quot;blue&amp;quot;,
  SECONDARY = &amp;quot;white&amp;quot;,
}
console.log(Color.PRIMARY) // blue
console.log(Color.SECONDARY) // white&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;const enum&lt;/h4&gt;
&lt;p&gt;기본적인 enum은 컴파일 시, &lt;code class=&quot;language-text&quot;&gt;[속성이름]=값&lt;/code&gt;을 연결해주는 별도의 객체를 생성한다.&lt;br&gt;
하지만 enum 앞에 const를 붙이면 컴파일 시 객체를 생성하지 않고 &lt;code class=&quot;language-text&quot;&gt;[속성이름]&lt;/code&gt;을 직접 &lt;code class=&quot;language-text&quot;&gt;값&lt;/code&gt;으로 치환해버리기 때문에 컴파일 코드의 양을 줄일 수 있다.&lt;/p&gt;
&lt;h2&gt;제네릭&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T&amp;gt;(value: T): T {
  return value
}
// 파라미터에 어떤 타입을 넣느냐에 따라 value의 타입이 정해짐
console.log(gatValue(10)) // number type
console.log(gatValue(&amp;quot;hello&amp;quot;)) // string type&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T extends string&amp;gt;(value: T) {
  return value.length
}
// extends 키워드를 통해 제네릭으로 받을 타입을 제한할 수 있음
const num = getValue(10) // ❌
const str = getValue(&amp;quot;hello&amp;quot;) // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends keyof type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
type PhoneType = keyof Phone // &amp;quot;cpu&amp;quot; | &amp;quot;sim&amp;quot;

function getPhoneComponent&amp;lt;T extends keyof Phone&amp;gt;(component: T) {
  return component
}
const component1 = getPhoneComponent(&amp;quot;cpu&amp;quot;) //  ✅
const component2 = getPhoneComponent(&amp;quot;gpu&amp;quot;) // ❌&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Non-null assertion&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const elem = document.querySelector(&amp;quot;.elem&amp;quot;)
// elem : HTMLElement | null
elem.textContent = &amp;quot;Hello&amp;quot; // ❌, elem is possibly null;
elem!.textContent = &amp;quot;Hello&amp;quot; // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;유틸리티 타입&lt;/h2&gt;
&lt;h4&gt;Pick&lt;/h4&gt;
&lt;p&gt;특정 타입만 골라내서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type Cpu = Pick&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: Cpu = {
  cpu: &amp;quot;A15&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Omit&lt;/h4&gt;
&lt;p&gt;특정 타입만 제외해서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type withoutCpu = Omit&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: withoutCpu = {
  ram: &amp;quot;8GB&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Partial&lt;/h4&gt;
&lt;p&gt;모든 타입을 옵셔널 파라미터로 바꿔서 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PartialPhone = Partial&amp;lt;Phone&amp;gt;
/*
  PartialPhone = {
    cpu?:string
    ram?:string
    sim?:string
  }
*/
const myPhone: PartialPhone = {
  ram: &amp;quot;8GB&amp;quot;,
}
const yourPhone: PartialPhone = {
  cpu: &amp;quot;A16&amp;quot;,
  ram: &amp;quot;8GB&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Exclude&lt;/h4&gt;
&lt;p&gt;유니온 타입에서 특정 타입을 제외하여 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type WithoutApple = Exclude&amp;lt;PhoneBrands, &amp;quot;Apple&amp;quot;&amp;gt; // &amp;#39;Samsung&amp;#39; | &amp;#39;LG&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Record&lt;/h4&gt;
&lt;p&gt;key-value 값 형태의 객체 타입을 만들어줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneComponent = Record&amp;lt;PhoneBrands, Phone&amp;gt;
/*
 type PhoneComponent = {
  Samsung: Phone
  Apple: Phone
  LG: Phone
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;맵드 타입&lt;/h2&gt;
&lt;p&gt;이미 정의된 타입을 가지고 새로운 타입을 만들어줌&lt;/p&gt;
&lt;h4&gt;in&lt;/h4&gt;
&lt;p&gt;유니온타입의 원소를 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type Phone = {
  [brand in PhoneBrands]: string
}
/*
type Phone = {
    Samsung: string;
    Apple: string;
    LG: string;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;in keyof&lt;/h4&gt;
&lt;p&gt;객체의 각 속성을 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneIncluded = {
  [phone in keyof Phone]: boolean
}
/*
type PhoneIncluded = {
    cpu: boolean;
    ram: boolean;
    sim: boolean;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yes24.com/Product/Goods/119410497&quot;&gt;쉽게 시작하는 타입스크립트(장기효)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[pinia 소개 및 도입 후기]]></title><description><![CDATA[pinia란? 기존 vue의 전역 상태관리 라이브러리는 거의 가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 ,,,와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 9…]]></description><link>https://juheon.dev/vue/230704-start-pinia/</link><guid isPermaLink="false">https://juheon.dev/vue/230704-start-pinia/</guid><pubDate>Tue, 04 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;pinia란?&lt;/h2&gt;
&lt;p&gt;기존 vue의 전역 상태관리 라이브러리는 거의 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 &lt;code class=&quot;language-text&quot;&gt;redux&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;recoil&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;MobX&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;zustand&lt;/code&gt;와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 99% &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 써야했다. 오히려 이 점이 학습에 대한 부담(여러 라이브러리 두루 알고 있어야 함)을 줄여주기도 했지만, vuex의 아쉬운 점을 대체할 수단이 없다는 단점을 껴안고 있었다.&lt;/p&gt;
&lt;p&gt;그러다가 2019년 11월에 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 experiment to redesign(리디자인 실험)으로서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;가 처음 출시되었고, 현재는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신하여 vue의 공식 상태관리 라이브러리로 자리잡았다. 이름은 달라졌다고는 해도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt; 개발팀이 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 개발했기 때문에 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 기능과 문법은 거의 바뀌지 않았고 새로 학습해야할 내용도 부담 없는 수준이다.(공식문서에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;vuex 5&lt;/code&gt;의 다른 이름이라고 소개한다)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://npmtrends.com/pinia-vs-vuex&quot;&gt;npmtrends&lt;/a&gt;를 보더라도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와의 격차가 점점 줄어들고 있음을 확인할 수 있다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.177215189873415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA5UlEQVR42lVRC67EIAj0/jfdZPO2La2KAvMC9LNrMgEHcEAK9w4zgwFpVaCqYaEDlSfenwV6/EE8SSfsgud/15qirOsKa44N1ncY79DwKTkmgAk2GqwtyfMevDWC1eWp7YTSvMPZYTJCwZVU5VF2eIxe2RW+eJ/EY17vvndYaz3bxT1CjJxEQmZMEefi7mef4zWFiFzqJynU1DBFwaJhXWRI4mDB1gVbEyxVsLYZPnVBOWrF3v2iNzKY/s5pP1VAp9+nQkLwF84VEYkOLjhZW8cY8x7bbeucmz+3aSZgZqjavWH/w3+SAyeNoekG7wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;npm trends pinia&quot;
        title=&quot;&quot;
        src=&quot;/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png&quot;
        srcset=&quot;/static/c5bf99a91716a6dc0ec17d96e55aae29/c26ae/npm-trends-pinia.png 158w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/6bdcf/npm-trends-pinia.png 315w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/f058b/npm-trends-pinia.png 630w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/40601/npm-trends-pinia.png 945w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/78612/npm-trends-pinia.png 1260w,
/static/c5bf99a91716a6dc0ec17d96e55aae29/1cb21/npm-trends-pinia.png 2586w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;vuex와 비교해 달라진 점&lt;/h2&gt;
&lt;h4&gt;1. 다중 store&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서 여러 종류의 store를 사용할 경우 일반적으로 modules 디렉토리 밑에 몰아넣고 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 하나로 합쳐주는 방식을 사용하였다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
src
└── store
    ├── index.js
    └── modules
        ├── counter.js
        ├── user.js
        ├── order.js
        └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 다중store를 지원하기 때문에 modules를 사용할 필요가 없어졌다. 따라서 stores 디렉토리 밑에 모든 store를 둘 수 있게 되었다. (개인 선호에 따라 &lt;code class=&quot;language-text&quot;&gt;stores/index.js&lt;/code&gt;를 두어서 기본 설정을 초기화하는 코드를 작성하기도 한다.)&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
src
└── stores
    ├── counter.js
    ├── user.js
    ├── order.js
    └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;2. mutation 없이 state의 직접 변경 가능&lt;/h4&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 state의 값을 변경하려면 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 통해야 했다.&lt;br&gt;
가령 &lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;라는 state와 이 값을 증가시키는 &lt;code class=&quot;language-text&quot;&gt;increment&lt;/code&gt;라는 함수가 있다고 하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
const store = createStore({
  state: {
    count: 1,
  },
  mutations: {
    increment(state) {
      state.count++
    },
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;값을 증가시키기 위해서는 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;에 등록된 함수를 통해서만 접근해야 한다.
&lt;code class=&quot;language-text&quot;&gt;store.state.count++&lt;/code&gt;처럼 직접적으로 state를 변경시키는 건 허용되지 않았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ $store.state.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    // store.state.count++; // 직접 변형 불가
    store.commit(&amp;#39;increment&amp;#39;); // 반드시 mutation을 통해서만 변형
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 사라지고 값의 직접 변형이 가능해졌다. 따라서 매번 state값을 변경하기 위한 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;함수를 만들 필요가 없어졌기 때문에 상당히 편리해졌다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 1,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;counterStore&lt;/code&gt;로 받아오기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ counterStore.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    counterStore.count++; // 직접 변경 가능
    return{
      counterStore,
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;변경해야 하는 값이 복잡하거나, 따로 함수로 분리하고 싶다면 &lt;code class=&quot;language-text&quot;&gt;actions&lt;/code&gt;에서 선언하거나 혹은 아래에서 설명할 &lt;code class=&quot;language-text&quot;&gt;$patch&lt;/code&gt; 라는 내장 메소드를 사용하면 된다.&lt;/p&gt;
&lt;h4&gt;3. Typescript 호환성 증가&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 도입하기 까다로웠던 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 쉽게 사용할 수 있게 되었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
interface VueLib {
  state: &amp;quot;vuex&amp;quot; | &amp;quot;pinia&amp;quot;
}

export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 0 as number,
      library: {
        state: &amp;quot;pinia&amp;quot;,
      } as VueLib,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;프로젝트 도입 후기&lt;/h2&gt;
&lt;h4&gt;1. mutation 이 없어서 정말 편리하다&lt;/h4&gt;
&lt;p&gt;위에서 언급했다시피 state값의 직접 변형이 가능하기 때문에 별도의 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 선언할 필요가 없다는 점이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;로 개발하면서 느꼈던 답답함을 한방에 뚫어주는듯한 기분이다. 덕분에 &lt;code class=&quot;language-text&quot;&gt;store&lt;/code&gt; 코드의 절반 가량을 차지하던 부분이 사라졌으니 코드가 상당히 가벼워지고 가독성도 나아졌다.&lt;/p&gt;
&lt;h4&gt;2. 생각보다 유용한 내장 메소드&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 Option API 기준으로 3개의 내장 메소드를 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$reset()&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt; 값들을 모두 초기화시킨다. 예를 들어 회원 로그인시 회원 데이터를 store에 갖고 있다가 로그아웃을 하면 값을 초기화해주어야 할 때 사용한다. 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 개발자가 직접 reset함수를 만들어야 했는데 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 에서는 그럴 필요가 없어졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$patch(state)&lt;/code&gt; : state값을 변경시켜주는 함수이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 값의 직접 변경이 가능한데 왜 굳이 필요한가 싶을 수 있는데, 여러 변수들의 값을 한번(함수 하나)에 변경하려고 할 때나 값의 변경 로직이 복잡해지면 오히려 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 그리워 질 수도 있다. &lt;code class=&quot;language-text&quot;&gt;$patch()&lt;/code&gt;함수가 그 역할을 대신한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;counterStore.$patch({ count: 1 })
OR
counterStore.$patch(state =&amp;gt; {
  state.count = state.count + 1
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;$subscribe(mutation,state)&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;하는 기능이라고 생각하면 된다. 프로젝트에서는 이 기능을 써보지 않아서 정확히 어떤 상황에 필요할 지는 잘 모르겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. modules가 없어져서 코드 양은 쪼금 늘어날 수 있다&lt;/h4&gt;
&lt;p&gt;개인적으로 한가지 아쉬운 점은 모든 store를 하나로 묶어주는 modules 기능의 부재로 인하여 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 가져올 때처럼 &lt;code class=&quot;language-text&quot;&gt;$store.state.[store이름]&lt;/code&gt; 식으로 접근할 수 없다는 점이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{$store.state.counter.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 반드시 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;use*Store()&lt;/code&gt; 훅을 이용하여 &lt;code class=&quot;language-text&quot;&gt;*store&lt;/code&gt;를 한번 빼와야만 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서도 값을 전달할 수 있다. 그래서 코드의 양이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;대비 늘어날 수도 있다. 그렇다고 이거 하나가 단점이라 지적하기엔 사소한 문제이고 1,2번에서 얻을 수 있는 이점이 훨씬 더 크다고 생각한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{counterStore.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    return{
      counterStore,
    }
  }
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 비교하여 typescript 지원, mutation 삭제, 다중 store지원 같은 기능으로 인하여 DX(개발 경험)을 상당히 개선시켜 주었다. 커뮤니티와 자료의 양이 아직 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;만큼은 아니지만 조금씩 쌓여나가고 있다는 점에서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 도입을 주저하는 개발자가 있다면 주저하지 말고 한번 써보라고 추천하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>https://juheon.dev/vue/230702-vmodel-and-custom-component-2/</link><guid isPermaLink="false">https://juheon.dev/vue/230702-vmodel-and-custom-component-2/</guid><pubDate>Sun, 02 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juheon.dev/vue/230701-vmodel-and-custom-component-1/&quot;&gt;지난 포스팅&lt;/a&gt;에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리와 커스텀 컴포넌트를 만드는 방법에 대해서 살펴보았다. 이번 포스팅에서는 만들어진 컴포넌트에다 각각의 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 특성에 맞는 로직을 구현해보도록 하겠다.&lt;/p&gt;
&lt;h2&gt;기본 구조&lt;/h2&gt;
&lt;p&gt;부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;와 전화번호를 위한 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;, 이메일을 위한 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 자식 컴포넌트로 구성한다. 자식 컴포넌트는 지난 포스팅에서 다루었던 &lt;code class=&quot;language-text&quot;&gt;MyInput.vue&lt;/code&gt;를 베이스로 작성했다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;App.vue
└── MainPage.vue
  ├── InputContact.vue
  └── InputEmail.vue&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;연락처와 이메일과 관련된 변수는 당연히 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서만 관리하고, 두 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 전달하여 데이터 처리 로직 수행 후, &lt;code class=&quot;language-text&quot;&gt;emit(&apos;update:modelValue&apos;)&lt;/code&gt;로 가공된 데이터를 넘겨주는 방식이다.&lt;/p&gt;
&lt;h2&gt;전화번호를 위한 input&lt;/h2&gt;
&lt;p&gt;전화번호를 입력하는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;을 생각해보자. 우선적으로 필요한 기능은 전화번호 사이마다 &apos;-&apos;를 넣어주는 기능이다. 예를 들어 사용자가 &lt;code class=&quot;language-text&quot;&gt;01012345678&lt;/code&gt;를 입력한다면 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;010-1234-5678&lt;/code&gt;로 표시되도록 해야한다.&lt;/p&gt;
&lt;p&gt;그래서 일단 전화번호 포맷팅을 수행하는 &lt;code class=&quot;language-text&quot;&gt;formatContact()&lt;/code&gt; 함수에 정규표현식을 사용하려고 한다. 전화번호 포맷팅 관련 정규표현식은 구글링을 해봐도 쉽게 찾을 수 있지만 내가 사용한 정규표현식은 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;formatContact&lt;/code&gt;함수를 &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt;의 콜백함수에 넣어주고, &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 호출할 때도 &lt;code class=&quot;language-text&quot;&gt;formatted&lt;/code&gt;된 값을 부모 컴포넌트(&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;)에 넘겨야한다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
    const formatted = formatContact(newValue);
    emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const formatContact = (rawString) =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;); //아직 숫자 입력되기 전의 -는 가려주기
  return formatted;
};
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;는 그냥 일반적인 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그를 다룰 때처럼만 작성하면 된다. 커스텀 컴포넌트로 변경했다고 한들, 부모 컴포넌트가 데이터 처리 로직에 관여해서 안되고 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;되는 이벤트에만 의존하고 있어야 한다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputContact v-model=&amp;quot;contact&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;contact : {{ contact }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputContact from &amp;quot;@/components/InputContact.vue&amp;quot;;

const contact = ref(&amp;quot;&amp;quot;);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;선택적으로 포맷팅하고 싶다면?&lt;/h4&gt;
&lt;p&gt;위 코드에서는 전화번호가 항상 포맷팅되지만, 상황에 따라서는 포맷팅되지 않는 걸 원할 수도 있다. &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 &lt;code class=&quot;language-text&quot;&gt;useFormat&lt;/code&gt; 을 받아서 이 값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;일 때만 포맷팅되도록 할 수도 있다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const props = defineProps({
  modelValue: String,
  useFormat: {
    type: Boolean,
    default: true,
  },
})

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;])

const onInput = e =&amp;gt; {
  const newValue = e.target.value
  if (props.useFormat) {
    const formatted = formatContact(newValue)
    emit(&amp;quot;update:modelValue&amp;quot;, formatted)
  } else {
    emit(&amp;quot;update:modelValue&amp;quot;, newValue)
  }
}

const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3자리,4자리,4자리로 끊고 -로 구분하기
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;InputContact :useFormat=&amp;quot;true&amp;quot; v-model=&amp;quot;contact&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;이메일을 위한 input&lt;/h2&gt;
&lt;p&gt;이번에는 이메일을 입력받는 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 살펴볼텐데, 전화번호와는 다르게 유효성을 검증하는 기능을 하나 추가하려고 한다. 이메일 유효성을 검증하는데에도 역시 구글링해보면 정규표현식이 많이 나오긴 하지만 여기서는 편하게 &lt;code class=&quot;language-text&quot;&gt;email-validator&lt;/code&gt;라는 npm 패키지를 사용했다.&lt;/p&gt;
&lt;p&gt;큰 틀에서는 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;와 동일하나, &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt; 이벤트마다 유효성 검증을 거친 값을 부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 전달해주어야 한다. 따라서 나는 &lt;code class=&quot;language-text&quot;&gt;emit(&apos;is-valid&apos;,유효성여부)&lt;/code&gt;으로 지정했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&amp;quot;email&amp;quot; :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import * as EmailValidator from &amp;quot;email-validator&amp;quot;;

const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;, &amp;quot;is-valid&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  const isEmailValid = checkEmailValid(newValue);
  emit(&amp;quot;is-valid&amp;quot;, isEmailValid);
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const checkEmailValid = (email) =&amp;gt; {
  return EmailValidator.validate(email);
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 보낸 값을 &lt;code class=&quot;language-text&quot;&gt;@is-valid&lt;/code&gt;로 받고 콜백함수에서 유효성 여부를 인자로 받을 수 있다. 콜백함수를 위한 별도의 함수를 하나 만들어도 되긴 하는데, 예제 상에서는 만들지 않고 &lt;code class=&quot;language-text&quot;&gt;isEmailValid&lt;/code&gt;라는 변수에 직접 넣어주는 방식을 선택하였다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputEmail v-model=&amp;quot;email&amp;quot; @is-valid=&amp;quot;(data) =&amp;gt; (isEmailValid = data)&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;email : {{ email }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;valid : {{ isEmailValid }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputEmail from &amp;quot;@/components/InputEmail.vue&amp;quot;;

const email = ref(&amp;quot;&amp;quot;);

const isEmailValid = ref(null);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-2-mcx2wv?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input-2&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>https://juheon.dev/vue/230701-vmodel-and-custom-component-1/</link><guid isPermaLink="false">https://juheon.dev/vue/230701-vmodel-and-custom-component-1/</guid><pubDate>Sat, 01 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;반복되는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그&lt;/h2&gt;
&lt;p&gt;사용자에게 입력을 받기 위해서는&lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그가 필요한데, 입력 받는 데이터의 종류와 특성에 따라 제공되는 기능이 달라질 수 있다. 예를 들어 &apos;오늘의 집&apos;의 주문 페이지를 살펴보자.&lt;/p&gt;
&lt;div align=&quot;center&quot; height=&quot;600&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/230701-vmodel-and-custom-component-1/input-tag-1.png&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;!--![](./input-tag-1.png)--&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이름이나 주소같은 단순한 텍스트 : &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문자가 아닌 오직 숫자만 입력받을 경우(상품 수량) &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;number&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전화번호 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;tel&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이메일 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;email&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이처럼 같은 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그라도 각각의 특성과 수행해야 될 기능이 다르다.&lt;br&gt;
이름이나 주소의 경우에는 빈 문자열이어서는 안된다거나 최소/최대 글자수 제한이 있을 수 있고, 전화번호나 이메일은 유효성 검증을 거쳐야 할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;속성으로으로도 어느정도 해결할 수는 있지만, 이러한 기능을 가진 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그들이 프로젝트에서 반복적으로 사용된다면 컴포넌트로 분리시켜 공통화하고 싶다는 생각이 든다. 그러면 각 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Input&gt;&lt;/code&gt; 컴포넌트별로 특정 기능에만 집중할 수 있다. 그렇다면 커스텀 컴포넌트화 시키려면 어떻게 해야하는지 살펴볼 건데, 그 전에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리에 대해서 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리&lt;/h2&gt;
&lt;p&gt;vue의 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 양방향 데이터바인딩(two-way binding) 기능을 제공하는 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;br&gt;
양방향 바인딩이란, 화면상에 보이는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;에 데이터를 입력(수정)할 때마다 &lt;code class=&quot;language-text&quot;&gt;Javascript&lt;/code&gt;에서도 실시간으로 변화를 감지하여 값이 업데이트 되는 기능이다.&lt;/p&gt;
&lt;p&gt;SPA 라이브러리를 vue로 처음 입문한 사람에게는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 왜 편리한 기능인지 이해하기 어려울 수 있지만, react를 접한 뒤에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 만난다면 그 편리함에 감탄할 것이다. 왜냐하면 react에서 양방향 바인딩을 구현하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;태그에 다음와 같이 작성해야만 했다.&lt;/p&gt;
&lt;h4&gt;react&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const [text, setText] = useState(&amp;quot;&amp;quot;)
const onInputChange = e =&amp;gt; {
  setText(e.target.value)
}
...
return &amp;lt;input onChange={onInputChange} value={text} /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 이를 vue에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;로 구현한다면 간단하게 구현할 수 있다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input v-model=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;두 코드 사이에서 주목해야 할 점은 react의 경우에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그에 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개가 필요한 반면에, vue에서는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 단 하나만 필요하다는 점이다. 단순히 생각해보더라도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개의 역할을 동시에 수행하고 있으리라 예상할 수 있다.&lt;br&gt;
사실은 vue도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 사용하지 않고 양방향 바인딩을 구현해보자면 아래와 같이 구현해야 했다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input @change=&amp;quot;onChangeInput&amp;quot; :value=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);
const onChangeInput = (e) =&amp;gt; {
  text.value = e.target.value
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 매번 두 개의 속성을 적어주는 건 성가신 일이기 때문에 이를 하나로 합쳐서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 탄생하게 된 것이다.
vue에서는 이처럼 tag 레벨에서 자주 쓰이는 기능들은 하나의 공통 함수로 묶게 되었는데 이게 바로 vue의 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필자 개인의견 : &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 react와 vue가 추구하는 방향성의 다름을 가장 잘 보여주는 대목이다. react는 코드 뒷편에서 무슨 일이 일어나는지 최대한 개발자에게 숨기지 않고 드러내려는 반면, vue는 &apos;이 기능은 라이브러리에서 책임질테니, 무슨 일이 일어나는 지는 신경쓰지 마&apos;라고 말하는 인상이 들었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;커스텀 컴포넌트로 만들기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;을 컴포넌트화 시켜서 부모-자식간의 관계가 형성되면 부모 컴포넌트에서 자식 컴포넌트로&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;를 별도로 연결시켜주어야만 양방향 데이터 바인딩 기능을 유지할 수 있다.&lt;/p&gt;
&lt;p&gt;방법은 어렵지 않다. 부모 컴포넌트 입장에서는 컴포넌트화하기 이전 코드와 동일하게 &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;data&quot;&lt;/code&gt;를 걸어주기만 하면 된다. 이렇게만 하면 자식 컴포넌트의 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;에서 자동으로 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;라는 (미리 정해진)이름으로 받을 수 있게 된다.&lt;/p&gt;
&lt;p&gt;다만 자식 컴포넌트에서는 별도로 처리해줘야 한다. &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;modelValue&quot;&lt;/code&gt;로 받을 수 있을 것 같지만 아쉽게도 불가능하다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;@input=&quot;() =&gt; modelValue = e.target.value&quot;&lt;/code&gt;가 생략되어있는데, vue에서 자식 컴포넌트가 받은 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값(여기서는 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;)의 직접 변형이 불가능하기 때문이다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 자식 컴포넌트에서는 input 이벤트가 발생하면 부모 컴포넌트에게 이를 알려야 한다.&lt;br&gt;
자식컴포넌트가 부모컴포넌트에게 이벤트를 발생시키고 싶을 때 호출하는&lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 통해&lt;br&gt;
&lt;em&gt;&quot;&lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;의 값이 &lt;code class=&quot;language-text&quot;&gt;e.target.value&lt;/code&gt;로 변했다&quot;&lt;/em&gt;&lt;br&gt;
는 정보만 전달하고, 실질적인 변경된 값을 반영하는 과정은 부모 컴포넌트에서 진행되야 한다. 다행히도 그 과정은 이미 &lt;code class=&quot;language-text&quot;&gt;update:modelValue&lt;/code&gt;라는 이벤트로 미리 등록되어 있기 때문에 우리가 직접 구현할 필요는 없다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue (parent)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;MyInput v-model=&amp;quot;num&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;text : {{ num }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import MyInput from &amp;quot;@/components/MyInput.vue&amp;quot;;

const num = ref(&amp;quot;Hello&amp;quot;);
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MyInput.vue (child)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;!-- 불가능 --&amp;gt;
  &amp;lt;!-- &amp;lt;input v-model=&amp;quot;modelValue&amp;quot; /&amp;gt;  --&amp;gt;

  &amp;lt;input :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-3tnt3q?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;다음 포스팅에서 &apos;input 종류별로 기능 적용하기&apos;를 소개하겠습니다&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react에는 named-route 없나요?(Feat. vue에는 있는데..)]]></title><description><![CDATA[2023-05-05에 작성된 원문을 수정한 버전입니다 vue-router를 사용하는 두 가지 방법 vue…]]></description><link>https://juheon.dev/vue/230630-vue-named-route/</link><guid isPermaLink="false">https://juheon.dev/vue/230630-vue-named-route/</guid><pubDate>Fri, 30 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-05-05에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/229&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;vue-router를 사용하는 두 가지 방법&lt;/h2&gt;
&lt;p&gt;vue에서는 &lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;router-link&gt;&lt;/code&gt; 컴포넌트로 페이지 이동을 하려면 크게 두 가지 방법이 있는데, 하나는 해당 페이지의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 직접 적는 방법과 다른 하나는 &lt;code class=&quot;language-text&quot;&gt;router&lt;/code&gt;에서 미리 정의해둔 &lt;code class=&quot;language-text&quot;&gt;route name&lt;/code&gt;을 적는 방법이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/about&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;

// 그리고 vue-router에서 미리 route별로 name을 지정해주어야 한다
const routes = [
	{
		path: &amp;#39;/&amp;#39;,
		name: &amp;#39;Home&amp;#39;,
		component: ...,
	},
	{
		path: &amp;#39;/about&amp;#39;,
		name: &amp;#39;About&amp;#39;,
		component: ...,
	},
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;하지만 오타가 난다면?&lt;/h2&gt;
&lt;p&gt;나는 개발할 때 주로 방법 2를 선호하는데 그 이유는 방법 1의 경우에는 경로명을 잘못 입력하더라도 에러로 검출해내지 못하고 클릭하면 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동시켜버리는 반면에, 방법 2는 아래와 같이 개발자 도구의 콘솔창에서 에러를 띄워주기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/abou&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생X&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Abou&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생함&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/64639/named-route-error.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 23.417721518987342%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA2ElEQVR42o3JW1OCQABAYf7/f6qnrMwxEbkYphOWGMjuchVE2NNEUy/WTA/fnIdjhMEIlVhkyqMQLlVsUec+TfE89FSu4by71IW0dUCVbzgWG8p8TVO9YBztB/Rqgd6u6OSePj8MdCmgklBKKJJfteqdOtkNGhHSyD0GkyncjGhnJjvHI1g4vNoupyjmfBCg0j/1UtEJ+aMXCkPf3sHVNYzHpKZJYM7xpo/4psWb7YJUkKb/lGFoawaTe3DmlL5H9OQReA7bpUO0WtKLGJ0KyL7JC/pT+vU+AO/YeJJTSVuIAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;named route error&quot;
        title=&quot;&quot;
        src=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/f058b/named-route-error.png&quot;
        srcset=&quot;/static/ce3ee02400fcbc8fb937fed74135d507/c26ae/named-route-error.png 158w,
/static/ce3ee02400fcbc8fb937fed74135d507/6bdcf/named-route-error.png 315w,
/static/ce3ee02400fcbc8fb937fed74135d507/f058b/named-route-error.png 630w,
/static/ce3ee02400fcbc8fb937fed74135d507/40601/named-route-error.png 945w,
/static/ce3ee02400fcbc8fb937fed74135d507/78612/named-route-error.png 1260w,
/static/ce3ee02400fcbc8fb937fed74135d507/64639/named-route-error.png 1568w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;방법 1은 오타가 발생하더라도 해당 라우터를 클릭해서 404 페이지가 뜨는 걸 확인하기 전까지는 찾기가 어렵다. 왜냐하면 사용자가 오타를 낸 건지, 아니면 정말로 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동하길 원하는지 라우터에게는 알 수 있는 정보가 없기 때문이다.&lt;/p&gt;
&lt;p&gt;반면에 방법 2에서는 라우터를 클릭하기 전에도 콘솔창에서 에러를 검출할 수 있다. &lt;code class=&quot;language-text&quot;&gt;routes&lt;/code&gt;에 들어있는 원소를 하나씩 뒤져보면서 name이 &lt;code class=&quot;language-text&quot;&gt;Abou&lt;/code&gt;와 일치하는 라우트를 찾아본다. 일치하는 라우트가 없으면 에러로 판별해낼 수 있는 단서가 제공된다는 뜻이다.&lt;/p&gt;
&lt;p&gt;이런 식으로 vue 에서는 &lt;code class=&quot;language-text&quot;&gt;named-route&lt;/code&gt;기반으로 페이지 이동이 가능하기 때문에 예상치 못한 오타 발생시 에러로 검출할 수 있는 반면에 react에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link to={&apos;/about&apos;}&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;useNavigate&lt;/code&gt;훅의 &lt;code class=&quot;language-text&quot;&gt;navigate(&apos;/about&apos;)&lt;/code&gt;와 같이 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt; 기반으로만 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 위의 언급한 방법 1처럼 오타로 인한 route 이동을 막을 수 있는 방법은 아직까지는 찾지 못하였다. 타입스크립트로 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;enum&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;으로 변수화시키는 방법이라면 가능할 지도 모르겠다는 생각은 드는데, 실무에서도 그렇게 개발할 지는 모르겠다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;현재 페이지 판별&lt;/h2&gt;
&lt;p&gt;위 주제와 비슷한 궁금증.&lt;/p&gt;
&lt;p&gt;리액트에서는 현재 접속해있는 페이지를 판별하는 방법에 대해서이다.
예를 들어 현재 접속한 페이지와 일치하면 class에 &lt;code class=&quot;language-text&quot;&gt;isMatched&lt;/code&gt;를 붙여서 하이라이트 스타일을 주는 상황을 생각해보자.
vue로 구현한다면 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;router-link :to={name : &amp;quot;Home&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;
    Home
  &amp;lt;/router-link&amp;gt;
  &amp;lt;router-link :to={name : &amp;quot;About&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;
    About
  &amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실상 스크립트 코드를 하나도 작성하지 않고 template 레벨에서만 현재 라우트 일치 여부를 판별해낼 수 있다.&lt;/p&gt;
&lt;p&gt;이걸 react 로 작성해본다면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Header() {
  const { pathname: currentPath } = useLocation()
  const isMatch = (path: string) =&amp;gt; {
    if (currentPath === path) return &amp;quot;matched&amp;quot;
  }
  return (
    &amp;lt;Nav&amp;gt;
      &amp;lt;Link to=&amp;quot;/&amp;quot; className={currentPath === &amp;quot;/&amp;quot; ? &amp;quot;matched&amp;quot; : &amp;quot;&amp;quot;}&amp;gt;
        Home
      &amp;lt;/Link&amp;gt;
      &amp;lt;Link to=&amp;quot;/about&amp;quot; className={isMatch(&amp;quot;/about&amp;quot;)}&amp;gt;
        About
      &amp;lt;/Link&amp;gt;
    &amp;lt;/Nav&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;useLocation&lt;/code&gt;훅을 통해서 현재의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 한번 뽑아와야하며, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;에서도 클래스를 동적으로 바인딩 할 때도 삼항연산자로 판별하거나, 코드를 줄이려면 &lt;code class=&quot;language-text&quot;&gt;isMatch&lt;/code&gt;함수를 하나 선언해서 인자로 현재 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;To&lt;/code&gt; 값을 그대로 넣어줘야 한다(물론 이건 vue도 마찬가지다).&lt;/p&gt;
&lt;p&gt;vue는 template 레벨에서 &lt;code class=&quot;language-text&quot;&gt;$route.name&lt;/code&gt; 으로 현재 라우트 정보를 한방에 가져올 수 있고, class-binding을 할 때에도 &lt;code class=&quot;language-text&quot;&gt;:class={isMatched : someValue}&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;someValue&lt;/code&gt;값이 true면 곧바로 클래스 이름으로 붙일 수 있어 편리하다.&lt;/p&gt;
&lt;p&gt;vue는 &lt;code class=&quot;language-text&quot;&gt;너한테-이런게-필요할거-같았어&lt;/code&gt; 기능(함수)들이 미리 제공되어있는 반면에 react는 &lt;code class=&quot;language-text&quot;&gt;너가-직접-구현하렴&lt;/code&gt;같은 느낌이다.&lt;br&gt;
react는 기능에 대한 부품들만 던져준다면, vue는 그 부품으로 조립까지 해주는 느낌이랄까? 각 라이브러리가 추구하는 방향성의 차이를 알 수 있는 대목이다.&lt;/p&gt;
&lt;p&gt;각자 장단점이 있겠지만, 나 같이 vue를 먼저 익히고 난 뒤에 react에서는 그 기능을 어떻게 구현해야 하는지 찾아보는 입장에서는 조금 답답함이 느껴지는 것도 사실이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue-router를 통한 페이지간 state 전달]]></title><description><![CDATA[2023-04-24에 작성된 원문을 수정한 버전입니다 페이지에 state를 전달하는 방법 react에서는 페이지 이동 시 state를 전달하기 위해서는 에서  컴포넌트 또는  훅을 통해 전달이 가능하다. 반면에 vue…]]></description><link>https://juheon.dev/vue/230629-vue-router-state/</link><guid isPermaLink="false">https://juheon.dev/vue/230629-vue-router-state/</guid><pubDate>Thu, 29 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-24에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/227&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;페이지에 state를 전달하는 방법&lt;/h2&gt;
&lt;p&gt;react에서는 페이지 이동 시 state를 전달하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt; 컴포넌트 또는 &lt;code class=&quot;language-text&quot;&gt;useNaviate()&lt;/code&gt; 훅을 통해 전달이 가능하다.&lt;br&gt;
반면에 vue에서는 직접적인 전달 방법이 존재하지 않아 개발자 자체적으로 방법을 찾아야 했다. 생각해볼 수 있는 방법으로는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 같은 전역상태 저장소에 넣어두고 꺼내쓰기&lt;br&gt;
=&gt; 일회용 데이터를 위해서 전역상태에 임시 데이터를 넣고 싶지는 않았다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;router.push()&lt;/code&gt;를 하는 코드 직후에 &lt;code class=&quot;language-text&quot;&gt;window.pushState(state)&lt;/code&gt;를 추가해서 페이지가 이동되면 꺼내쓴다&lt;br&gt;
=&gt; 그나마 현실적인 방법이다. 다만 history를 두번으로 push하기 때문에 똑같은 페이지가 히스토리에 스택에 두번 들어가게 된다.&lt;/li&gt;
&lt;li&gt;이동하려는 URL에 쿼리스트링으로 데이터 값을 담아서 전달 하기&lt;br&gt;
=&gt; URL이 괜히 길어지는데다가, 보안상 민감한 데이터는 쿼리스트링에 담기 조심스럽다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이런 불편함 때문인지 vue git의 rfc에도 글이 몇 개 올라와 있었고, 드디어 2022년 7월에 &lt;code class=&quot;language-text&quot;&gt;vue-router@4.1.0&lt;/code&gt;버전에서 정식 기능으로 추가되었다(&lt;a href=&quot;https://github.com/vuejs/router/releases/tag/v4.1.0&quot;&gt;링크&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;방법은 간단하다. router에 params를 넣는 방식처럼 state도 객체 형태로 적어주기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.push({name &amp;#39;NextPage&amp;#39;, state : { isDetailsOpen : true }})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;다만 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;useRoute()&lt;/code&gt;에서 뽑아내는 게 아니라, &lt;code class=&quot;language-text&quot;&gt;windiw.history.state&lt;/code&gt;에서 직접 꺼내야한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { isDetailsOpen } = window.history?.state || false&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실 정식기능으로 추가되었다고는 하더라도 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;객체의 state 힘을 빌리는 정도에 불과하기 때문에 위에서 언급한 임시 해결방법 2번과 거의 유사하다고 볼 수 있다. 또한 이 방법을 사용한다고 하더라도 보안에 민감한 데이터를 전달하기엔 역시나 찝찝한 구석이 있다. 그냥 다음 페이지에의 상태(모달 오픈 여부 등)만 전달하는 데 사용할 수 있을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[router-view 에서 DOM을 찾지 못하는 문제]]></title><description><![CDATA[2023-04-04에 작성된 원문을 수정한 버전입니다 router-view안에 있는 DOM은 왜 못 찾지? vue로 프론트엔드 개발을 하던 도중,  에서 안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class…]]></description><link>https://juheon.dev/vue/230628-router-view-find-dom/</link><guid isPermaLink="false">https://juheon.dev/vue/230628-router-view-find-dom/</guid><pubDate>Wed, 28 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/225&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;router-view안에 있는 DOM은 왜 못 찾지?&lt;/h2&gt;
&lt;p&gt;vue로 프론트엔드 개발을 하던 도중, &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class가 존재 유무를 확인해야 했다).&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;document.querySelector(&apos;.특정클래스&apos;)&lt;/code&gt;함수를 호출하여 해당 DOM에 접근하려고 시도했는데 결과는 예상과 달리 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;로 반환되었다. (파일 구조는 아래와 같이 구성되어있다.)&lt;/p&gt;
&lt;h4&gt;NavBar.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;nav&amp;gt;
    &amp;lt;router-link :to=&amp;quot;{ name: &amp;#39;Home&amp;#39; }&amp;quot;&amp;gt;Home&amp;lt;/router-link&amp;gt;
  &amp;lt;/nav&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Home.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1 class=&amp;quot;home&amp;quot;&amp;gt;This is home&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;NavBar /&amp;gt;
  &amp;lt;router-view /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
...
export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

      console.log(homeEl); // not found
      console.log(navEl); // found
    });
  },
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;내부에 있는 DOM요소(&apos;home&apos; 클래스)에 접근하는 건데 왜 못 찾는 걸까? 혹시나 하는 마음에 똑같이 글로벌 범위로 사용되는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;를 찾아보았을 때는 잘 찾고 있었다.&lt;/p&gt;
&lt;p&gt;내 경험상 vue에서 특정 DOM을 찾지 못하는 문제에 부딪혔을 때는 일단 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 딜레이를 걸어서 찾으면 해결되는 경우가 많았다. 그래서 일단 아래와 같이 코드를 수정해보았다.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;script&amp;gt;
export default {
  setup() {
    onMounted(() =&amp;gt; {
      setTimeout(()=&amp;gt;{
        const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
        const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

        console.log(homeEl); // found
        console.log(navEl); // found
      },1000)
    });
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아니나 다를까, 시간을 두고 DOM을 찾았더니 성공하였다. 우선 가장 무식한(비효율적인) 방법으로는 문제를 해결하기는 했다.&lt;/p&gt;
&lt;p&gt;문제의 원인은 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;가 &lt;strong&gt;mount 될 때까지 미세하게나마 시간이 소요되기 때문&lt;/strong&gt;이었다.&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;onMounted()&lt;/code&gt;가 호출되는 시점에는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;Home.vue&lt;/code&gt; 는 아직 mount되기 이전이었기 때문에 DOM에 접근할 수 없었던 것이다. 그에 반해 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부에 있지 않고 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에 독립적으로 존재하기 때문에 mount되는 시간이 훨씬 짧아 접근이 가능하다.&lt;/p&gt;
&lt;h2&gt;해결책은 router.isReady()&lt;/h2&gt;
&lt;p&gt;개발할 때는 워낙 빠릿하게 작동해서 눈치채기는 어렵지만 사실 router가 mount되기까지의 딜레이는 결코 무시할 수 없는 수준으로 꽤 긴 시간이다. 그렇다면 앞으로도 계속 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 강제 딜레이를 넣어줘야 하는 걸까? 당연히 아니다.&lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서는 이런 문제가 발생할 줄 알고 미리 &lt;code class=&quot;language-text&quot;&gt;router.isReady()&lt;/code&gt;라는 비동기 함수를 만들어 놓았다.&lt;a href=&quot;https://router.vuejs.org/guide/migration/#replaced-onready-with-isready&quot;&gt;공식문서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;문제를 해결한 코드를 먼저 보자.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      await router.isReady() // Added!
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;)
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;)

      console.log(homeEl) // found
      console.log(navEl) // found
    })
  },
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;코드는 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 찾기 전에 &lt;code class=&quot;language-text&quot;&gt;await router.isReady()&lt;/code&gt; 딱 한 줄만 추가했다.&lt;/p&gt;
&lt;p&gt;이 함수는 쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부의 파일들이 DOM으로 mount 될 때 까지 기다려주는 역할이다. 모두 mount가 완료되었다면 resolve 해줌으로써 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 접근할 수 있게 된다.&lt;/p&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-router-isready-tlqd83?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-router-isReady&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[vue-chart에서 비동기 통신 후 화면에 반영하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 문제상황 vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue…]]></description><link>https://juheon.dev/vue/230627-vue-async-data/</link><guid isPermaLink="false">https://juheon.dev/vue/230627-vue-async-data/</guid><pubDate>Tue, 27 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/221&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;문제상황&lt;/h2&gt;
&lt;p&gt;vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue 기반으로 래핑해놓은 &lt;a href=&quot;https://vue-chart-3.netlify.app/&quot;&gt;vue-chart-3&lt;/a&gt;를 활용하려고 한다. 그래서 공식문서 &lt;a href=&quot;https://codesandbox.io/s/demo-vue-chart-3-ugynm?from-embed=&amp;#x26;file=/src/App.vue&quot;&gt;데모 페이지&lt;/a&gt;에 나와있는 대로 따라하려고 하니 문제가 하나 생겼다.&lt;/p&gt;
&lt;p&gt;내가 화면에 보여줄 데이터는 서버와 비동기 통신을 통해서 받아온 다음에 그려야 한다. 그런데 데모 소스코드 상에서는 데이터가 아래와 같이 그냥 하드코딩 되어 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    // &amp;lt;template&amp;gt;
    &amp;lt;DoughnutChart :chartData=&amp;quot;testData&amp;quot; /&amp;gt;
    ...

    // &amp;lt;script&amp;gt;
    const dataValues = ref([30, 40, 60, 70, 5]);
    const dataLabels = ref([&amp;quot;Paris&amp;quot;, &amp;quot;Nîmes&amp;quot;, &amp;quot;Toulon&amp;quot;, &amp;quot;Perpignan&amp;quot;, &amp;quot;Autre&amp;quot;]);
    const testData =  {
      labels: dataLabels.value,
      datasets: [
        {
          data: dataValues.value,
        },
      ],
    };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제 chart.js를 활용하는 사례에서는 데이터를 하드코딩해서 넣는 경우보단, 비동기로 넣는 경우가 더 일반적이다. 하지만 chart.js는 차트를 그리는 데 필요한 데이터를 받으면 곧바로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&gt;&lt;/code&gt;로 그려버리기 때문에, 그 이후에는 비동기로 데이터가 도착한다고 한들 차트가 변하지 않는다는 문제가 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 아래 코드와 같이 비동기 통신을 가장한 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;함수가 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;에서 실행된다 하더라도 차트는 그려지지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const dataValues = ref([])
const dataLabels = ref([])

onMounted(() =&amp;gt; {
  fetchData().then(res =&amp;gt; {
    dataValues.value = res.map(item =&amp;gt; item.data)
    dataLabels.value = res.map(item =&amp;gt; item.label)
  })
})

const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

const fetchData = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve([
        { data: 10, label: &amp;quot;a&amp;quot; },
        { data: 30, label: &amp;quot;b&amp;quot; },
        { data: 15, label: &amp;quot;c&amp;quot; },
        { data: 5, label: &amp;quot;d&amp;quot; },
        { data: 20, label: &amp;quot;e&amp;quot; },
      ])
    }, 1000)
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이를 해결하기 위해서는 차트의 props에 해당하는 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 주입시켜야 한다. 그러면 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;에서 1초 뒤에 값을 받아오고 나서 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;도 받아온 값으로 업데이트된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 부여하려면 &lt;code class=&quot;language-text&quot;&gt;computed&lt;/code&gt; 를 사용하여 감싸주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

// After
const testData = computed(() =&amp;gt; {
  return {
    labels: dataLabels.value,
    datasets: [
      {
        data: dataValues.value,
      },
    ],
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-chart-3nbvlh?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-chart&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Vue 에서 스크롤 위치 저장]]></title><description><![CDATA[2023-03-09 에 작성된 원문을 수정한 버전입니다 SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.…]]></description><link>https://juheon.dev/vue/230626-save-scroll/</link><guid isPermaLink="false">https://juheon.dev/vue/230626-save-scroll/</guid><pubDate>Mon, 26 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/220&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.&lt;/p&gt;
&lt;h2&gt;1. vue-router의 savedPosition 활용&lt;/h2&gt;
&lt;p&gt;vue-router의 &lt;code class=&quot;language-text&quot;&gt;createRouter()&lt;/code&gt;함수의 인자로 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수를 넣을 수 있다.&lt;/p&gt;
&lt;p&gt;이 함수에서 return 해주는 값에 따라서 페이지를 이동할 때마다 해당 값만큼 스크롤이 이동하게 된다. (쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;window.scrollTo&lt;/code&gt; 함수가 페이지 이동할 때마다 호출된다고 생각하면 된다.)&lt;br&gt;
예를 들어 아래 코드와 같이 &lt;code class=&quot;language-text&quot;&gt;{top : 100}&lt;/code&gt;을 리턴하다면 매 페이지 이동 시 수직 스크롤이 100px 내려져 있는 상태가 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior() {
    return { top: 100 }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;그렇다면 스크롤 위치를 저장하고 해당 위치로 돌아가려면 어떻게 해야할까?&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수는 아래와 같이 인자로 &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;savedPosistion&lt;/code&gt; 이렇게 3개를 받는다. &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;는 다음으로 이동할 페이지의 정보, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;은 이전에 어느 페이지로부터 왔는지에 대한 정보이다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;에 우리가 원하는 정보가 들어있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,

  scrollBehavior(to, from, savedPosition) {
    // 기존 위치 존재하면 그 위치 반환
    if (savedPosition) {
      return savedPosition
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
영상으로 이 값의 정체를 직접 확인해보자.
&lt;br /&gt;
&lt;br /&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/save-scroll/save-scroll-1.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;을 찍어보면 그 정체는 &lt;code class=&quot;language-text&quot;&gt;{top: number,left : number}&lt;/code&gt;형태라는 걸 알 수 있다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt; 값은 사용자가 &lt;strong&gt;뒤로가기/앞으로가기&lt;/strong&gt; 를 누를 때만 값이 활성화되고 vue-router를 활용하여 페이지 이동할 때는 값이 null값으로 반환되어서 위치를 저장할 수 없다. 만약 뒤로가기/앞으로가기 누를 때 뿐만 아니라 모든 경우에 대해서 스크롤 위치를 저장하기 위해서는 아래 2번 방법을 사용해야한다.&lt;/p&gt;
&lt;h2&gt;2. Web Storage(sessionStorage) 활용&lt;/h2&gt;
&lt;p&gt;두 번째 방법은 Web Storage를 활용하여 스크롤 위치를 동적으로 기억해 놓는 것이다. Web Storage는 크게 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;가 있는데 차이는 브라우저를 닫았을 때 데이터가 날리느냐 마냐의 차이이다. 보통 웹사이트의 특정 기간동안 &apos;로그인상태 유지&apos; 기능이 활성화한다면 브라우저가 꺼져도 유지되야 하므로 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;에 저장하는게 적합하다. 스크롤 위치 정보의 경우 브라우저를 껐다가 다시 실행했을 경우에는 초기화 시키는게 적합하므로 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 저장하기로 했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;페이지를 이동할 때마다 현재 페이지의 스크롤 위치를 저장해두어야 한다.
따라서 vue-router의 &lt;code class=&quot;language-text&quot;&gt;beforeEach()&lt;/code&gt;함수에서 떠나는 페이지(from)의 스크롤 위치인 &lt;code class=&quot;language-text&quot;&gt;window.scrollY&lt;/code&gt; 값을 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 key-value 형태로 저장한다. key값은 현재 페이지의 이름, value값은 스크롤 위치 값이다.&lt;/p&gt;
&lt;p&gt;이때 Web Storage에는 string형태의 데이터만 저장할 수 있으므로 저장할 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.stringify()&lt;/code&gt;로, 값을 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.parse()&lt;/code&gt;함수를 거쳐야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.beforeEach((_, from) =&amp;gt; {
  const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))

  const key = from.name
  if (key) {
    const scrollObj = { [key]: window.scrollY }
    window.sessionStorage.setItem(
      &amp;quot;scrollInfo&amp;quot;,
      JSON.stringify({ ...prevInfo, ...scrollObj })
    )
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 페이지에 진입하면 &lt;code class=&quot;language-text&quot;&gt;scrollInfo&lt;/code&gt;에서 이전에 저장되어 있는 스크롤 위치가 있는지 확인한 후, 있다면 그 위치로 이동시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to) {
    const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))
    if (!prevInfo) return
    const savedPosition = prevInfo[to.name] || 0

    return { top: savedPosition }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;를 찍어보면 다음과 아래와 같이 나온다.&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/hjhj97/blog.gatsby/main/content/blog/vue/images/save-scroll/save-scroll-2.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;에 저장된 value값을 받아서 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수의 top값으로 리턴해주게 되면 이전에 저장되었던 스크롤 위치로 복귀할 수 있게 되는 원리이다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;(&lt;a href=&quot;https://in0407.tistory.com/11&quot;&gt;https://in0407.tistory.com/11&lt;/a&gt;)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로젝트 회고]]></title><description><![CDATA[2023-02-18에 작성된 원문을 수정한 버전입니다 1. 프론트는 항상 맨 먼저 쳐맞는다. '어 이거 안되는데요? 프론트에서 확인 좀 해주세요' 이런 말을 프로젝트하면서 일주일에 1…]]></description><link>https://juheon.dev/essay/230625-project-review/</link><guid isPermaLink="false">https://juheon.dev/essay/230625-project-review/</guid><pubDate>Sun, 25 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-02-18에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/219&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1. 프론트는 항상 맨 먼저 쳐맞는다.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&apos;어 이거 안되는데요? 프론트에서 확인 좀 해주세요&apos;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 말을 프로젝트하면서 일주일에 10번도 넘게 들었다. 에러의 원인이 차라리 내(프론트) 문제라면 오히려 낫다. 하지만 백엔드 문제, 혹은 네이티브 문제인 경우도 있다. 하지만 사용자에게 가장 앞단에 보이는 부분은 결국 프론트이다. 일단 누구의 문제이든간에 내가 먼저 버그 issue를 접수받고나서 어느 파트의 문제인지 파악한 다음, 다시 그 파트의 개발자에게 해당 이슈를 토스해야 하는 입장이다.&lt;/p&gt;
&lt;p&gt;프론트 개발자 입장에서는 좀 억울하지만 어쩔 수 없는 숙명이다. 사용자는 백엔드가 어떻건, 네이티브가 어떻건은 신경쓰지 않는다. 지금 당장 자신에게 보이는 화면이 에러로 나온다면 일단 프론트 문제처럼 비춰질 수밖에 없다.그래서 나는 이 상황에 대해 &apos;제 잘못이 아닌데요&apos;라고 책임회피를 하려기보다는 그냥 침착하게 &apos;파악해보고 알려드리겠습니다&apos; 라고 대응하는게 더 현명한 방법이라고 결론내렸다.&lt;/p&gt;
&lt;h3&gt;2. 에러처리(fallback)가 성가시지만 정말 중요하다.&lt;/h3&gt;
&lt;p&gt;백엔드 API에서 어떤 데이터를 받아온다고 하자.&lt;br&gt;
백엔드에서 보내주는 형식은 &lt;code class=&quot;language-text&quot;&gt;res.data.result.list&lt;/code&gt; 라는 구조안에 내가 원하는 데이터가 들어있다. 총 4겹으로 감싸져 있는 구조이다. 여기서 중요한 점은, 한 겹을 벗길 때마다 반드시 유효성 검증을 해줘야 한다는 점이다. 하지만 예전의 나같은 경우에는 단순무식하게&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;);
const myList = res.data.result.list;
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런 식으로 한 번에 꺼내오려고 했을 것이다. 하지만 위 코드는 서버가 100% 정상 작동할때만 보장되는 코드이다. 만약 서버가 잠시 에러가 났다거나, 아니면 데이터 구조가 바뀌게 되면 위 코드는 여지없이 에러를 내뿜고 말 것이다.&lt;/p&gt;
&lt;p&gt;예전의 나라면 &lt;code class=&quot;language-text&quot;&gt;그런-상황이-프론트개발자-잘못은-아닌거-같은데요&lt;/code&gt;라고 했겠지만, 지금은 생각이 바뀌었다. 설령 백엔드 단에서 에러가 발생했다 할지라도 그 문제 상황이 프론트(사용자가 보는 화면)단까지 역류해서는 안된다. 최소한 사용자가 보기에 에러가 발생해서 아무것도 없는 흰 화면만 보여주기보다는, &apos;에러가 발생했습니다&apos;라는 텍스트 한 줄이라도 적혀있는 페이지로 리다이렉트 시켜주는게 프론트 개발자가 해야하는 최소한의 예의이다.&lt;/p&gt;
&lt;p&gt;가장 훌륭한 방법은 백엔드에서 에러가 발생하여 데이터가 예상과는 다르게 오더라도 이를 잘 핸들링 할 수 있어야 한다. 다시 위의 예시를 들자면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// After
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;).catch(fail=&amp;gt;handleFail())
if (res) {
  const myList = res?.data?.result?.list
  if(myList){
    ...
  } else{
    handleFail();
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 데이터의 유효성 검증을 반드시 거쳐야 한다. 처음에는 이런 식의 코딩이 비효율적이고 미관상으로도 보기에 좋지 않다고 생각했었는데 ,이건 아무래도 내가 이전까지 코딩을 하던 습관이 주로 Problem solving에 머물러 있었기 때문이라고 생각한다.&lt;/p&gt;
&lt;p&gt;PS에서의 코딩을 할 때는 서버랑 통신하지 않고 데이터의 구조를 내가 직접 지정하다보니, 데이터의 유효성을 굳이 검증할 필요를 느끼지 못했다. 하지만 웹개발에서 프론트-백엔드가 맞물리는 작업에서는 반대쪽 진영에서 데이터를 어떻게 보낼 것인지에 대해서는 항상 보수적이고 안정적인 방향으로 코드를 짜야한다.&lt;/p&gt;
&lt;h3&gt;3. 사용자가 시도할 만한 모든 행동을 테스트하라.&lt;/h3&gt;
&lt;p&gt;휴대폰 본인인증을 위한 기능을 추가한다고 생각해보자.&lt;br&gt;
사용자가 문자를 받으면 번호를 입력하고 인증 버튼을 눌러주면 참 좋겠지만, 안타깝게도 사용자는 내가 의도한대로만 행동하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;첫 번째, 사용자가 전화번호를 잘못 입력했을 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황은 그나마 낫다. 문자를 보내기 전에 서버에서 유효하지 않은 정보라고 에러를 보내주기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;두 번째, 인증번호를 잘못 입력할 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황도 충분히 일어날 수 있으며 서버에서도 에러를 띄워주기 때문에 처리하기엔 어렵지 않다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 세 번째, 사용자가 &apos;인증 요청&apos;버튼을 광클한다.&lt;/strong&gt;&lt;br&gt;
휴대폰 인증의 경우, 각 요청마다 고유한 인증 ID값이 부여되기 때문에 3번 클릭을 하면 3개의 별개의 인증 ID가 부여되고 3개의 문자가 전송되며 당연히 사용자에게 전송되는 인증번호도 다르다. 그리고 인증과정은 대개 가장 마지막 요청을 기준으로만 유효하기 때문에 사용자는 세 번째 인증번호를 입력해야 하는 상황이다.&lt;/p&gt;
&lt;p&gt;여기서 성질 급한 사용자는 세 번째 문자가 오기 전에 첫 번째 인증번호 문자를 입력하고 확인 버튼을 누를 것이다. 인증 결과는 당연히 실패. 당황한 사용자는 세 번째 문자를 기다리는게 아닌, &apos;인증 재요청&apos;버튼을 누를 것이다. 네 번째 문자 요청인 셈이다. 그 순간 사용자에게 두 번째, 혹은 세 번째 인증문자가 도착하고 사용자는 또 다시 인증에 실패한다. 그리고 사용자는 영문도 모르고 이 웹페이지를 만든 개발자(아마 나)를 욕하고 있을 것이다.&lt;/p&gt;
&lt;p&gt;누구의 잘못일까? 버튼을 세번 광클한 사용자인가, 그런 행동도 예측 못한 개발자인가. 프로젝트가 진행될수록 느끼는 점은 개발자가 더 신경써야 한다는 것이다. 사용자가 왜 그런 터무니없는 행동을 할까에 대해 원망을 하기 보다, 내가 한발 먼저 터무니없는 행동을 막아야 한다. 이 문제의 경우에는 &lt;code class=&quot;language-text&quot;&gt;debounce&lt;/code&gt;함수나 &lt;code class=&quot;language-text&quot;&gt;throttle&lt;/code&gt;함수를 이용하여 단 하나의 요청만 전송되도록 처리되도록 해야할 것이다.&lt;/p&gt;
&lt;p&gt;이 외에도 시간제한(3분)을 지나서 확인 버튼을 누른다거나 하는 등 내가 의도한 베스트 시나리오에서 벗어나는 행동을 얼마든지 있을 수 있다. 단순 베스트 시나리오만 처리한다면 코드를 단 30줄만 작성하면 된다. 하지만 위에서 언급한 예외적인 사용자의 행동까지 처리하기 위해서는 거의 300줄을 써야 한다. 예전에는 이런 에러 상황 처리로 인해 코드 길이가 길어지는게 현타가 오기도 했는데, 이제는 받아들이기로 했다. 그것이...프론트의 숙명이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추후에 나는 이 일을 계기로 TDD,테스트코드의 중요성을 깨닫게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4. 안드로이드와 iOS를 동시에 고려해야한다&lt;/h3&gt;
&lt;p&gt;웹뷰 기반의 하이브리드 앱을 개발하면 프론트 개발자는 반드시 안드로이드(AOS)와 iOS를 동시에 고려해야한다. 대부분의 기능은 하나의 코드로도 양쪽에서 잘 작동하지만, 일부 기능들은 AOS에서만 작동한다거나, 반대로 iOS에서만 작동하는 기능들도 있다.&lt;/p&gt;
&lt;p&gt;이런 경우에는 어쩔 수 없이 if문을 이용하여 사용자의 기기를 식별한 다음 분기처리 해주어야 한다. 나는 아이폰을 사용하기 때문에 앱을 만들면서 iOS에서는 정상 작동을 잘 확인하였으나 안드로이드(사실상 갤럭시)에서는 동작이 다르거나 아예 실행되지 않는 케이스도 있었다.&lt;/p&gt;
&lt;p&gt;예를 들어 Javascript web share API의 경우, ios에서는 &lt;code class=&quot;language-text&quot;&gt;window.navigator.share()&lt;/code&gt; 함수만 호출하면 되는 반면에, AOS에서는 별도의 네이티브 함수를 호출해야만 공유하기 기능을 활용할 수 있다. 게다가 javascript의 문제뿐만이 아니라 css에서도 레이아웃이 다르게 보이는 경우가 있다.&lt;br&gt;
(예를 들어 safari에서는 border-radius가 들어간 element에는 outline 속성이 먹지 않는 문제)&lt;/p&gt;
&lt;p&gt;그래서 개발할 때는 항상 chrome창과 safari창을 동시에 켜놓고 작업하면서 두 브라우저에서 모두 잘 나타는지 확인해야했다.&lt;/p&gt;
&lt;h3&gt;5. 데이터 가공은 가급적 백엔드에 맡겨라&lt;/h3&gt;
&lt;p&gt;이 문제의 원인 역시 PS에서의 습관이 묻어있었기 때문이다.&lt;/p&gt;
&lt;p&gt;PS에서는 문제를 풀 때 데이터를 정렬하는 일은 정말 비일비재하므로 웹개발에서 나도 모르게 sort()함수를 하고 있는 나 자신을 발견한다. 하지만 기본적인 시간순 정렬이나, 기간조회 같은 기능들은 프론트가 직접 필터링하기보다는 백엔드 API를 통해서 값을 받아오는게 낫다. 나는 백엔드 통신을 최소화해야만 극한의 최적화를 이룰 수 있다는 강박이 있었는데, 오히려 스크립트가 연산하는 작업이 더 큰 오버헤드 일 수도 있다.&lt;/p&gt;
&lt;p&gt;어차피 백엔드는 db에서 값을 꺼내오는 과정이 포함되어있고, 백엔드 자체적으로 가공을 거친 후 보내준다 해도 그렇게 큰 시간 손실은 아니다. 상황에 따라서 데이터 가공을 프론트가 해야할 지 백엔드가 해야할 지를 잘 정해야 한다.&lt;/p&gt;
&lt;h3&gt;6. 어디까지 나의 &apos;주관적 판단&apos;을 개입시켜야 하는가&lt;/h3&gt;
&lt;p&gt;내가 프론트 개발을 할 때는 보통 와이어프레임 형태로 되어있는 기획서와 디자이너가 퍼블리싱한 문서를 기반으로 작업한다. 이 둘을 참고해가며 개발하다보면 모호한 부분이 생길 때가 있다. 이를테면 프론트단에서 구현할 수 없는 기능이거나, 왜 필요한 지 알 수 없는 기능이거나 할 때가 있다.&lt;/p&gt;
&lt;p&gt;이런 상황에서 어떻게 대처할 지 난처해진다. 잘못된 것 같아도 기획서를 그대로 따라갈 것인지, 아니면 나의 주관을 개입시켜서 기획서와 다르게 개발을 해야할지 말이다. 나는 전자와 후자의 방법 모두를 시행해보았는데 결론적으로 두 번 모두 태클을 받았다.&lt;/p&gt;
&lt;p&gt;전자의 방법을 따를 경우,
&lt;code class=&quot;language-text&quot;&gt;&apos;기획서가 좀 잘못되더라도 개발하다가 이상하다 느꼈으면 융통성 있게 수정해주세요&apos;&lt;/code&gt;
라는 말을 듣고,&lt;br&gt;
후자의 방법을 따를 경우
&lt;code class=&quot;language-text&quot;&gt;&apos;그냥 기획서에 나와 있는 그대로만 개발해주세요&apos;&lt;/code&gt;
라는 말을 듣는다. 결국에는 정답이 없다. 나의 주관을 정말 &lt;strong&gt;&apos;적절하게&apos;&lt;/strong&gt; 개입시켜야 한다.&lt;/p&gt;
&lt;h3&gt;7. 개발 자체보다, 사람과의 소통이 더 어렵다&lt;/h3&gt;
&lt;p&gt;어쩌면 가장 중요한 교훈이다. 개발은 그냥 하면 된다. 모르면 구글링으로 찾아보기도 하고 버그가 발생하면 될 때까지 부딪히다 보면 된다.&lt;/p&gt;
&lt;p&gt;하지만 사람과의 소통은 그렇지 않다. 검색을 해도 나오지도 않고 계속 부딪힐 수도 없는 문제이다. 똑같은 의도를 전달하더라도, 내가 사용하는 단어에 따라서 상대방의 대답이 달라지기도 한다.&lt;/p&gt;
&lt;p&gt;나는 코드만 잘 짜기만 하면 사람들간의 트러블은 전혀 없을 줄 알았다. 하지만 이번 프로젝트를 통해서 깨닫게 된 점은 결국 프로그램을 만드는 것도 사람, 이용하는 것도 사람이다. 내가 아무리 환상적이게 작동하는 코드를 잘 짜놓았다고 한들 상대방이 납득하지 못한다면 아무 소용없는 일이다.&lt;/p&gt;
&lt;p&gt;내가 중점적으로 신경쓴 점은 &apos;나는 어떤 문제상황을 이렇게 받아 들였고, 이런 방식으로 해결하려고 했다.&apos;를 주장하고,&lt;br&gt;
상대방에게 업무를 요청할 때는 &apos;현재 프론트에 이러이러한 문제가 있는데, 이 부분이 원인인 것 같다. 백엔드에서 다른 방식으로 개선해달라&apos; 방식의 의사소통으로 다듬어가고 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CSS,JS를 이용한 룰렛 구현]]></title><description><![CDATA[2022-11-1…]]></description><link>https://juheon.dev/vue/230624-vue-roulette/</link><guid isPermaLink="false">https://juheon.dev/vue/230624-vue-roulette/</guid><pubDate>Sat, 24 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2022-11-12 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/214&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;룰렛 이벤트&lt;/h2&gt;
&lt;p&gt;다들 온라인이나 오프라인에서 룰렛(회전판)을 돌려서 나온 상품을 추첨받는 경험 한 번씩 있을 것이다. 현실에서의 룰렛은 공평한 물리법칙에 내 운명을 맡기면 되지만, 웹페이지(프론트엔드)상에서 구현할 때는 룰렛을 어떻게 돌아가게 만들고 어떤 영역을 가리키도록 해야할까? 마침 진행 중인 프로젝트에서 룰렛을 구현해야 했는데 구글링이나 오픈소스에는 내가 원하는 기능이 없어서 직접 구현하게 되었다.&lt;/p&gt;
&lt;h4&gt;요구조건&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;사용자가 버튼을 누르면 백엔드 API가 호출되고 리턴값으로 당첨영역을 받는다. 이 영역의 위치에 따라 회전 각도를 조절해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현실에서 룰렛이 회전하는 것처럼, 처음에는 천천히 돌다가 점점 가속도가 붙어서 빨라지고 마지막에는 느려지다 멈춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;구현 방식&lt;/h4&gt;
&lt;p&gt;가장 쉽게 생각해볼 수 있는 방법은 css animation을 활용하여 rotate시키는 방법이다.
아래와 같이 &lt;code class=&quot;language-text&quot;&gt;spin&lt;/code&gt;이라는 keyframs를 정의하고 &lt;code class=&quot;language-text&quot;&gt;rotate(360deg)&lt;/code&gt;를 부여하면 한 element를 한바퀴 돌릴 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;strong&gt;요구조건 1&lt;/strong&gt;에서 언급했다시피 당첨영역, 즉 회전 각도는 고정된 값이 아니라 서버에서 리턴받는 값에 따라서 동적으로 변해야 한다. 그래서 나는 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 css keyframes에 접근하여 rotate각도를 직접 수정할 수 있는지를 찾아보았다. 예를 들어 DOM element의 &lt;code class=&quot;language-text&quot;&gt;backgroundColor&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;fontSize&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;querySelector()&lt;/code&gt;함수를 이용해 접근할 수 있는 것처럼 animation도 그런 작업이 가능한 지 궁금했다.&lt;/p&gt;
&lt;p&gt;결론부터 얘기하자면, 가능은 하지만 방법이 너무 복잡했다.&lt;a href=&quot;https://stackoverflow.com/questions/59573722/how-can-i-set-a-css-keyframes-in-javascript&quot;&gt;(링크)&lt;/a&gt;&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;insertRule()&lt;/code&gt;함수를 이용해서 넣는 방식이었는데 keyframe부분을 직접 문자열로 하드코딩해야하기 때문에 너무 억지인 것 같아서 다른 방법을 찾아보기로 하였다.&lt;/p&gt;
&lt;h4&gt;css var()를 활용한 방식&lt;/h4&gt;
&lt;p&gt;다른 방법으로 생각해낸 건 아래와 같이 css의 var()를 활용해서 :root에서 선언해놓은 변수 값을 keyframes에서 갖다 쓰는 방식이다. root 영역의 값은 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 &lt;code class=&quot;language-text&quot;&gt;setProperty()&lt;/code&gt;함수를 활용해서 조작할 수 있기 때문에 이 방식이 더 낫다고 판단하였다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/*roulette.css*/
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(var(--roulette-angle));
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;룰렛의 파라미터&lt;/h4&gt;
&lt;p&gt;룰렛을 돌리기 전에 결정되어야 할 파라미터가 몇 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;룰렛을 최소 몇 바퀴 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛을 몇 초 동안 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛 안에 채워져 있는 컨텐츠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 3가지가 채워지고나면 룰렛을 돌릴 수 있게 된다.&lt;/p&gt;
&lt;p&gt;원리는 간단하다. 룰렛의 중심각이 360도이다. 따라서 &lt;code class=&quot;language-text&quot;&gt;360/(영역의 개수)&lt;/code&gt; 를 계산하면 룰렛의 각 영역당 중심각의 크기&lt;code class=&quot;language-text&quot;&gt;(=degPerSection)&lt;/code&gt;를 구할 수 있다.&lt;br&gt;
그리고 당첨된 영역&lt;code class=&quot;language-text&quot;&gt;(=pick)&lt;/code&gt;이 (반시계방향 기준)몇 번째인지 구하여 &lt;code class=&quot;language-text&quot;&gt;degPerSection * pick&lt;/code&gt; 값이 룰렛을 회전시켜야하는 각도 값&lt;code class=&quot;language-text&quot;&gt;(=rouletteAngle)&lt;/code&gt;이 된다.
이 값을 root에 &lt;code class=&quot;language-text&quot;&gt;--roulette-angle&lt;/code&gt;로 저장시키면 &lt;code class=&quot;language-text&quot;&gt;var()&lt;/code&gt;함수를 이용하여 keyframes에서도 이 값을 가져다 쓸 수 있는 방식이다.&lt;/p&gt;
&lt;p&gt;그래서 &lt;code class=&quot;language-text&quot;&gt;startRoulette()&lt;/code&gt;함수를 실행시키면 &lt;code class=&quot;language-text&quot;&gt;rouletteAngle&lt;/code&gt;값이 정해지고 이 값은 다시 :root의 &lt;code class=&quot;language-text&quot;&gt;roulette-angle&lt;/code&gt;으로 채워져서 spin animation이 작동하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const useRoulette = () =&amp;gt; {
  const POINT_ARRAY = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;yellow&amp;quot;]
  // 룰렛의 내용, 12시 방향부터 반시계방향
  const MIN_ROTATION = 3
  // 룰렛을 최소 몇 바퀴 돌릴 것인지
  const ROTATION_SECOND = 2
  // 몇 초동안 돌릴 것인지

  const numberOfSection = POINT_ARRAY.length
  // 룰렛에 적힌 영역의 개수
  const degPerSection = 360 / numberOfSection
  // 하나의 섹션당 각도가 몇 도인지 계산함.
  let pickedSection
  // 당첨된 영역

  const setRouletteProperty = () =&amp;gt; {
    const pick = Math.floor(Math.random() * numberOfSection)
    // [0, section - 1]범위에 랜덤한 인덱스를 뽑음, 서버에서 영역을 정해준다면 필요없음
    pickedSection = POINT_ARRAY[pick]
    // 당첨된 영역 값 대입
    const rouletteAngle = 360 * MIN_ROTATION + degPerSection * pick
    // 최소 MIN_ROTATION만큼은 돌고난 후에, pick 영역을 가르키도록 함

    document.documentElement.style.setProperty(
      &amp;quot;--roulette-angle&amp;quot;,
      rouletteAngle + &amp;quot;deg&amp;quot;
    )
    //css의 root에 선언해놓은 변수에 값 할당함.

    const rouletteEl = document.querySelector(&amp;quot;.roulette_content&amp;quot;)
    rouletteEl.style.animationDuration = `${ROTATION_SECOND * 1000}ms`
    // 애니메이션(룰렛회전) 지속시간 적용
  }

  const startRoulette = () =&amp;gt; {
    setRouletteProperty()

    const toId = setTimeout(() =&amp;gt; {
      alert(pickedSection)
      clearTimeout(toId)
    }, ROTATION_SECOND * 1000)
  }
  return {
    startRoulette,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(var(--roulette-angle));
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue3-roulette-cu4617?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;Vue3-roulette&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[블로그 꾸미기 일지]]></title><description><![CDATA[블로그 템플릿 블로그를 이제 막 개설해서인지 아직은  프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium…]]></description><link>https://juheon.dev/etc/230622-blog-decoration/</link><guid isPermaLink="false">https://juheon.dev/etc/230622-blog-decoration/</guid><pubDate>Thu, 22 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 템플릿&lt;/h2&gt;
&lt;p&gt;블로그를 이제 막 개설해서인지 아직은 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt; 프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium 같은 플랫폼보다 커스텀할 수 있는 폭이 넓은 gatsby를 기술 블로그로 선택한 이상 꾸미기는 선택이 아닌 거의 필수라고 생각한다.&lt;/p&gt;
&lt;p&gt;첫 글에서도 언급했다시피 다른 개발자분들의 gatsby 블로그를 구경다니면서도 한 가지 의아했던 점 중 하나는, UI가 하나같이 매우 흡사하다는 점이었다. 상단에는 full-width의 top-fixed-header가 존재하고 바로 밑에는 자신의 프로필과 간단한 소개글, 그 밑에 포스팅이 나열되는 방식이었다. 이게 무슨 정해진 규칙같은 게 있는 건 지, 아니면 이런 형식으로 제공되는 템플릿이 있는 지는 모르겠는데 일단 나는 나만의 방식으로 꾸미기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(나중에 알게된 사실인데, &lt;a href=&quot;https://jbee.io&quot;&gt;Jbee&lt;/a&gt;님이 배포하시는 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt;가 있었다. 아마 내가 구경한 블로그의 상당수는 이를 fork한 것으로 보인다. 이 블로그도 fork해서 만드는 걸 고려해보긴 했지만, 일단은 제로베이스부터 만들고 싶었다. 대신에 각종 기능을 어떻게 구현했는지에 대한 코드는 많이 참고하고 있다. Jbee님 감사합니다.)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;어떻게 꾸밀까&lt;/h2&gt;
&lt;p&gt;나는 &lt;code class=&quot;language-text&quot;&gt;gatsby-starter-blog&lt;/code&gt;를 fork해서 갖고왔다. 처음 &lt;code class=&quot;language-text&quot;&gt;npm run develop&lt;/code&gt; 커맨드로 실행하게 되면 뿌듯함과 함께 어떻게 꾸며야할까에 대한 막막함이 몰려온다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/0c1ff/blog-history-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 77.84810126582278%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABjklEQVR42q2TzXLaMBSF8/6vwppFugF2rGEDoZ4mzjSAsfUvG//xdaTgmZCWMqQ9M3dkW9Lne6R7HwBOp1MY0FqzWq3YbDakacr3JCFJEtbrNcvlMs4P64c9n/XwEbjf7/j2+Mh4PGY2mzGfz5lMJkynU0ajEYvFIq7r+55rugDuDoqfu4K2bdHGYaynbhqatqVtO7wvsdZhjI1xE/iavpBsnnDWkhcC4yuauqGOUccfdV0X4WG8ChzUn6Bqe9yxwx1buv7EvXrP8Pyyk47Fc8bqTfG01RH6JeCgY1WipcA7i7MGpRRCSAohEVLFY5Dy/ZtS+o+XcwHU1pNuD7zuc9JtThYASiGVjqDwrLVBSIlz/rblzFSst4pUeH7kDlM1fJy/23LpPXmWoaRAKxUt53lxti0oChHthyzLsroNtL7iLStiFEKhjUHpcygdI9gPtXmtuC8s57aKN5zsLWXd3m33twzDQWfZIRbw5579W/9eBYbqPx7rc7t19F8t7EEhs5Cl857ClJR192/A/6FfblHhRO9cVYoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;첫 상태&quot;
        title=&quot;&quot;
        src=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/f058b/blog-history-1.png&quot;
        srcset=&quot;/static/fe18827134b205b6948d96e3ca7f53b5/c26ae/blog-history-1.png 158w,
/static/fe18827134b205b6948d96e3ca7f53b5/6bdcf/blog-history-1.png 315w,
/static/fe18827134b205b6948d96e3ca7f53b5/f058b/blog-history-1.png 630w,
/static/fe18827134b205b6948d96e3ca7f53b5/40601/blog-history-1.png 945w,
/static/fe18827134b205b6948d96e3ca7f53b5/78612/blog-history-1.png 1260w,
/static/fe18827134b205b6948d96e3ca7f53b5/0c1ff/blog-history-1.png 2192w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;em&gt;
처음으로 블로그를 실행하면 마주하게 되는 화면.사실상 허허벌판 상태이다.
&lt;/em&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;p&gt;일단 해야할 일을 정해보자.&lt;/p&gt;
&lt;h4&gt;1. primary-color 정하기&lt;/h4&gt;
&lt;p&gt;UI의 통일성을 위해서는 꼭 필요하다. 내가 평소에 좋아하는 색인 &lt;code class=&quot;language-text&quot;&gt;DodgerBlue&lt;/code&gt; 계열의 색을 rgb-picker로 찍어왔다.&lt;/p&gt;
&lt;h4&gt;2. 내 소개글(profile) 작성하기&lt;/h4&gt;
&lt;p&gt;이건 간단하다. 한두줄 정도의 소개글과 프로필사진만 업로드하면 된다.&lt;/p&gt;
&lt;h4&gt;3. 헤더 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;다른 사람들의 블로그의 헤더가 모두 top-fixed에 full-width인 걸 보아하니, 나도 왠지 그래야만 할 것 같은 기분이 들었다. background-color는 primary-color로 적용하니 꽤 볼만해졌다. 그렇지만 점점 갈수록 다른 블로그들이랑 너무 비슷해져가는데...? 이럴거면 그냥 처음부터 &lt;code class=&quot;language-text&quot;&gt;gatsby-start-bee&lt;/code&gt;를 받아서 쓸 걸 그랬나...&lt;/p&gt;
&lt;p&gt;여기까지 적용해본 결과, 아래와 같이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/104decd28c6c747339e89b9fc13397e9/26781/blog-history-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.75949367088608%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABH0lEQVR42q1STUsDMRDtnxcRjyqK4LHQav+JePDkUZC6WtvtZpJMPjd5sllbKCzYVgceA0Py5s2bGZ3ePOHs9hkn1484v3vB1X2Ni8myx7TH5XS1N0b45xjllJFzRkoJKeVSfK0Ibx8NqvcK83mFtm23H/Im52HsKOyIuxiPJ5g9zCBI4XPxBSEIgiSaRoDZwBgL5/2wwqGiswzDDOdbhBjhQ0AIEd77ojblvG3+K2H3jnQ3/pEeDhWV0jDGbG3YxRGEQkYs6ogVdSPnvyskqctCpGJo5rIIrX8yM6x1+3vYBRsPkgakDNhYWGvLZq1zMNYihHCYwrpxWK4D1tTChVSub+Nhf6899lfIGiQJSklIKSGICqRURaVzHjHGQcJvx8ag/VPYq0AAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;두 번째 상태&quot;
        title=&quot;&quot;
        src=&quot;/static/104decd28c6c747339e89b9fc13397e9/f058b/blog-history-2.png&quot;
        srcset=&quot;/static/104decd28c6c747339e89b9fc13397e9/c26ae/blog-history-2.png 158w,
/static/104decd28c6c747339e89b9fc13397e9/6bdcf/blog-history-2.png 315w,
/static/104decd28c6c747339e89b9fc13397e9/f058b/blog-history-2.png 630w,
/static/104decd28c6c747339e89b9fc13397e9/40601/blog-history-2.png 945w,
/static/104decd28c6c747339e89b9fc13397e9/78612/blog-history-2.png 1260w,
/static/104decd28c6c747339e89b9fc13397e9/26781/blog-history-2.png 2664w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;참고 볼 만한 수준은 되었지만, 아직 이정도로는 부족하다.&lt;/p&gt;
&lt;h4&gt;4. 댓글 작성 기능&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;utterance&lt;/code&gt;를 활용하면 된다. 블로그 댓글을 위한 별도의 public 레포지토리를 만들고나서 연동을 하면 해당 레포지토리의 issue에 글이 올라가게 되고, 이를 댓글처럼 활용할 수 있는 방식이다.&lt;/p&gt;
&lt;h4&gt;5. 폰트 변경하기&lt;/h4&gt;
&lt;p&gt;기본으로 깔려있는 폰트는 별로 예쁘지가 않았다. 구글링으로 폰트 변경하는 법을 찾아보니, &lt;code class=&quot;language-text&quot;&gt;@fontsource&lt;/code&gt;에서 제공해주는 폰트를 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;기반으로 설치할 수 있다고 하더라. 기본 제공되는 한글 폰트는 가짓수가 그리 많지는 않지만 나는 가장 무난한 &lt;code class=&quot;language-text&quot;&gt;Noso Sans&lt;/code&gt;를 선택했다.&lt;/p&gt;
&lt;h4&gt;6. 코드블럭 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;코드블럭 역시 기본으로 제공되는 스타일이 마음에 들지 않았다. 구글링해보니 &lt;code class=&quot;language-text&quot;&gt;gatsby-remark-highlight-code&lt;/code&gt;라는 플러그인을 제공해주고 있더라. 이런 문제들을 미리 만나고 해결해주시고 블로그에 글을 남겨주신 모든 분들께 감사드린다.&lt;/p&gt;
&lt;h4&gt;7. 모바일 환경도 신경쓰기&lt;/h4&gt;
&lt;p&gt;PC 환경에서는 잘 보이는데, 모바일에서 확인해보니 스타일이 깨지는 부분이 많았다. 사실 기술블로그를 주로 읽는 독자들의 대다수는 PC로 접속할 것으로 예상은 되지만, 그렇다고 모바일을 소홀히 할 변명이 되지는 않는다. 당연히 모바일에서도 잘 보여야한다. 헤더의 z-index나 element들의 간격을 조정해서 해결하였다.&lt;/p&gt;
&lt;h4&gt;8. 나만의 독특함(?)은 뭐가 있을까&lt;/h4&gt;
&lt;p&gt;사실 여기까지만 진행해도 나름 그럴싸한 UI가 완성되었다. 그렇지만 뭔가 좀 아쉽다. 다른 블로그를 너무 열심히 참고하는 바람에 내 블로그만의 특색이 사라졌다고나 할까? 그래도 나름 뭔가 좀 hooking 한 무언가 있었으면 좋겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;음, 생각을 해보자... 나만의 무언가....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러다가 문득 나의 닉네임이 Neon 이니, 네온사인같은 효과를 적용해보면 좋겠다는 생각이 떠올랐다. 바로 &lt;code class=&quot;language-text&quot;&gt;neon sign effect in css&lt;/code&gt;로 검색해보니 아니나 다를까, 수많은 구현 방법이 나와있었다. 기본적으로 text-shadow를 활용해서 뒤에 어두운 배경을 갖다대면 네온사인처럼 주변을 밝히는 효과를 낼 수 있었다. 더 참신한 건 animation,keyframes을 이용해서 네온사인이 깜빡이는 효과까지 만들 수 있다!&lt;br&gt;
처음 이걸 본 순간 확 꽂혀서 바로 내 블로그에 도입해보고 싶다는 생각이 들었다. 어려운 테크닉이 들어간 방식도 아니어서 단번에 보고 따라할 수 있었다. 혹시나 코드가 궁금하신 분들은 &lt;code class=&quot;language-text&quot;&gt;header-effect.css&lt;/code&gt;를 참고하면 된다.&lt;br&gt;
대신에 깜빡이는 효과는 눈이 아프거나 정신 사납다고 느낄 수도 있으니 독자에게 비활성화할 수 있는 방법은 제공해야되겠다고 생각했다. 상태관리 라이브러리를 써야하나 고민했는데 그렇게 복잡할 필요는 없을 것 같다고 판단하여 그냥 localStorage단에서 boolean값을 저장하여 제어하는 방식을 선택했다.&lt;/p&gt;
&lt;h2&gt;앞으로 적용해 볼 기능들&lt;/h2&gt;
&lt;h4&gt;카테고리&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;gatsby-starter-bee&lt;/code&gt;에서는 기본으로 제공해주는 기능인데, 나는 직접 구현해야한다. 구현 원리는 슥 봤는데 어느정도는 이해하긴 했다. 카테고리 목록을 &lt;code class=&quot;language-text&quot;&gt;string[]&lt;/code&gt;형태의 constant로 미리 선언해놓고, &lt;code class=&quot;language-text&quot;&gt;content/blog/&lt;/code&gt;밑의 경로에 선언해둔 카테고리를 디렉토리로 만들어서 포스팅을 집어 넣는다. 그리고 &lt;code class=&quot;language-text&quot;&gt;useCategory&lt;/code&gt; hook을 호출해서 특정 카테고리 밑에 있는 포스팅들을 다 묶어주는 방식인 것 같다. 머리로는 이해했는데 구현은 한번 해봐야 할 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2023.06.23 적용&lt;/strong&gt;&lt;br&gt;
오늘 하루를 꼬박 투자해서 카테고리 기능을 구현해냈다. 위에 적은 예상 구현 방법은 반은 맞고 반은 틀렸다. 카테고리 리스트는 constant로 미리 선언해둘 필요 없이, 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;category&lt;/code&gt;라는 속성을 적어주기만 하면 된다. 그러면 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 모든 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;정보를 긁어와서 map형태로 만들고 &lt;code class=&quot;language-text&quot;&gt;unique&lt;/code&gt;함수를 거쳐서 유일하게 만들어주면 된다.&lt;br&gt;
여기까지는 &lt;em&gt;Jbee&lt;/em&gt; 님이 구현한 방식을 참고했는데, 나는 여기서 더 나아가 카테고리별 글의 &apos;개수&apos;까지 보여주고 싶었다. 기존 방식은 post의 카테고리를 &lt;code class=&quot;language-text&quot;&gt;map()&lt;/code&gt;함수로 뽑아낸 다음, &lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;uniq&lt;/code&gt;함수를 실행하기 때문에 글의 개수와 관련된 정보는 날라가버린다. 그래서 나는 글의 개수를 보존하기 위해 자료구조 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt;을 활용하여 key값은 카테고리 이름, value값은 해당 카테고리 글의 개수를 저장했다.&lt;/p&gt;
&lt;h4&gt;다크모드&lt;/h4&gt;
&lt;p&gt;카테고리 기능만큼 우선순위가 높은 기능은 아니라고 생각한다. 이 역시도 gatsby-theme과 관련된 플러그인이 있는 것 같던데, 나중에 적용할 마음이 생기면 찾아보려고 한다.&lt;/p&gt;
&lt;h4&gt;오픈그래프(검색최적화)&lt;/h4&gt;
&lt;p&gt;이 부분에 관해서는 나도 아직 모르는 부분이 많아서 차차 공부해가면서 적용해보려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 번째 글]]></title><description><![CDATA[블로그 이사 기존에 4년 반 동안 운영하던 티스토리 블로그에서 이곳 Gatsby 블로그로 이사하였다. 이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 '개발과 관련된' 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL…]]></description><link>https://juheon.dev/essay/230621-first-article/</link><guid isPermaLink="false">https://juheon.dev/essay/230621-first-article/</guid><pubDate>Wed, 21 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 이사&lt;/h2&gt;
&lt;p&gt;기존에 4년 반 동안 운영하던 &lt;a href=&quot;https://ps-hjhj97.tistory.com&quot;&gt;티스토리 블로그&lt;/a&gt;에서 이곳 Gatsby 블로그로 이사하였다.&lt;/p&gt;
&lt;p&gt;이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 &apos;개발과 관련된&apos; 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL에서부터 짐작되다시피, PS(Problem Solving)를 하면서 얻은 지식이나 문제 풀이 위주의 글들로 이루어져 있다. 처음 블로그를 개설할 당시만 하더라도 나는 아주 PS만 공부하고 있었으므로 추후에 개발 블로그로서 발전될 가능성을 염두에 두지 않았다.&lt;/p&gt;
&lt;p&gt;그러다 시간이 흘러 내가 취업전선에 뛰어들게 되면서 점점 PS보다는 개발 공부에 투자하는 비중이 더 많아졌다. 처음에는 개발 공부에서 얻은 지식들도 기존 티스토리 블로그에 포스팅할 예정이었으나, 그 당시에는 익숙치 않아서인지 개발 포스팅은 글을 어떻게 써야할 지 감이 잡히지 않았다.&lt;br&gt;
문제풀이 글의 경우에는 &apos;문제요약&apos; &gt; &apos;문제접근&apos; &gt; &apos;나의 생각&apos; &gt;&apos;코드구현&apos; 이라는 명확한 기승전결 포맷이 갖춰져 있음에 비해, 개발관련 글은 주제가 자유분방하다보니 이걸 어떻게 설명해야할지 도무지 갈피를 못잡았던 것 같다. 그래서 개발 포스팅은 차일피일 계속 미뤄지다가 작년에 회사 인턴을 시작하면서 &apos;이제는 진짜 해야한다&apos;라는 위기감을 느껴서 개발 포스트 몇 개 정도는 발행할 수 있었다.&lt;br&gt;
하지만 그럼에도 문제는 여전히 있었다. 일단 개발 포스팅을 스스로가 습관화하지는 못해서 업로드 주기가 불규칙하였으며(당초 목표는 한달에 약 3개 발행), 어쩌다가 의무감때문에 글을 쓰더라도 (지금 다시 읽어보면) 글의 퀄리티가 영 마음에 들지 않았기 때문이다.&lt;/p&gt;
&lt;p&gt;마음 속에는 &apos;열심히 글 써야지&apos;라는 추상화된 생각이 자리잡고 있는데, 현실 속에서 이를 구현하고 있지 못하는 상황이었다. 고민 끝에 내린 해결책이 바로 &apos;기술 블로그는 따로 분리하자&apos; 였다. 아무래도 티스토리 블로그에는 이미 PS 글들로 가득 차 있었고, 자잘한 블로그 테마나 스킨들도 이에 맞춰져 있었기 때문인지 개발 글을 써도 뭔가 기술 블로그처럼 보이지가 않았다. 고민에 고민을 거듭한 끝에 결국 내가 떠올린 해결책은 바로..&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이건...블로그를 옮겨야 해...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;완전히 새로운 마음으로 제로베이스부터 다시 시작해야 되겠다고 마음을 먹었다. PS를 위한 티스토리 블로그는 PS를 위한 글만 작성하도록 스스로 원칙을 정했다. 블로그 운영에도 &lt;code class=&quot;language-text&quot;&gt;단일 책임 원칙&lt;/code&gt;을 적용했다고 보면 된다.&lt;/p&gt;
&lt;h2&gt;왜 하필 Gatsby?&lt;/h2&gt;
&lt;p&gt;새로운 개발 블로그를 개설할 때에는 여러가지 옵션이 있었다. 가장 간단한 방법은 다른 도메인의 개발용 티스토리 블로그를 개설할 수도 있었다. 하지만 또 다시 티스토리에서 운영하면 똑같은 나태함의 수순을 반복할 것 같아서 완전히 다른 플랫폼으로 옮겨야되겠다고 마음먹었다. 그래서 티스토리를 제외하고 보통 사람들이 운영하는 개발 블로그의 종류에는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brunch&lt;/li&gt;
&lt;li&gt;velog&lt;/li&gt;
&lt;li&gt;medium&lt;/li&gt;
&lt;li&gt;github page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등이 있는데, 앞의 3가지는 플랫폼에서 미리 제공해주는 템플릿이 있고, 유저는 오직 글 작성에만 집중하면 되는 방식이다.
하지만 나는.... 나름 명색이 &lt;strong&gt;프론트엔드 개발자&lt;/strong&gt;이다. 그렇다면 내가 직접 커스텀하고 개발할 수 있는 폭이 넓은 &apos;github page&apos;를 선택해야 하지 않을까? 하는 &lt;code class=&quot;language-text&quot;&gt;근거는-없지만-당연히-그래야-할-것-같은-기분&lt;/code&gt;이 들었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;좋아, 그러면 일단 github page로 결정!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github page에서도 크게 선택이 두 가지로 나뉘는데 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;이다. 둘 다 정적 웹사이트 생성기이지만 약간의 차이는 있다. 내가 차이점에 대해서 정확히 조사한 건 아니지만 대략 찾아보고 느낀 점은 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;은 좀 불편하고, &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt;기반이면서 커스텀할 수 있는 여지도 더 넓다는 것이다. 그리고 무엇보다 결정적인 요인은, 내가 다른 개발자분들의 기술 블로그를 &lt;del&gt;염탐&lt;/del&gt; 구경해보면서 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;기반의 기술블로그가 훨씬 더 많았다는 점이다. 이쯤 되니 아, 나는 어쩔 수없이 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;를 선택해야 할 운명이야- 가 되어 버렸다.&lt;br&gt;
그래서 이틀 전에 구글링으로 &apos;gatsby 블로그 만드는 방법&apos; 찾아보면서 후다닥 만들고 git에 배포까지 완료했다. 게다가 야심차게 가비아에서 &lt;code class=&quot;language-text&quot;&gt;juheon.dev&lt;/code&gt; 도메인까지 구입해서 연결했다. 1년에 3만원 남짓한 금액이지만 아무튼 내 돈주고 운영하는 블로그인만큼 조금의 강제성은 부여되지 않을까 기대해본다.&lt;/p&gt;
&lt;h2&gt;앞으로 어떻게 운영해야할까&lt;/h2&gt;
&lt;p&gt;우선 나 스스로 블로그에 글을 쓴다는 심리적인 허들을 낮출 필요가 있다. 현재 나는 은근히 글을 쓰는 데에 부담감을 짋어지고 있는 듯 하다. 좋은 글을 써야 한다는 압박 때문인지 주제는 정해놓고서도 쉽사리 글을 적지는 못하고 있다.&lt;br&gt;
사실 다른 개발자분들의 기술블로그를 구경하면서 다들 글을 너무 잘 쓰길래 스스로 기가 죽은 것 같은 기분을 느낀다. 그렇지만 처음부터 잘 쓰는 사람이 어디 있을까, 짧고 간결한 글이라도 좋으니깐 일단 글을 쓰는 일을 &apos;습관화&apos;하는 일이 1순위이다.&lt;/p&gt;</content:encoded></item></channel></rss>