<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[하주헌 개발 블로그]]></description><link>https://juheon.dev</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 04 Jul 2025 17:53:53 GMT</lastBuildDate><item><title><![CDATA[2025년 상반기 회고]]></title><description><![CDATA[오랜만에 오랜만에 글을 쓴다. 그동안 '많은 일'들이 있었고, 개인적으로 생각을 정리하느라 블로그에 소홀해졌다. '많은 일'이 무엇인지에 대해선 차차 설명할 것이고, 결론부터 말하자면 대학원에 진학하기로 결정했다.…]]></description><link>https://juheon.dev/essay/250701-review-2025-half/</link><guid isPermaLink="false">https://juheon.dev/essay/250701-review-2025-half/</guid><pubDate>Tue, 01 Jul 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;오랜만에&lt;/h2&gt;
&lt;p&gt;오랜만에 글을 쓴다.&lt;/p&gt;
&lt;p&gt;그동안 &apos;많은 일&apos;들이 있었고, 개인적으로 생각을 정리하느라 블로그에 소홀해졌다. &apos;많은 일&apos;이 무엇인지에 대해선 차차 설명할 것이고, 결론부터 말하자면 &lt;strong&gt;대학원에 진학하기로 결정했다&lt;/strong&gt;. 9월부터 석사 과정을 시작할 예정이며, 분야는 LLM으로 큰 방향성을 정했다.&lt;/p&gt;
&lt;p&gt;뜬금없는 전개일 수 있다. 그렇다고 해서 홧김에 내린 즉흥적인 결정이 아니며, 긴 고심 끝에 내린 결정이다. 여러 요인을 고려해 보았을 때 도출해낸 최선의 안이라고 생각한다(최소한 지금까지는).&lt;br&gt;
직장인 생활을 약 2년간 해오다가 다시 대학원으로 유턴하는 선택이 쉽지는 않았다. 이번 글에서는 내가 어떤 근거로 이러한 결정을 내리게 되었는지에 대한 생각을 풀어보고자 한다.&lt;/p&gt;
&lt;h2&gt;많은 일이 있었다&lt;/h2&gt;
&lt;p&gt;작년(2024년) 8월에 다니던 회사를 퇴사했다. 경영상의 이유로 사실상 비자발적인 퇴사였고 갑작스럽게 구직을 해야하는 상황이 찾아왔다. 묵혀둔 이력서를 고쳐쓰고 여러 회사에 서류를 돌렸다. 그렇다고 해서 조급한 마음에 무막정 아무 공고에 지원을 넣지는 않았다. 내 나름대로 회사와 프로덕트에 대한 기준선을 설정해놓고 이를 만족하는 회사들만 지원했다.&lt;/p&gt;
&lt;p&gt;그렇게 8~9월간 약 20곳의 회사에 지원했고 서류를 합격한 곳은 7 곳이었다. 당시 채용 시장 상황이 위축되어 있음을 고려하면 나름 선방한 타율이라고 볼 수 있다. 서류 합격 이후에는 대부분 면접을 진행한다. 기술면접과 컬쳐핏 2번에 걸쳐서 진행하는 곳도 있고, 단 1번만에 끝나는 곳도 있다. 그리하여 최종 면접까지 보고 왔던 회사가 3곳이 있었다. 최종 면접은 웬만하면 합격한다는 인식이 있었기 때문에 한편으로는 마음이 놓이기도 했다.&lt;br&gt;
&lt;strong&gt;그렇지만 결과는 3곳 모두 불합격이었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기서 1차로 멘탈이 나가는 시점이었다. 게다가 우연의 장난인건지 각기 다른 회사 3곳의 불합격 통보가 3일 연속으로 날아왔다. 이때가 9월 말이었다. 솔직히 3곳 중 최소 하나쯤은 붙을 것이라고 낙관하고 있었기에 충격이 더 컸던 것 같다.&lt;/p&gt;
&lt;p&gt;그 후 3일동안 서류 지원도, 공부도 손을 대지 못했다. 일단 멘탈을 복구할 시간이 필요했다.&lt;br&gt;
&lt;em&gt;그래, 내가 어딘가 부족한 부분이 있었기 때문에 떨어진 거겠지. 이건 분명 다음에 더 좋은 회사를 가기 위한 큰 그림일거야.&lt;/em&gt; 하면서 스스로 자기합리화를 했다(난 이런걸 좀 잘하는 편이다).&lt;/p&gt;
&lt;p&gt;그렇다고 자기합리화만 한 건 아니다. 나는 온라인으로 진행되는 면접에서는 녹음기를 틀어놓고, 면접이 끝나면 다시 들어보면서 셀프 피드백을 한다. 오프라인 면접에서는 면접이 끝나자마자 받았던 질문들과 내가 했던 대답들을 기록해 놓는다. 그리곤 다음번에는 어떻게 대답하는게 좋을지 모범답안을 다시 만들어보곤 한다.&lt;/p&gt;
&lt;p&gt;왜 떨어졌는지에 대해 어느정도 짐작이 가는 면접도 있었다. 회사에서는 5년이상의 고연차 경력자를 원하는데 나는 그에 못미치기도 했다. 그리고 내가 대답을 제대로 못했던 면접도 있었다. 아무튼 세상에 이유없이 떨어뜨리는 면접은 없다.&lt;br&gt;
일주일이 지나자 너덜너덜해졌던 멘탈이 어느정도 복구되었고, 셀프 피드백을 통해 나는 더 강해졌으리라 믿고 있었다. 다시 이력서를 고치고 공부를 하는 일상이 반복되었다.&lt;/p&gt;
&lt;p&gt;그 이후로는 회사 지원에 대한 기준선을 조금 낮춰서 지원 횟수를 늘렸다. 너무 나만의 기준선을 엄격하게 두기보단, 표본의 개수를 늘려보면서 어떠한 회사와 공고에서 합격률이 높은지를 확인해보고 싶었다. 그렇게 10월부터 12월까지 30개가 넘는 공고에 지원했다. 합격률은 지난번과 비슷했다. 피드백 과정을 반복하다보니 확실히 지난번보다 면접에서의 자신감은 붙었고, 결국 2곳으로부터 최종합격을 받게 되었다. 하지만 여기서도 시련은 끊이질 않았다.&lt;/p&gt;
&lt;p&gt;우선 한 곳은 최종합격 통보를 받고 3일이 지난 뒤, 불합격으로 결과가 번복되었다. 이 소식을 듣고 어안이 벙벙해져 회사로부터 자초지종을 설명해달라고 했지만, &apos;내부 협의에 따른 결과&apos;라는 형식적인 답변만 돌아왔다.&lt;br&gt;
그리고 다른 한 곳은 연봉협상 과정에서 이견의 너무 커서 결국 결렬되었다.&lt;/p&gt;
&lt;p&gt;이로인해 2차로 멘탈이 나가게 되었다. 이제는 내 능력과 노력의 탓이 아닌 외부 상황으로 인해 벌어진 사태였기에 1차 때보다도 더 큰 타격이었다. 이 시점을 계기로 구직을 위한 의지가 대부분 꺾이게 되었다. 설상가상으로 시장 상황은 점점 더 악화되고 문은 더 좁아지고 있었다. 무기력해진 내 자신의 모습을 부정하고 싶었다. 애써 괜찮은 척 다시 공부를 시작하고 지원하려 했는데 이번에는 복구하기가 쉽지 않겠다는 예감이 들었다. 당시에는 인정하진 않았지만 지금 와서 돌이켜보면 &lt;strong&gt;번아웃&lt;/strong&gt;이 왔었다. 이때가 12월 말이었다.&lt;/p&gt;
&lt;h2&gt;이대로는 안된다&lt;/h2&gt;
&lt;p&gt;이대로 계속 가다간 커리어뿐만 아니라 정신건강까지 망치게 될 것 같다는 생각이 들었다. 출구전략이 필요했다. 일단은 쉴 필요가 있다고 판단했다. 기한을 정하려 하지도 않고 멘탈이 복구될 때까지 무작정 쉬기로 했다.&lt;/p&gt;
&lt;p&gt;그렇게 한 열흘정도 쉰 것 같다. 날짜는 어느새 해가 지나 2025년이 되었다. 멘탈이 복구되지는 않았지만 드문드문 채용공고를 살펴보면서 몇 개 지원을 해보기도 했지만 결과는 좋지 않았다. 이제는 너무 많이 떨어지고 멘탈도 두 번이나 깨져서인지 별 타격도 없었다. 그냥 아무 회사에 들어가서 시간 때우다가, 시장 상황이 나아지면 이직하는게 나을지도 고민해보기도 했다. 지푸라기라도 잡고 싶은 심정이었다.&lt;/p&gt;
&lt;p&gt;그리고 2,3년 뒤의 웹 프론트엔드 시장이 어떨지를 생각해보았다. 2024년부터 Cursor를 비롯한 코딩을 위한 생성형 AI 기술의 성능이 비약적으로 성장했다. 이제는 단순 구현을 위한 코딩만 놓고보면 나보다 AI가 더 빠르고 정확하게 수행한다는 사실을 인정하지 않을 수 없게 되었다. 몇 년이 더 지나면 지금보다도 AI는 훨씬 더 잘하게 될 것이고 대부분의 업무를 사람 대신 AI가 대체할 수 있게 될 것이다.&lt;br&gt;
웹 프론트엔드 업무의 대부분은 기존에 작성된 코드를 약간만 각색하여 새로운 페이지를 만드는 일이고, 이 업무는 AI가 가장 잘 하는 분야이다. 그럼 나는 AI는 잘 하지 못하는 분야를 강점으로 내세워야 경쟁력이 생긴다.&lt;/p&gt;
&lt;p&gt;점점 내 앞으로의 커리어에 대한 생각의 방향이 낙관론에서 비관론에 가까워지고 있었다. 그러면서 이 분야의 지속가능성에 대해서도 회의감이 들기 시작했다.&lt;br&gt;
&apos;지금 당장 프론트엔드 개발자는 전망이 없다&apos;는 말을 하려는게 아니다. 내가 개발자 커리어에 진입하는 시점에서 &lt;strong&gt;앞으로 투자(시간/공부)대비 결과(희귀성/유망성/보상)을 계산했을 때, 프론트엔드보다는 다른 분야가 더 효율적&lt;/strong&gt;이라는 결론을 내리게 되었다. 간단히 말하자면 프론트엔드 분야는 지난 몇 년간 공급은 지나치게 과잉되었고 수요는 점점 줄어들고 있다. 앞으로 저연차 개발자가 차지하는 피라미드의 밑부분은 AI가 대체하여 설 자리를 잃게될 것이라고 생각했다.&lt;/p&gt;
&lt;h2&gt;대학원 진학&lt;/h2&gt;
&lt;p&gt;그렇다면 위의 계산 공식에 의거하면 어떤 분야에 투자하는게 가장 효율적일까를 고민해보았다. 만만한건 백엔드나 모바일 분야기는 하나, 이 또한 AI의 발전으로 인해 언젠가는 대체될 것 같다는 맥락은 동일했다. 희귀성과 유망성에 걸맞는 분야를 찾는다면 AI 개발분야가 1순위다.&lt;/p&gt;
&lt;p&gt;여기서도 다양한 선택지가 있었는데 전통적인 방식은 대학원을 가는 것이고, 다른 방안은 부트캠프를 가는 것이었다. 대학원은 최소 2년이라는 시간과 논문 작성의 측면에서 투자해야할 인풋이 크지만 그만큼 확실한 대우를 보장받는다. 반면 부트캠프는 평균적으로 6개월 과정으로, 논문 없이 프로젝트 성격으로 진행되기에 인풋대비 결과를 더 바르게 확인할 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;처음에는 학업을 위한 공부를 더 해야한다는 점에 부담감이 있어서 대학원을 선택하기는 어려웠다. 내가 지금까지 살아오면서 이처럼 선택의 갈림길에 섰을 때, 두려운 선택지는 외면하고 쉬운 길을 택했던 경향이 있다. 하지만 기왕 다른 분야로 도전할거라면 처음부터 제대로 시작하는게 낫다고 판단했다. 그래서 이번에는 어려운 길을 선택해보기로 했다. 때로는 지금까지 내가 살아온 관성을 버리고 새로운 길을 선택함으로써 더 좋은 결과가 나올 수도 있는 법이다.&lt;/p&gt;
&lt;h2&gt;프론트 개발자로 2년동안 배운 것&lt;/h2&gt;
&lt;p&gt;이런 질문을 던질 수도 있겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;웹 프론트엔드 개발자로서 2년동안 열심히 공부하고 커리어 쌓아왔는데, 이제와서 다른 분야(AI)로 틀기엔 지금까지 해놓은게 너무 아깝지 않나?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;사실 이 질문은 내가 스스로에게 던진 것이다. 위 질문을 스스로에게 100번쯤 되물어 보았다. 대학원에 진학하는 마지막 순간까지도 지금까지 (프론트엔드 분야에서) 해놓은게 아까워서 결정을 주저하고 있었다. 그러면서 내가 2년동안 무엇을 해왔는지에 대해 곰곰이 되돌아보았다.&lt;/p&gt;
&lt;p&gt;나는 지금까지 2곳의 회사에서 일했다. 각각 1년씩 총 2년의 경력인 셈이다. 그동안 한 번의 이직을 경험했고, 이력서를 30번 넘게 고쳐썼고, 지원한 채용공고가 150개는 족히 되며 불합격은 100번 넘게 받아보고, 면접은 23번 봤다. 새로운 직장 동료 수십명이 카톡 친구창에 추가됐고, 다른 회사로 파견 근무도 가보고, 코드리뷰를 통해 내 코드를 다른 사람에게 설명해보고, 마감기간을 지키기 위해 밤 10시가 넘도록 야근도 해보고, 그것도 모자라 집에서 새벽이 되도록 작업을 해본 경험도 있었다.&lt;/p&gt;
&lt;p&gt;이처럼 내가 2년동안 배운건 비단 프론트엔트 기술만이 아니다. 학교에서 벗어나 회사라는 새로운 사회에서 사람들과 관계를 맺고, 내 생각을 남들에게 표현하는 방법, 여러 사람이 모인 &apos;회사&apos;집단이 하나의 지향점을 향해 달려가기 위해서 어떻게 운영되는지, 그리고 업무를 대하는 방식과 여러 사람들과 협업하는 방법에 대해 배울 수 있었다.&lt;/p&gt;
&lt;p&gt;또한 이전에는 개발외에는 문외한이었던 내가 회사를 다니며 기획,디자인,경영,마케팅,HR 등 각기 다양한 분야의 사람들과 직간접적으로 만나며 대화할 수 있는 기회를 만드려고 했다. 대화를 통해 개발 외 분야에서는 어떠한 어려움이 있고 이를 어떻게 해결하는지 얘기를 들으면서 내가 접해보지 못했던 다른 세계를 조금이나마 간접적으로 경험하고 싶었다.&lt;/p&gt;
&lt;p&gt;나는 세상에 쓸모없는 경험은 없다고 생각한다. 일의 말미가 잘못된다 하더라도 모든 경험은 나름대로의 교훈을 준다. &lt;strong&gt;내가 2년동안 배운건 더 넓은 세상 속에서 다양한 사람들과의 경험, 회사 생활과 업무를 처리하는 방식, 그리고 내 생각을 남들에게 표현하는 법이다.&lt;/strong&gt; 분야가 바뀐다고 한들 여기서 얻은 경험치는 사라지지 않는다. 앞으로 무슨 일을 하든 이 경험은 내게 소중한 시간으로 남을 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Selenium으로 블로그 이미지 마이그레이션 (Feat.Cursor)]]></title><description><![CDATA[이미지 마이그레이션 계획 Cloudinary 관련 컨텐츠로 글을 무지막지하게 뽑아내고 있다. 처음에는 소소하게 시작했는데, 하다보니깐 재미가 붙어서 계속 살을 덧붙이고 싶어진다. 지금까지 내가 블로그에 올린 asset…]]></description><link>https://juheon.dev/python/250128-selenium-automation/</link><guid isPermaLink="false">https://juheon.dev/python/250128-selenium-automation/</guid><pubDate>Tue, 28 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;이미지 마이그레이션 계획&lt;/h2&gt;
&lt;p&gt;Cloudinary 관련 컨텐츠로 글을 무지막지하게 뽑아내고 있다. 처음에는 소소하게 시작했는데, 하다보니깐 재미가 붙어서 계속 살을 덧붙이고 싶어진다.&lt;/p&gt;
&lt;p&gt;지금까지 내가 블로그에 올린 asset 파일들은 &lt;a href=&quot;https://juheon.dev/react/250123-cloudinary-next-image-uploader-1/&quot;&gt;이 포스팅&lt;/a&gt;에서도 설명했다시피 두 가지 방식으로 저장했었는데, 이제는 이 파일들을 모두 Cloudinary로 마이그레이션 하고자 한다. 이를 위해 웹 스크래핑 라이브러리 &lt;code class=&quot;language-text&quot;&gt;Selenium&lt;/code&gt;을 사용해보기로 했다. 나도 &lt;code class=&quot;language-text&quot;&gt;Selenium&lt;/code&gt;은 이번에 처음 접해보기 때문에 Cursor의 힘을 빌려서 자동화 코드를 작성해보려 한다. 마이그레이션은 총 4단계로 이뤄진다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;블로그에 올린 이미지 파일의 경로 추출&lt;/li&gt;
&lt;li&gt;추출한 경로를의 이미지를 모두 다운로드&lt;/li&gt;
&lt;li&gt;다운로드한 이미지를 Cloudinary에 업로드&lt;/li&gt;
&lt;li&gt;업로드된 경로를 바탕으로 기존 경로 수정&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. 블로그에 올린 이미지 파일의 경로 추출&lt;/h3&gt;
&lt;p&gt;우선 내 블로그(juheon.dev)에 접속하여 존재하는 모든 게시물에 있는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt;태그 안의 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt; 속성을 추출해내야 한다. 추출한 이미지는 별도의 txt 파일로 저장해두고 이후 다운로드 과정에서 사용할 것이다.&lt;/p&gt;
&lt;p&gt;코드는 Cursor가 열심히 만들어줬다. Cusor는 정말 최고다...짜릿하다....&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;코드 보기&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;python&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
import time
from datetime import datetime

def get_all_image_sources(driver, post_url):
    # 게시물 페이지 접속
    driver.get(post_url)
    time.sleep(2)  # 페이지 로딩 대기

    # 이미지 태그 찾기
    images = driver.find_elements(By.TAG_NAME, &amp;quot;img&amp;quot;)
    image_sources = []

    # 이미지 소스 URL 추출
    for img in images:
        src = img.get_attribute(&amp;#39;src&amp;#39;)
        if src:
            image_sources.append(src)

    return image_sources

def save_to_file(image_sources):
    # 현재 시간을 파일명에 포함
    timestamp = datetime.now().strftime(&amp;quot;%Y%m%d_%H%M%S&amp;quot;)
    filename = f&amp;quot;image_sources_{timestamp}.txt&amp;quot;

    with open(filename, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f:
        f.write(f&amp;quot;추출 시간: {datetime.now().strftime(&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39;)}\n&amp;quot;)
        f.write(f&amp;quot;총 이미지 수: {len(image_sources)}\n&amp;quot;)
        f.write(&amp;quot;-&amp;quot; * 50 + &amp;quot;\n\n&amp;quot;)

        for i, src in enumerate(image_sources, 1):
            f.write(f&amp;quot;{i}. {src}\n&amp;quot;)

    return filename

def main():
    # Chrome 드라이버 설정
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service)

    try:
        # 메인 페이지 접속
        driver.get(&amp;quot;https://juheon.dev&amp;quot;)
        time.sleep(3)  # 페이지 로딩 대기

        # 모든 게시물 링크 수집
        post_links = []
        articles = driver.find_elements(By.TAG_NAME, &amp;quot;article&amp;quot;)

        for article in articles:
            try:
                link = article.find_element(By.TAG_NAME, &amp;quot;a&amp;quot;).get_attribute(&amp;#39;href&amp;#39;)
                if link:
                    post_links.append(link)
            except:
                continue

        print(f&amp;quot;총 {len(post_links)}개의 게시물을 찾았습니다.&amp;quot;)

        # 각 게시물 방문하여 이미지 소스 추출
        all_image_sources = []
        for i, post_url in enumerate(post_links, 1):
            print(f&amp;quot;\n게시물 {i}/{len(post_links)} 처리 중...&amp;quot;)
            image_sources = get_all_image_sources(driver, post_url)
            print(f&amp;quot;발견된 이미지 수: {len(image_sources)}&amp;quot;)

            for src in image_sources:
                print(f&amp;quot;이미지 소스: {src}&amp;quot;)
                all_image_sources.append(src)

        # 결과를 파일로 저장
        filename = save_to_file(all_image_sources)
        print(f&amp;quot;\n총 {len(all_image_sources)}개의 이미지를 찾았습니다.&amp;quot;)
        print(f&amp;quot;결과가 {filename} 파일에 저장되었습니다.&amp;quot;)

    finally:
        driver.quit()

if __name__ == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;2. 추출한 경로를의 이미지를 모두 다운로드&lt;/h3&gt;
&lt;p&gt;1번을 실행하면 아래와 같은 형태의 텍스트 파일이 생성된다. 그럼 이제 이 파일을 모두 다운로드해야 한다. 여기서 주의해야할 점은 jpg 파일과 gif 파일이 혼재되어 있기 때문에 파일 확장자를 확인하여 다운로드해야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;추출 시간: 2025-01-27 21:43:56
총 이미지 수: 104
--------------------------------------------------

4. https://juheon.dev/static/d059a7dc2274b3319003d03e50db9fcd/bbf83/profile-graduate.jpg
14. https://github.com/user-attachments/assets/4d1c7159-9a23-4473-a039-7bfe3375bf2c
18. https://github.com/user-attachments/assets/d9ad8b41-fb62-4469-a1bd-0f278b6d13f4
...
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Response 헤더를 통해 확장자가 gif인지 jpg인지 확인할 수 있다. 또한 경로가 &lt;code class=&quot;language-text&quot;&gt;juheon.dev/static/&lt;/code&gt; 이거나 &lt;code class=&quot;language-text&quot;&gt;github.com/user-attachments/&lt;/code&gt; 인 경우에만 다운로드하도록 하면 된다. 다운로드한 파일은 &lt;code class=&quot;language-text&quot;&gt;/images&lt;/code&gt; 디렉토리에 저장된다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;코드 보기&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;python&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import os
import requests
from urllib.parse import urlparse
import re
from pathlib import Path

def get_image_format(response):
    &amp;quot;&amp;quot;&amp;quot;
    이미지 데이터를 분석하여 실제 이미지 포맷을 반환
    &amp;quot;&amp;quot;&amp;quot;
    # 처음 바이트를 확인하여 이미지 포맷 판별
    header = response.content[:8]

    # GIF 시그니처 확인
    if header.startswith(b&amp;#39;GIF89a&amp;#39;) or header.startswith(b&amp;#39;GIF87a&amp;#39;):
        return &amp;#39;gif&amp;#39;
    # JPEG 시그니처 확인
    elif header.startswith(b&amp;#39;\xFF\xD8\xFF&amp;#39;):
        return &amp;#39;jpg&amp;#39;

    return &amp;#39;jpg&amp;#39;  # 기본값은 jpg

def download_image(url, save_dir):
    try:
        # URL에서 파일명 추출
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)

        # 파일명에서 모든 확장자 제거
        name = filename.lower().replace(&amp;#39;.jpg&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;.jpeg&amp;#39;, &amp;#39;&amp;#39;).replace(&amp;#39;.gif&amp;#39;, &amp;#39;&amp;#39;)

        # 이미지 다운로드 및 포맷 확인
        response = requests.get(url, stream=True)
        response.raise_for_status()

        # 실제 이미지 포맷 확인
        image_format = get_image_format(response)
        filename = name + &amp;#39;.&amp;#39; + image_format

        # 저장 경로 설정
        save_path = os.path.join(save_dir, filename)

        # 파일 저장
        with open(save_path, &amp;#39;wb&amp;#39;) as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)

        print(f&amp;quot;다운로드 완료: {filename} ({image_format} 포맷)&amp;quot;)
        return True
    except Exception as e:
        print(f&amp;quot;다운로드 실패 ({url}): {str(e)}&amp;quot;)
        return False

def main():
    # images 디렉토리 생성
    save_dir = &amp;#39;images&amp;#39;
    os.makedirs(save_dir, exist_ok=True)

    # 가장 최근의 image_sources 파일 찾기
    image_sources_files = list(Path(&amp;#39;.&amp;#39;).glob(&amp;#39;image_sources_*.txt&amp;#39;))
    if not image_sources_files:
        print(&amp;quot;image_sources 파일을 찾을 수 없습니다.&amp;quot;)
        return

    latest_file = max(image_sources_files, key=os.path.getctime)
    print(f&amp;quot;파일 처리 중: {latest_file}&amp;quot;)

    # 파일에서 URL 읽기
    with open(latest_file, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f:
        lines = f.readlines()

    # URL 필터링 및 다운로드
    patterns = [
        r&amp;#39;juheon\.dev/static/&amp;#39;,
        r&amp;#39;github\.com/user-attachments/&amp;#39;
    ]

    success_count = 0
    total_count = 0

    for line in lines:
        # URL 추출 (번호. URL 형식에서)
        match = re.search(r&amp;#39;\d+\.\s*(http[^\s]+)&amp;#39;, line)
        if not match:
            continue

        url = match.group(1)

        # 지정된 패턴과 일치하는 URL만 처리
        if any(re.search(pattern, url) for pattern in patterns):
            total_count += 1
            if download_image(url, save_dir):
                success_count += 1

    print(f&amp;quot;\n다운로드 완료: {success_count}/{total_count} 파일&amp;quot;)
    print(f&amp;quot;저장 위치: {os.path.abspath(save_dir)}&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;dd&lt;/p&gt;
&lt;/details&gt;
&lt;p&gt;실행해보면 파일들이 모두 저장된 것을 확인할 수 있다!
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737985320/blog/assets/download-result.png&quot; alt=&quot;download-result&quot;&gt;&lt;/p&gt;
&lt;h3&gt;3. 다운로드한 이미지를 Cloudinary에 업로드&lt;/h3&gt;
&lt;p&gt;이제 이 파일들을 Cloudinary에 업로드해야 한다. 이 단계는 Drag &amp;#x26; Drop 방식으로 옮기기만 하면 되기 때문에 매우 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737985542/blog/assets/%08Upload.png&quot; alt=&quot;upload-result&quot;&gt;&lt;/p&gt;
&lt;h3&gt;4. 업로드된 경로를 바탕으로 기존 경로 수정&lt;/h3&gt;
&lt;p&gt;이제 Cloudinary에 업로드된 이미지들을 바탕으로 기존 경로를 수정해야 한다. 이 단계는 모두 수작업으로 해야 한다. 때문에 이전 3개의 단계를 합친 시간보다도 더 품이 드는 작업이다. Cursor로도 자동화를 해보려고 했는데, 잘 인식이 안되는 것 같다.&lt;/p&gt;
&lt;h2&gt;마이그레이션 결과&lt;/h2&gt;
&lt;p&gt;빌드 결과물을 확인해본 결과, asset 파일의 용량이 기존 28.4 MB에서 70% 이상 줄어든 6.3MB가 된 것을 확인할 수 있다. 앞으로 블로그에 올린 이미지들은 모두 Cloudinary에 저장될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737989498/blog/assets/migration-result.png&quot; alt=&quot;migration-result&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이미지 업로드 자동화 에러 핸들링/개선 사항]]></title><description><![CDATA[예외 처리 지난 포스팅에서 언급했던 4가지 예외 처리를 고려해보자. 파일 업로드 실패 처리(네트워크 문제) 중복되는 파일 처리 파일 포맷 검증 파일 크기 검증…]]></description><link>https://juheon.dev/react/250126-cloudinary-next-image-uploader-3/</link><guid isPermaLink="false">https://juheon.dev/react/250126-cloudinary-next-image-uploader-3/</guid><pubDate>Sun, 26 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;예외 처리&lt;/h2&gt;
&lt;p&gt;지난 포스팅에서 언급했던 4가지 예외 처리를 고려해보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;파일 업로드 실패 처리(네트워크 문제)&lt;/li&gt;
&lt;li&gt;중복되는 파일 처리&lt;/li&gt;
&lt;li&gt;파일 포맷 검증&lt;/li&gt;
&lt;li&gt;파일 크기 검증&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1. 파일 업로드 실패 처리&lt;/h4&gt;
&lt;p&gt;현재 서비스에서는 업로드 도중 네트워크가 끊기게 될 경우 무한 로딩 상태에 빠지게 된다. 사용자는 네트워크에 문제가 생겼다는 걸 인지하기 전까지는 하염없이 로딩을 기다려야 하기 때문에 UX에 악영향을 끼치게 된다.&lt;br&gt;
이를 해결하기 위해서 timeout 시간을 설정하여 이 시간 내에 업로드를 완료하지 못할 경우 업로드를 중단하고 사용자에게 에러를 띄우려고 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;AbortController&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;을 사용하여 업로드 시간을 제한하고 이 시간 내에 업로드가 완료되지 않을 경우 업로드를 중단하고 사용자에게 에러를 띄우는 방식으로 해결했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUpload.ts
...
const controller = new AbortController()
const timeoutId = setTimeout(() =&amp;gt; controller.abort(), UPLOAD_TIMEOUT)

try {
  const response = await fetch(&amp;quot;/api/upload&amp;quot;, {
    method: &amp;quot;POST&amp;quot;,
    body: formData,
    signal: controller.signal,
  })
  clearTimeout(timeoutId)

  const result: { secure_url: string } = await response.json()
  if (!result) throw new Error(&amp;quot;Failed to upload file&amp;quot;)
  uploadedUrls.push(result.secure_url)
} catch (error) {
  if (error instanceof Error) {
    if (error.name === &amp;quot;AbortError&amp;quot;) {
      alert(&amp;quot;Upload timeout exceeded. Please try again.&amp;quot;)
      throw new Error(&amp;quot;Upload Timeout&amp;quot;)
    }
    throw error
  }
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;개발자도구의 Network Throttle을 Offline으로 설정해놓고 10초가 넘으면 아래와 같이 에러 alert가 표시된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737787649/blog/assets/error2.png&quot; alt=&quot;error2&quot;&gt;&lt;/p&gt;
&lt;p&gt;아직 API가 하나밖에 없는 작은 규모의 서비스기 때문에 &lt;code class=&quot;language-text&quot;&gt;useFileUpload&lt;/code&gt; 훅에서 예외처리를 하고 있지만, 나중에 API가 많아진다면 공통함수로 분리하는 편이 낫겠다.&lt;/p&gt;
&lt;h4&gt;2. 중복되는 파일 처리&lt;/h4&gt;
&lt;p&gt;파일명을 바꿀 수 있는 기능을 추가했기 때문에 여러개의 파일의 이름을 동일하게 수정할 수도 있다. 실제로 업로드 해보면 어떤 결과가 나올까?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737785178/blog/assets/%08error1.png&quot; alt=&quot;error1&quot;&gt;&lt;/p&gt;
&lt;p&gt;기묘한 결과가 나왔다.&lt;br&gt;
업로드를 성공하긴 했다. 파일의 저장 경로를 보면 v로 시작하는 값이 다름을 확인할 수 있다. 각기 다른 경로에 저장된 것이다. 여러 이미지 파일들로 업로드 테스트해본 결과 이미지가 저장되는 경로는 다음과 같은 규칙성이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;res.cloudinary.com/{클라우드이름}/image/upload/{업로드시간}/{저장경로}/{파일명}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 실제 업로드 된 이미지를 보면 둘이 완전히 동일한 이미지이다. 하나의 파일이 다른 하나의 파일로 덮어 씌워진 것이다. 아무래도 동일한 파일명으로 업로드를 시도하면 고장이 나는 것 같다. 동일한 파일명으로 업로드하는 건 버튼을 누르기 전에 프론트엔드에서 방어 로직을 추가하는 것이 좋겠다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUpload.ts
...
const checkDuplicateFileName = (newName: string, currentIndex: number) =&amp;gt; {
  for (let i = 0; i &amp;lt; previewUrls.length; i++) {
    if (i === currentIndex) continue
    if (previewUrls[i].name === newName) return true
  }
  return false
}

const confirmEdit = (index: number, newName: string) =&amp;gt; {
  if (checkDuplicateFileName(newName, index)) {
    alert(&amp;quot;This file name already exists. Please enter a different name.&amp;quot;)
    return
  }

  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;파일명을 수정하는 &lt;code class=&quot;language-text&quot;&gt;confirmEdit&lt;/code&gt; 에서 중복되는 파일명을 검증하는 &lt;code class=&quot;language-text&quot;&gt;checkDuplicateFileName&lt;/code&gt;함수를 추가했다. 동일한 파일명으로 업로드를 시도하려는 경우 alert가 뜨면서 파일명을 수정하도록 유도할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737811251/blog/assets/error3.png&quot; alt=&quot;error3&quot;&gt;&lt;/p&gt;
&lt;h4&gt;3. 파일 포맷 검증&lt;/h4&gt;
&lt;p&gt;현재 업로드 가능한 파일의 포맷은 이미지(gif 포함)파일만 가능하다. 그 외의 파일 포맷은 업로드를 막기 위해서 방어로직을 추가해보자.&lt;/p&gt;
&lt;p&gt;우선 프론트엔드에서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그의 속성으로 &lt;code class=&quot;language-text&quot;&gt;accept&lt;/code&gt;를 추가하여 파일 포맷을 제한할 수 있다. 만약 이미지 파일만 업로드 가능하도록 하고 싶다면 다음과 같이 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;input type=&amp;quot;file&amp;quot; accept=&amp;quot;image/*&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러면 파일탐색기에서 이미지 파일만 선택할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;하지만 프론트엔드에서만 방어한다고 능사가 아니다. 프론트엔드를 우회하여 업로드할 수도 있으므로 백엔드에서 또한 파일 포맷을 검증하는 로직을 추가하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// api/upload.ts
...
const result = await new Promise&amp;lt;UploadApiResponse&amp;gt;((resolve, reject) =&amp;gt; {
  cloudinary.uploader
    .upload_stream(
      {
        resource_type: &amp;quot;image&amp;quot;,
        folder: uploadsFolder,
        public_id: filename.split(&amp;quot;.&amp;quot;)[0],
        allowed_formats: [&amp;quot;jpg&amp;quot;, &amp;quot;jpeg&amp;quot;, &amp;quot;png&amp;quot;, &amp;quot;gif&amp;quot;, &amp;quot;webp&amp;quot;], // 허용 파일 포맷 지정
      },
      (error, result) =&amp;gt; {
        if (error || !result) reject(error)
        else resolve(result)
      }
    )
    .end(Buffer.from(fileBuffer))
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;4. 파일 크기 검증&lt;/h4&gt;
&lt;p&gt;마지막으로 파일 크기를 검증하는 로직을 추가해보자. 이 역시 프론트엔드와 백엔드에서 모두 검증해야 한다.&lt;/p&gt;
&lt;p&gt;프론트엔드에서는 &lt;code class=&quot;language-text&quot;&gt;File&lt;/code&gt; 객체의 &lt;code class=&quot;language-text&quot;&gt;size&lt;/code&gt; 속성을 사용하여 파일 크기를 알아낼 수 있다. 파일 최대 용량을 10MB로 제한하고 싶다면 다음과 같이 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUpload.ts
...
 const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
 const checkOverSizeFile = (files: File[]) =&amp;gt; {
    const oversizedFiles = files.filter((file) =&amp;gt; file.size &amp;gt; MAX_FILE_SIZE);
    if (oversizedFiles.length &amp;gt; 0) {
      alert(&amp;#39;Files cannot exceed 10MB in size.&amp;#39;);
      return true;
    }
    return false;
  };

  const handleFileChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
    ...
    if (checkOverSizeFile(selectedFiles)) {
      e.target.value = &amp;#39;&amp;#39;;
      return;
    }
    ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;마찬가지로 백엔드에서도 &lt;code class=&quot;language-text&quot;&gt;chunk_size&lt;/code&gt; 속성을 사용하여 업로드할 최대 파일 크기를 제한할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// api/upload.ts
...
    const result = await new Promise&amp;lt;UploadApiResponse&amp;gt;((resolve, reject) =&amp;gt; {
      cloudinary.uploader
        .upload_stream(
          {
            resource_type: &amp;#39;image&amp;#39;,
            folder: uploadsFolder,
            public_id: filename.split(&amp;#39;.&amp;#39;)[0],
            allowed_formats: [&amp;#39;jpg&amp;#39;, &amp;#39;jpeg&amp;#39;, &amp;#39;png&amp;#39;, &amp;#39;gif&amp;#39;, &amp;#39;webp&amp;#39;],
            chunk_size: MAX_FILE_SIZE, // 최대 파일 크기 제한
          },
          (error, result) =&amp;gt; {
            if (error || !result) reject(error);
            else resolve(result);
          }
        )
        .end(Buffer.from(fileBuffer));
    });
    ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;그 밖의 개선사항&lt;/h2&gt;
&lt;h4&gt;1. 파일을 선택한 상태에서 다른 파일을 추가할 수 있도록 하기&lt;/h4&gt;
&lt;p&gt;현재 기존에 파일이 올라가 있는 상태에서 새로운 파일만 따로 추가할 수가 없어서, 새로고침 후 처음부터 업로드 해야하는 불편함이 있다. 새 파일이 선택되면 덮어씌우지 말고 기존 파일들과 병합시키도록 하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUpload.ts
  const handleFileChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
    ...

    // Merge newly selected files with existing files if any
    setFiles((prevFiles) =&amp;gt; [...prevFiles, ...selectedFiles]);

    const previews: PreviewUrl[] = [];
    selectedFiles.forEach((file) =&amp;gt; {
      const fileReader = new FileReader();
      fileReader.onloadend = () =&amp;gt; {
        previews.push({
          url: fileReader.result as string,
          name: file.name,
          originalName: file.name,
          isEditing: false,
        });
        if (previews.length === selectedFiles.length) {
          // Merge newly selected files with existing files if any
          setPreviewUrls((prevPreviewUrls) =&amp;gt; [
            ...prevPreviewUrls,
            ...previews,
          ]);
        }
      };
      fileReader.readAsDataURL(file);
    });
  };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;2. 업로드 완료 후 리셋 기능&lt;/h4&gt;
&lt;p&gt;업로드를 완료하고 나서 파일 선택 영역을 초기화하는 기능을 추가해보자. 정석적인 방법은 &lt;code class=&quot;language-text&quot;&gt;useFileUpload&lt;/code&gt; 훅에서 파일 관련 변수들을 초기화하는 함수를 추가하면 되지만, 간단하게 생각하면 그냥 페이지를 새로고침 시키면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUpload.ts
...
const clearFiles = () =&amp;gt; {
  window.location.reload()
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;앞으로 더 생각해볼 것들&lt;/h2&gt;
&lt;h4&gt;안전하게 public 배포(인증 프로세스?)&lt;/h4&gt;
&lt;p&gt;현재 상태로 Public 배포를 하면 모든 사용자가 이미지를 업로드할 수 있게 된다. 이를 방지하기 위해서는 인증 프로세스를 추가해야 하는데 어차피 나 혼자만 쓸거니깐 최대한 간소화시키고 싶다. 그 전까지는 번거롭지만 로컬서버에서 띄워서 업로드해야겠다.&lt;/p&gt;
&lt;h4&gt;이전에 올린 asset 파일들 모두 Cloudinary로 마이그레이션 자동화&lt;/h4&gt;
&lt;p&gt;앞으로 올릴 asset 파일들은 모두 Cloudinary로 업로드할 예정이다. 이전에 올린 파일들은 모두 Cloudinary로 마이그레이션 자동화해야하는데 꽤나 번거로운 작업이다.&lt;/p&gt;
&lt;h4&gt;파일 업로드 진행률 표시&lt;/h4&gt;
&lt;p&gt;파일을 업로드하는 동안 진행률을 표시해주는 것이 좋을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Cloudinary API + Next.js 로 이미지 업로드 자동화 (2 of 2)]]></title><description><![CDATA[기능 추가하기 지난 포스팅에서 언급했다시피 기본으로 제공하는 업로드 기능에서 다음…]]></description><link>https://juheon.dev/react/250124-cloudinary-next-image-uploader-2/</link><guid isPermaLink="false">https://juheon.dev/react/250124-cloudinary-next-image-uploader-2/</guid><pubDate>Fri, 24 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;기능 추가하기&lt;/h2&gt;
&lt;p&gt;지난 포스팅에서 언급했다시피 기본으로 제공하는 업로드 기능에서 다음 5가지 기능을 추가해보고자 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;파일 동시에 여러개 업로드 허용&lt;/li&gt;
&lt;li&gt;업로드 전에 파일 미리보기&lt;/li&gt;
&lt;li&gt;파일명 수정할 수 있도록 하기&lt;/li&gt;
&lt;li&gt;업로드 후 이미지 경로 받아오기&lt;/li&gt;
&lt;li&gt;이미지 경로를 마크다운 문법으로 변환&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;파일 여러개 업로드 / 미리보기 / 파일명 수정하기&lt;/h4&gt;
&lt;p&gt;먼저 1,2,3번의 기능을 구현해보자. 3개의 기능이 모두 연관되어 있으므로 한번에 구현할 것이다. 파일을 업로드 하는 로직들은 &lt;code class=&quot;language-text&quot;&gt;useFileUploader.ts&lt;/code&gt; hook으로 분리하여 작성했다. 이 안에서 로컬 파일을 브라우저에 업로드하는 역할을 담당하는 &lt;code class=&quot;language-text&quot;&gt;handleFileChange&lt;/code&gt; 함수를 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useFileUploader.ts
...
const [files, setFiles] = useState&amp;lt;File[]&amp;gt;([]);
const [previewUrls, setPreviewUrls] = useState&amp;lt;PreviewUrl[]&amp;gt;([]);

const handleFileChange = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; {
  if (!e.target.files) return
  setIsUploaded(false)

  const selectedFiles = Array.from(e.target.files)
  setFiles(selectedFiles)

  const previews: PreviewUrl[] = []
  selectedFiles.forEach(file =&amp;gt; {
    const fileReader = new FileReader()
    fileReader.onloadend = () =&amp;gt; {
      previews.push({
        url: fileReader.result as string,
        name: file.name,
        originalName: file.name,
        isEditing: false,
      })
      if (previews.length === selectedFiles.length) {
        setPreviewUrls(previews)
      }
    }
    fileReader.readAsDataURL(file)
  })
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;파일을 업로드 하기 위해서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;file&quot;&gt;&lt;/code&gt; 태그를 사용하며 &lt;code class=&quot;language-text&quot;&gt;multiple&lt;/code&gt; 속성을 추가하면 여러개의 파일을 동시에 업로드할 수 있다. 그러면 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt; 이벤트 핸들러에서 여러개의 파일을 받아올 수 있다. 이 때 받아온 파일은 &lt;code class=&quot;language-text&quot;&gt;FileList&lt;/code&gt; 는 유사배열 형태의 타입이다.&lt;/p&gt;
&lt;p&gt;원래는 &lt;code class=&quot;language-text&quot;&gt;File&lt;/code&gt; 객체를 &lt;code class=&quot;language-text&quot;&gt;FormData&lt;/code&gt; 에 &lt;code class=&quot;language-text&quot;&gt;append&lt;/code&gt;한 뒤 &lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt; 요청의 &lt;code class=&quot;language-text&quot;&gt;body&lt;/code&gt;에 담아 보내도 업로드되지만, 이번에는 이미지를 업로드 하기 전에 미리보기를 보여주고 파일명을 수정하는 기능을 제공해야 하므로 이미지 파일의 Base64 URL을 따로 뽑아내야 한다.&lt;/p&gt;
&lt;p&gt;일단 &lt;code class=&quot;language-text&quot;&gt;Array.from()&lt;/code&gt; 메서드를 사용하여 배열로 변환하여 &lt;code class=&quot;language-text&quot;&gt;FileList&lt;/code&gt; 타입을 &lt;code class=&quot;language-text&quot;&gt;File[]&lt;/code&gt; 타입으로 변환한다. &lt;code class=&quot;language-text&quot;&gt;File&lt;/code&gt; 타입 자체로는 브라우저에서 이미지 미리보기를 지원하지 않으므로 &lt;code class=&quot;language-text&quot;&gt;FileReader&lt;/code&gt; 객체와 &lt;code class=&quot;language-text&quot;&gt;readAsDataURL()&lt;/code&gt; 메서드를 사용하여 이미지를 Base64 형태의 URL로 뽑아낸다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;FileReader&lt;/code&gt; 객체는 비동기 방식으로 동작하므로 &lt;code class=&quot;language-text&quot;&gt;onloadend&lt;/code&gt; 이벤트 핸들러를 작성한다. 이 때 이미지의 URL을 뽑아내려면 &lt;code class=&quot;language-text&quot;&gt;FileReader.result&lt;/code&gt; 값을 사용한다. 그리고 파일명이 바뀔 수 있음을 염두에 두려면 원본 파일명인 &lt;code class=&quot;language-text&quot;&gt;originalName&lt;/code&gt;와 바뀐 파일명 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 속성을 추가해야 한다. 또한 파일명을 수정할 수 있도록 하기 위해 &lt;code class=&quot;language-text&quot;&gt;isEditing&lt;/code&gt; 속성을 추가했다. 이 값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 라면 수정이 가능하도록 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그를 활성화시킨다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;File[]&lt;/code&gt; 배열을 순회하면서 이 속성들을 &lt;code class=&quot;language-text&quot;&gt;previewUrls&lt;/code&gt; 배열에 하나씩 push 한다. 이 때 모든 파일을 다 읽어왔다면 &lt;code class=&quot;language-text&quot;&gt;setPreviewUrls()&lt;/code&gt; 함수를 호출하여 &lt;code class=&quot;language-text&quot;&gt;previewUrls&lt;/code&gt; 배열을 업데이트한다. &lt;code class=&quot;language-text&quot;&gt;previewUrls&lt;/code&gt; 배열은 &lt;code class=&quot;language-text&quot;&gt;PreviewList&lt;/code&gt; 컴포넌트에서 &lt;code class=&quot;language-text&quot;&gt;prop&lt;/code&gt;으로 받아와 미리보기 이미지를 표시하고 파일명을 수정할 수 있도록 한다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;PreviewList.tsx&lt;/code&gt; 컴포넌트
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// PreviewList.tsx
import type { PreviewUrl } from &amp;quot;./hooks/useFileUploader&amp;quot;

type PreviewListProps = {
  previewUrls: PreviewUrl[]
  setPreviewUrls: React.Dispatch&amp;lt;React.SetStateAction&amp;lt;PreviewUrl[]&amp;gt;&amp;gt;
  startEdit: (index: number) =&amp;gt; void
  confirmEdit: (index: number, newName: string) =&amp;gt; void
  cancelEdit: (index: number) =&amp;gt; void
  handleDeleteFile: (index: number) =&amp;gt; void
  handleDeleteAll: () =&amp;gt; void
  isUploaded: boolean
}

function PreviewList({
  previewUrls,
  setPreviewUrls,
  startEdit,
  confirmEdit,
  cancelEdit,
  handleDeleteFile,
  handleDeleteAll,
  isUploaded,
}: PreviewListProps) {
  const handleNameChange = (fileIndex: number, newValue: string) =&amp;gt; {
    setPreviewUrls(
      previewUrls.map((url, i) =&amp;gt;
        i === fileIndex ? { ...url, name: newValue } : url
      )
    )
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;button type=&amp;quot;button&amp;quot; onClick={handleDeleteAll} disabled={isUploaded}&amp;gt;
          Delete All
        &amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
        {previewUrls.map((preview, index) =&amp;gt; (
          &amp;lt;div key={preview.name}&amp;gt;
            &amp;lt;img src={preview.url} alt={`Preview ${index + 1}`} /&amp;gt;
            &amp;lt;div&amp;gt;
              {preview.isEditing ? (
                &amp;lt;EditMode
                  preview={preview}
                  index={index}
                  handleNameChange={handleNameChange}
                  confirmEdit={confirmEdit}
                  cancelEdit={cancelEdit}
                /&amp;gt;
              ) : (
                &amp;lt;PreviewMode
                  preview={preview}
                  index={index}
                  startEdit={startEdit}
                  handleDeleteFile={handleDeleteFile}
                  isUploaded={isUploaded}
                /&amp;gt;
              )}
            &amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
        ))}
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
...
export default PreviewList&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h4&gt;데모&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737652954/blog/assets/demo1.gif&quot; alt=&quot;preview images&quot;&gt;&lt;/p&gt;
&lt;h4&gt;업로드 후 경로 받아오기 / 마크다운 문법으로 변환&lt;/h4&gt;
&lt;p&gt;API를 호출하여 업로드에 성공하면 응답값으로 업로드 경로인 &lt;code class=&quot;language-text&quot;&gt;secure_url&lt;/code&gt; 을 받을 수 있다. 구글 드라이브와 같은 타 클라우드 플랫폼에서는 공유용 URL로 들어가보면 웹페이지에 에디터 모드가 씌워진 형태라 불편했는데, Cloudinary에서 제공하는 URL은 순수하게 저장된 경로를 알려주므로 편리하다.&lt;/p&gt;
&lt;p&gt;이 경로를 HTML과 마크다운 문법으로 변환하여 클립보드에 복사하는 기능을 추가해보자. 이는 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 객체 중에서 &lt;code class=&quot;language-text&quot;&gt;navigator.clipboard.writeText()&lt;/code&gt; 메서드를 사용하면 된다. (&lt;code class=&quot;language-text&quot;&gt;write()&lt;/code&gt; 메서드를 사용하더라도 무관하다. 차이는 &lt;code class=&quot;language-text&quot;&gt;wrtie()&lt;/code&gt; 메서드는 이미지 같은 다양한 포맷의 파일의 복사를 지원해준다는 점이다.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// CopyButton.tsx
interface CopyButtonProps {
  text: string
  children?: React.ReactNode
  onCopy?: () =&amp;gt; void
}

export default function CopyButton({
  text,
  children,
  onCopy,
}: CopyButtonProps) {
  const handleCopy = async () =&amp;gt; {
    try {
      await navigator.clipboard.writeText(text)
      onCopy?.()
    } catch (error) {
      console.error(&amp;quot;Failed to copy:&amp;quot;, error)
    }
  }

  return (
    &amp;lt;button title={text} onClick={handleCopy}&amp;gt;
      {children || &amp;quot;Copy&amp;quot;}
    &amp;lt;/button&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 이 컴포넌트를 사용하여 버튼을 누르면 클립보드에 복사하는 기능을 추가했다. HTML과 Markdown 문법으로 변환하는 함수는 각각 &lt;code class=&quot;language-text&quot;&gt;convertToHtml()&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;convertToMarkdown()&lt;/code&gt; 함수를 작성했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// UploadResult.tsx
function UploadResult() {
  const convertToHtml = (url: string) =&amp;gt; `&amp;lt;img src=&amp;quot;${url}&amp;quot; alt=&amp;quot;preview images&amp;quot; /&amp;gt;`;
  const convertToMarkdown = (url: string) =&amp;gt; `![preview images](${url})`;
  ...

  return (
    &amp;lt;div&amp;gt;
      ...
      {fileUrls.map((url) =&amp;gt; (
        &amp;lt;div key={url}&amp;gt;
          &amp;lt;img src={url} alt=&amp;#39;preview images&amp;#39;/&amp;gt;
          &amp;lt;CopyButton text={url} onCopy={() =&amp;gt; setCopied(true)}&amp;gt;
            &amp;lt;span&amp;gt;URL&amp;lt;/span&amp;gt;
          &amp;lt;/CopyButton&amp;gt;
          &amp;lt;CopyButton text={convertToHtml(url)} onCopy={() =&amp;gt; setCopied(true)}&amp;gt;
            &amp;lt;span&amp;gt;HTML&amp;lt;/span&amp;gt;
          &amp;lt;/CopyButton&amp;gt;
          &amp;lt;CopyButton text={convertToMarkdown(url)} onCopy={() =&amp;gt; setCopied(true)}&amp;gt;
            &amp;lt;span&amp;gt;Markdown&amp;lt;/span&amp;gt;
          &amp;lt;/CopyButton&amp;gt;
        &amp;lt;/div&amp;gt;
      ))}
    &amp;lt;/div&amp;gt;
  )
}
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;데모&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737653198/blog/assets/demo2.gif&quot; alt=&quot;preview images&quot;&gt;&lt;/p&gt;
&lt;p&gt;내가 원하던대로 파일을 여러개 업로드하고 미리보기를 볼 수 있으며, 파일명을 수정할 수 있고, 업로드 후 이미지 경로를 받아올 수 있으며, 이를 마크다운 문법으로 변환할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;Cloudinary 콘솔에 들어가면 이처럼 내가 업로드한 이미지들을 한번에 확인해볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737696160/blog/assets/result.png&quot; alt=&quot;result&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 프로젝트의 소스코드는 &lt;a href=&quot;https://github.com/hjhj97/next-cloudinary-image-uploader&quot;&gt;Github&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;예외 처리&lt;/h2&gt;
&lt;p&gt;시간이 된다면 다음과 같은 예외 처리도 구현해보고자 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;파일 업로드 실패 처리&lt;/li&gt;
&lt;li&gt;중복되는 파일명 처리&lt;/li&gt;
&lt;li&gt;파일 포맷 검증&lt;/li&gt;
&lt;li&gt;파일 크기 검증&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[Cloudinary API + Next.js 로 이미지 업로드 자동화 (1 of 2)]]></title><description><![CDATA[무엇이 문제인가 현재 개발 블로그에서 사용되는 각종 asset 파일(이미지, 움짤 gif 등)들을 저장하는데 크게 2가지 방식을 사용하고 있다. 각각의 장점과 단점을 가지고 있다.…]]></description><link>https://juheon.dev/react/250123-cloudinary-next-image-uploader-1/</link><guid isPermaLink="false">https://juheon.dev/react/250123-cloudinary-next-image-uploader-1/</guid><pubDate>Thu, 23 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;무엇이 문제인가&lt;/h2&gt;
&lt;p&gt;현재 개발 블로그에서 사용되는 각종 asset 파일(이미지, 움짤 gif 등)들을 저장하는데 크게 2가지 방식을 사용하고 있다. 각각의 장점과 단점을 가지고 있다.&lt;/p&gt;
&lt;h4&gt;1. 레포지토리 자체 저장&lt;/h4&gt;
&lt;p&gt;가장 쉽고 간단한 방법은 개발 블로그 레포지토리(&lt;code class=&quot;language-text&quot;&gt;Gatsby&lt;/code&gt; 기반)에 asset 파일을 그대로 저장하는 것이다. 이 방식의 장점은 내가 Github에 제때 push만 잘 해놓으면 서버에 저장되기 때문에 맥북을 잃어버리더라도 이미지가 유실될 걱정을 하지 않아도 된다. 하지만 치명적인 단점은 이미지를 많이 저장할수록 빌드 결과물의 용량이 점점 커진다는 것이다.&lt;/p&gt;
&lt;p&gt;실제로 포스팅을 36개 작성한 현재 시점에서 프로젝트 빌드한 결과물이 &lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt; 폴더에 담기게 되는데 그 용량이 28.4MB에 달한다. 그 안에서도 asset,폰트 파일이 담겨있는 &lt;code class=&quot;language-text&quot;&gt;static&lt;/code&gt; 파일의 용량이 18MB이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737519985/blog/assets/%08image-size.png&quot; alt=&quot;image-size&quot;&gt;&lt;/p&gt;
&lt;p&gt;결코 작지 않은 용량이다. 앞으로 블로그에 올릴 이미지를 계속 이 방식으로 저장한다면 빌드가 점점 무거워질 것이다. 때문에 1번 방식은 블로그 개설 초창기에 사용하다가 이후에는 아래 설명할 2번 방식을 사용하고 있다.&lt;/p&gt;
&lt;h4&gt;2. Github 임시 업로드&lt;/h4&gt;
&lt;p&gt;2번 방식은 Github의 클라우드 서버를 이용하는 것이다. 물론 Github이 이미지 업로드 클라우드 서비스를 정식으로 제공하지는 않는다. 그래서 약간의 꼼수를 이용할 것이다. (꼼수라고 하기엔 누구나 다 알고 있지만)&lt;/p&gt;
&lt;p&gt;Github에서 commit,issue,PR을 작성할 때 마크다운용 에디터 모드로 전환되는데, 그 때 이미지를 Drag &amp;#x26; Drop 하게 되면 자동으로 이미지가 Github 서버에 저장되며 URL이 담긴 마크다운 문법까지 자동으로 완성해준다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737520954/blog/assets/github-upload.gif&quot; alt=&quot;github-upload&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 방식의 경우 asset을 클라우드 서버에 저장해놓기 때문에 빌드 결과물의 용량에는 영향을 미치지 않는다. 1번 방식의 단점을 해소할 수 있다.&lt;/p&gt;
&lt;p&gt;다만 이 방식도 단점이 존재하는데, 파일을 관리하는 주체가 내가 아닌 Github에게 있다는 점이다. 때문에 Github이 어느 순간 파일을 삭제해버리면 내 입장에서는 이미지를 찾을 수 없게 된다. 또한 구글 드라이브처럼 정식 클라우드 서비스가 아니기 때문에, 파일을 일괄적으로 관리할 수 있는 콘솔 기능은 지원하지 않는다.&lt;/p&gt;
&lt;h2&gt;어떻게 개선할 것인가&lt;/h2&gt;
&lt;p&gt;1번과 2번 방식 모두 장점과 단점이 존재하는데, 단점은 모두 지우고 장점만 모아놓은 서비스를 만드려고 한다.&lt;br&gt;
즉 &apos;&lt;strong&gt;파일을 안전하게 백업&lt;/strong&gt;&apos; + &apos;&lt;strong&gt;클라우드 서버에 저장&lt;/strong&gt;&apos; + &apos;&lt;strong&gt;이미지 업로드 자동화&lt;/strong&gt;&apos;를 챙기고자 하는 것이 목표이다.&lt;/p&gt;
&lt;p&gt;가장 쉽게 생각할 수 있는 방법은 클라우드 서비스를 이용하면 된다. 구글 드라이브, Dropbox, 네이버 MYBOX 등 여러 서비스를 체험해보며 다음 일련의 과정을 직접 테스트 해보았다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이미지 업로드 → 이미지가 저장된 URL 추출 → 마크다운 문법으로 변환&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그런데 생각보다 step의 수가 많아져서 깔끔하지 않았다. 클라우드 서비스에서 제공하는 URL은 실제 데이터가 저장된 경로가 아닌, 클라우드에서 제공하는 공유/에디터 기능이 씌워진 형태로 제공해주는 경우가 대부분이었다.&lt;br&gt;
따라서 개발자도구에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 태그를 찾아 이미지 경로를 추출해야 했는데 이는 너무 번거롭다고 판단했다. 또한 2번 방식처럼 이미지 주소를 곧바로 마크다운 문법으로 변환해주지 않아 내가 직접 변환해야 했다.&lt;/p&gt;
&lt;p&gt;좀 더 개발자 친화적으로 내가 원하는 기능만 커스텀할 수 있는 서비스를 찾다보니 &lt;a href=&quot;https://cloudinary.com/&quot;&gt;Cloudinary&lt;/a&gt;가 있었다. Cloudinary에서는 업로드를 위한 API를 제공해주며 리턴값으로 이미지 경로를 알려주기 때문에 이를 기반으로 마크다운 문법으로 변환해주는 기능을 구현해보기로 했다.&lt;/p&gt;
&lt;p&gt;Cloudinary에서 제공하는 프레임워크별로 보일러 플레이트 &lt;a href=&quot;https://github.com/cloudinary-community/cloudinary-examples&quot;&gt;레포지토리&lt;/a&gt;가 있어 나는 이 중에서 하나를 fork해서 사용하기로 했다. 이 중에는 React/Vue 와 같은 CSR과 Next/Nuxt 와 같은 SSR 프레임워크를 제공하고 있었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloudinary.com/documentation/image_upload_api_reference&quot;&gt;Cloudinary API 문서&lt;/a&gt;를 찾아보면 업로드 API를 호출하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt; 메소드의 &lt;code class=&quot;language-text&quot;&gt;Body&lt;/code&gt; 에 들어가는 파라미터로 &lt;code class=&quot;language-text&quot;&gt;API_KEY&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;API_SECRET&lt;/code&gt;를 기반으로 생성되는 &lt;code class=&quot;language-text&quot;&gt;SIGNATURE&lt;/code&gt; 가 필요하다. CSR 에서는 &lt;code class=&quot;language-text&quot;&gt;API_SECRET&lt;/code&gt;을 환경변수로 넣어서 페이지를 서빙하면 브라우저에 노출될 수밖에 없다. 이는 보안상 취약점이 될 수 있기 때문에 서버에서 실행하여 숨길 수 있는 SSR 프레임워크를 사용하는 것이 좋겠다고 판단했다. 나는 &lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt; 를 사용하기로 했다.&lt;/p&gt;
&lt;p&gt;프로젝트의 보일러 플레이트는 &lt;a href=&quot;https://github.com/cloudinary-community/cloudinary-examples/tree/main/examples/nextjs-upload-formdata&quot;&gt;이곳&lt;/a&gt;에서 fork 해왔다. 서버를 띄우고 본인의 cloudinary 와 연동하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;env.example&lt;/code&gt; 파일에 명시된 환경변수를 설정해주면 된다. 그리고 서버를 띄우면 기본적인 파일 업로드를 할 수 있는 웹페이지가 만들어진다. 이 상태에서는 파일을 하나씩밖에 업로드할 수 없으며, 파일 미리보기도 지원하지 않는다.&lt;/p&gt;
&lt;p&gt;여기서 내가 추가하고 싶은 기능은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;파일 동시에 여러개 업로드 허용&lt;/li&gt;
&lt;li&gt;업로드 전에 파일 미리보기&lt;/li&gt;
&lt;li&gt;파일명 수정할 수 있도록 하기&lt;/li&gt;
&lt;li&gt;업로드 후 이미지 경로 받아오기&lt;/li&gt;
&lt;li&gt;이미지 경로를 마크다운 문법으로 변환&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;구체적으로 어떻게 구현할 것인지는 다음 포스팅에서 다루도록 하겠다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloudinary.com/documentation/image_upload_api_reference&quot;&gt;https://cloudinary.com/documentation/image_upload_api_reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cloudinary-community/cloudinary-examples/tree/main/examples/nextjs-upload-formdata&quot;&gt;https://github.com/cloudinary-community/cloudinary-examples/tree/main/examples/nextjs-upload-formdata&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[2024년 회고]]></title><description><![CDATA[다사다난했던 2024년 2024년 반기 회고 포스팅에서도 언급했다시피…]]></description><link>https://juheon.dev/essay/250121-review-2024/</link><guid isPermaLink="false">https://juheon.dev/essay/250121-review-2024/</guid><pubDate>Tue, 21 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;다사다난했던 2024년&lt;/h2&gt;
&lt;p&gt;2024년 반기 회고 &lt;a href=&quot;https://juheon.dev/essay/240805-2024-first-review/&quot;&gt;포스팅&lt;/a&gt;에서도 언급했다시피 7월에 회사로부터 권고 사직을 통보 받았다. 상당히 착잡한 심정이었다. 내가 인생을 살아가면서 갖고 있는 신조 중 하나는 &apos;세상에 쓸모없는 경험이란 없다&apos;이다. 아무리 힘든 시련일지라도 나중에 돌아보면 그 경험이 나에겐 소중한 자산이 되리라는 믿음이다. 일종의 자기 합리화 수단이라는 건 부정할 수 없지만, 세상이란 원래 내가 예측한 대로만 흘러가지는 않으니깐.&lt;br&gt;
권고사직이란 경험도 결국 인생의 긴 관점에서 본다면 스쳐 지나가는 일에 불과할 일이다. 그러니 너무 흔들리지는 말자고 마음을 다잡았던 기억이 난다.&lt;/p&gt;
&lt;p&gt;아무튼 그 이후 이력서를 정리하고 수많은 회사에 지원을 했다. 그리고 수많은 탈락을 맛보았다. 그 과정에서 내가 무엇이 부족했는지를 되돌아보며 하나씩 채워 나갔다. 면접을 보고난 직후에는 받았던 질문들을 복기하면서 내가 제대로 대답했는지, 대답을 못했던 질문에 대해서는 공부를 통해 채워 나갔다. 그렇게 면접 경험을 쌓아가면서 자신감이 붙었고 합격도 하나 둘 받기 시작했다.&lt;/p&gt;
&lt;p&gt;하지만 번번이 컬쳐핏 면접에서 고배를 마셔야 했다. 그리고 무엇이 문제였을까를 되돌아본다. 기술면접에서의 탈락은 내가 무엇이 부족했는지 어느정도 짐작이 가지만, 컬쳐핏에서는 무엇이 문제였는지 짐작이 어렵다. 내가 무엇을 고쳐야 하는지, 어쩌면 고칠 수 있는 문제일지도 모르겠다. 이렇게 탈락 통보를 받고 나면 멘탈이 너덜너덜해진다. 그러면 한 2-3일은 멘탈을 복구하는 시간을 가져야 한다.&lt;/p&gt;
&lt;p&gt;처음에는 취업 시장이 안 좋아서 그런거야, 시간이 좀 흐르면 나아질거라고 생각했었다. 그렇지만 야속하게도 시간이 흘러도 시장이 나아질 기미는 보이지 않았고 오히려 점점 악화되는 추세였다. 2023년에 이직을 할 때보다도 더 문이 좁아졌다는 것이 체감되었다. 인정하고 싶진 않지만 스스로가 무기력의 늪에 빠져들고 있는 것 같았다. 무기력이 스멀스멀 기어오르려 할 때는 빨리 떨쳐버리려고 애썼다. 집에 박혀있기 싫어서 일부러 밖에 나와서 어디든 돌아다니면 조금은 나아지곤 했다. 무기력의 늪에 빠져서는 안된다고 스스로 되뇌이고 있다.&lt;/p&gt;
&lt;h2&gt;올해 잘한 점/부족한 점&lt;/h2&gt;
&lt;p&gt;이직을 준비하면서 부족한 부분을 공부하는데 많은 시간을 할애했다. 특히 회사에 다니는 동안에는 개발하는데에만 급급하여 타입스크립트, Nuxt, React 등 개념적으로 소홀했던 부분을 채우려고 노력했다.&lt;/p&gt;
&lt;p&gt;무엇보다 가장 중요한 것은 자신의 약점을 객관적으로 파악하고 인정할 수 있어야 한다고 생각한다. 모르는 게 나오면 지레 겁부터 나기 마련이다. 원래 내가 알던 방식을 버리고, 새로운 방식을 택해야 하는 불편한 상황과 마주해야 할 수도 있다. 이 불편함에 익숙해져야 한다.&lt;/p&gt;
&lt;p&gt;2024년에는 내가 무엇에 대해 불편함을 느끼는 지를 파악했다면, 2025년에는 그 불편함을 극복하는 방법을 찾아야 한다. 비단 &apos;개발자&apos;로서 국한된 얘기가 아니라, 앞으로 사회인으로 살아가면서 가져야 할 태도가 되어야 한다. 다시 한번 마음을 다잡아야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[fingerprint.js에 대해 알아보자]]></title><description><![CDATA[fingerprint 기법 fingerprint 기법은 브라우저에서 유저를 식별하는 방법 중 하나로 유저의 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별해준다. 신뢰성을 10…]]></description><link>https://juheon.dev/js_ts/250114-fingerprintjs-deepdive/</link><guid isPermaLink="false">https://juheon.dev/js_ts/250114-fingerprintjs-deepdive/</guid><pubDate>Tue, 14 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;fingerprint 기법&lt;/h2&gt;
&lt;p&gt;fingerprint 기법은 브라우저에서 유저를 식별하는 방법 중 하나로 유저의 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별해준다. 신뢰성을 100% 보장할 수는 없기 때문에 식별에 실패하더라도 큰 지장이 없는 광고 타겟팅을 위한 용도로 사용되곤 한다.&lt;/p&gt;
&lt;p&gt;fingerprint 기법을 구현한 대표적인 오픈소스가 바로 &lt;a href=&quot;https://fingerprint.com/&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;fingerprint.js&lt;/code&gt;&lt;/a&gt;이다. 이 외에도 npmjs에서 찾아보면 여러가지 라이브러리가 존재한다. 이 글에서는 fingerprint.js에 대해 알아보고 어떤 원리로 동작하는지, 어떤 문제가 있는지 알아보고자 한다.&lt;/p&gt;
&lt;p&gt;참고로, &lt;code class=&quot;language-text&quot;&gt;fingerprint.js&lt;/code&gt;와 유료버전인 fingerprint Pro 의 데모 페이지는 &lt;a href=&quot;https://fingerprintjs-vue3-demo.vercel.app/&quot;&gt;이곳&lt;/a&gt;에서 확인할 수 있다.
(유료 버전은 free-trial 기간이 지나면 비활성화 될 수도 있다).&lt;/p&gt;
&lt;h2&gt;어떤 원리로 동작하는가?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;fingerprint.js&lt;/code&gt;는 &lt;a href=&quot;https://github.com/fingerprintjs/fingerprintjs&quot;&gt;github&lt;/a&gt; 에 공개되어 있기 때문에 이를 분석해보며 어떻게 동작하는지 대략적으로 살펴보도록 하자.
공식문서에 나와있는 예시 코드는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import FingerprintJS from &amp;quot;@fingerprintjs/fingerprintjs&amp;quot;
export const getFingerprint = async () =&amp;gt; {
  const fp = await FingerprintJS.load()
  const { visitorId, confidence, components } = await fp.get()
  return { visitorId, confidence, components }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;load&lt;/code&gt; 함수를 통해 유저를 식별하는 함수를 비동기로 실행한 후, &lt;code class=&quot;language-text&quot;&gt;get&lt;/code&gt; 함수를 통해 받아오고 있다. 가장 먼저 프로젝트의 엔트리 포인트인 &lt;code class=&quot;language-text&quot;&gt;/src/index.ts&lt;/code&gt;를 찾아보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/index.ts
import { load, ... } from &amp;#39;./agent&amp;#39;
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;역시나 엔트리 포인트에서 &lt;code class=&quot;language-text&quot;&gt;load&lt;/code&gt; 함수를 찾을 수 있다. 계속해서 &lt;code class=&quot;language-text&quot;&gt;agent.ts&lt;/code&gt; 파일을 찾아보자.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/src/agent.ts&lt;/code&gt; 파일을 찾아보면 &lt;code class=&quot;language-text&quot;&gt;load&lt;/code&gt; 함수를 찾을 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/agent.ts
...
export async function load(
  options: Readonly&amp;lt;LoadOptions&amp;gt; = {}
): Promise&amp;lt;Agent&amp;gt; {
  if ((options as { monitoring?: boolean }).monitoring ?? true) {
    monitor()
  }
  const { delayFallback, debug } = options
  await prepareForSources(delayFallback)
  const getComponents = loadBuiltinSources({ cache: {}, debug })
  return makeAgent(getComponents, debug)
}
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여러가지 처음 보는 함수와 변수들이 등장하여 혼란스럽지만 주목해서 봐야할 것은 &lt;code class=&quot;language-text&quot;&gt;loadBuiltinSources&lt;/code&gt; 함수이다. 이 함수를 통해 브라우저 정보, 운영체제, 화면 해상도, 폰트 등을 조합하여 유저를 식별하게 해준다. &lt;code class=&quot;language-text&quot;&gt;loadBuiltinSources&lt;/code&gt; 함수가 위치해 있는 &lt;code class=&quot;language-text&quot;&gt;/src/sources/index.ts&lt;/code&gt; 파일을 찾아보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/sources/index.ts
...
export default function loadBuiltinSources(options: BuiltinSourceOptions): () =&amp;gt; Promise&amp;lt;BuiltinComponents&amp;gt; {
  return loadSources(sources, options, [])
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;loadBuiltinSources&lt;/code&gt; 함수는 &lt;code class=&quot;language-text&quot;&gt;loadSources&lt;/code&gt; 함수를 호출하고 있다. 첫 번째 인자로 들어가는 &lt;code class=&quot;language-text&quot;&gt;sources&lt;/code&gt; 변수를 주목해서 봐야하는데, 코드의 양이 방대하여 접어놓도록 하겠다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;./src/sources/index.ts&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/sources/index.ts
import getAudioFingerprint from &amp;#39;./audio&amp;#39;
import getFonts from &amp;#39;./fonts&amp;#39;
import getPlugins from &amp;#39;./plugins&amp;#39;
...
// import문 생략

export const sources = {
  fonts: getFonts,
  domBlockers: getDomBlockers,
  fontPreferences: getFontPreferences,
  audio: getAudioFingerprint,
  screenFrame: getScreenFrame,

  canvas: getCanvasFingerprint,
  osCpu: getOsCpu,
  languages: getLanguages,
  colorDepth: getColorDepth,
  deviceMemory: getDeviceMemory,
  screenResolution: getScreenResolution,
  hardwareConcurrency: getHardwareConcurrency,
  timezone: getTimezone,
  sessionStorage: getSessionStorage,
  localStorage: getLocalStorage,
  indexedDB: getIndexedDB,
  openDatabase: getOpenDatabase,
  cpuClass: getCpuClass,
  platform: getPlatform,
  plugins: getPlugins,
  touchSupport: getTouchSupport,
  vendor: getVendor,
  vendorFlavors: getVendorFlavors,
  cookiesEnabled: areCookiesEnabled,
  colorGamut: getColorGamut,
  invertedColors: areColorsInverted,
  forcedColors: areColorsForced,
  monochrome: getMonochromeDepth,
  contrast: getContrastPreference,
  reducedMotion: isMotionReduced,
  reducedTransparency: isTransparencyReduced,
  hdr: isHDR,
  math: getMathFingerprint,
  pdfViewerEnabled: isPdfViewerEnabled,
  architecture: getArchitecture,
  applePay: getApplePayState,
  privateClickMeasurement: getPrivateClickMeasurement,
  audioBaseLatency: getAudioContextBaseLatency,


  webGlBasics: getWebGlBasics,
  webGlExtensions: getWebGlExtensions,
}
...
export default function loadBuiltinSources(
  options: BuiltinSourceOptions
): () =&amp;gt; Promise&amp;lt;BuiltinComponents&amp;gt; {
  return loadSources(sources, options, [])
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;p&gt;보다시피 &lt;code class=&quot;language-text&quot;&gt;sources&lt;/code&gt; 변수 안에는 유저를 식별하기 위한 수많은 파라미터들(함수)로 구성되어 있다. 이 함수들이 &lt;code class=&quot;language-text&quot;&gt;loadSources&lt;/code&gt; 함수를 통해 실행되면서 유저를 식별하는 데이터를 추출하게 된다.&lt;/p&gt;
&lt;p&gt;수많은 파라미터(판별 함수)가 있지만 이 글에서는 가장 대표적인 &apos;설치된 폰트 판별&apos; 과 &apos;Canvas fingerprint&apos; 에 대해 알아보도록 하겠다.&lt;/p&gt;
&lt;h3&gt;설치된 폰트 판별&lt;/h3&gt;
&lt;p&gt;디바이스마다 설치되어있는 폰트의 종류가 다르기 때문에(100%는 아니지만), 이를 통해 디바이스를 식별하려는 아이디어이다.&lt;/p&gt;
&lt;p&gt;그런데 사실 일개 브라우저가 디바이스에 설치되어 있는 폰트 리스트를 갖고 오는 행위는 보안상 문제로 인하여 불가능하다(폰트도 엄연한 시스템 레벨의 데이터다). 하지만 약간의 꼼수를 발휘하면 설치된 폰트를 유추할 수 있는 방법이 있다.&lt;br&gt;
바로 test string을 HTML에 삽입하여 해당 문자열이 차지하는 영역의 &lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt;값을 통해 폰트의 존재 여부를 판단하는 것이다. &lt;strong&gt;폰트의 종류별로 렌더링되는 영역의 크기가 다르기 때문에&lt;/strong&gt;(100%는 아니지만) 이를 통해 특정 폰트의 설치 여부를 판단할 수 있다.&lt;/p&gt;
&lt;p&gt;&apos;A&apos;라는 폰트가 설치되어 있는지 판단한다고 해보자. 만약 &apos;A&apos; 폰트가 설치되어 있지 않다면 디바이스에서 기본으로 설치되어있는 폰트가 설정된다. fingerprint.js에서는 이를 &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt; 라고 부르며 &lt;code class=&quot;language-text&quot;&gt;monospace&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;sans-serif&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;serif&lt;/code&gt; 3종류의 폰트가 있다.&lt;br&gt;
test string을 렌더링한 HTML의 영역이 만약 &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt; 폰트 3종류 중 어느 한개라도 차지하는 영역과 일치한다면 &apos;A&apos; 폰트는 설치되지 않았으며, &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt;가 렌더링된 것으로 간주한다. 반대로 3종류의 &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt; 폰트가 차지하는 영역과 일치하지 않는다면 &apos;A&apos; 폰트가 렌더링(설치)된 것으로 간주한다.&lt;/p&gt;
&lt;p&gt;이 로직을 머리에 담아두고 실제 &lt;a href=&quot;https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/fonts.ts&quot;&gt;소스코드&lt;/a&gt;를 보자. &lt;code class=&quot;language-text&quot;&gt;/src/sources/fonts.ts&lt;/code&gt; 에서 찾을 수 있다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;./src/sources/fonts.ts&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/sources/fonts.ts
// 일부 주석은 삭제함
import { withIframe } from &amp;quot;../utils/dom&amp;quot;

const testString = &amp;quot;mmMwWLliI0O&amp;amp;1&amp;quot;
const textSize = &amp;quot;48px&amp;quot;
const baseFonts = [&amp;quot;monospace&amp;quot;, &amp;quot;sans-serif&amp;quot;, &amp;quot;serif&amp;quot;] as const

const fontList = [
  // This is android-specific font from &amp;quot;Roboto&amp;quot; family
  &amp;quot;sans-serif-thin&amp;quot;,
  &amp;quot;ARNO PRO&amp;quot;,
  &amp;quot;Agency FB&amp;quot;,
  &amp;quot;Arabic Typesetting&amp;quot;,
  &amp;quot;Arial Unicode MS&amp;quot;,
  &amp;quot;AvantGarde Bk BT&amp;quot;,
  &amp;quot;BankGothic Md BT&amp;quot;,
  &amp;quot;Batang&amp;quot;,
  &amp;quot;Bitstream Vera Sans Mono&amp;quot;,
  &amp;quot;Calibri&amp;quot;,
  &amp;quot;Century&amp;quot;,
  &amp;quot;Century Gothic&amp;quot;,
  &amp;quot;Clarendon&amp;quot;,
  &amp;quot;EUROSTILE&amp;quot;,
  &amp;quot;Franklin Gothic&amp;quot;,
  &amp;quot;Futura Bk BT&amp;quot;,
  &amp;quot;Futura Md BT&amp;quot;,
  &amp;quot;GOTHAM&amp;quot;,
  &amp;quot;Gill Sans&amp;quot;,
  &amp;quot;HELV&amp;quot;,
  &amp;quot;Haettenschweiler&amp;quot;,
  &amp;quot;Helvetica Neue&amp;quot;,
  &amp;quot;Humanst521 BT&amp;quot;,
  &amp;quot;Leelawadee&amp;quot;,
  &amp;quot;Letter Gothic&amp;quot;,
  &amp;quot;Levenim MT&amp;quot;,
  &amp;quot;Lucida Bright&amp;quot;,
  &amp;quot;Lucida Sans&amp;quot;,
  &amp;quot;Menlo&amp;quot;,
  &amp;quot;MS Mincho&amp;quot;,
  &amp;quot;MS Outlook&amp;quot;,
  &amp;quot;MS Reference Specialty&amp;quot;,
  &amp;quot;MS UI Gothic&amp;quot;,
  &amp;quot;MT Extra&amp;quot;,
  &amp;quot;MYRIAD PRO&amp;quot;,
  &amp;quot;Marlett&amp;quot;,
  &amp;quot;Meiryo UI&amp;quot;,
  &amp;quot;Microsoft Uighur&amp;quot;,
  &amp;quot;Minion Pro&amp;quot;,
  &amp;quot;Monotype Corsiva&amp;quot;,
  &amp;quot;PMingLiU&amp;quot;,
  &amp;quot;Pristina&amp;quot;,
  &amp;quot;SCRIPTINA&amp;quot;,
  &amp;quot;Segoe UI Light&amp;quot;,
  &amp;quot;Serifa&amp;quot;,
  &amp;quot;SimHei&amp;quot;,
  &amp;quot;Small Fonts&amp;quot;,
  &amp;quot;Staccato222 BT&amp;quot;,
  &amp;quot;TRAJAN PRO&amp;quot;,
  &amp;quot;Univers CE 55 Medium&amp;quot;,
  &amp;quot;Vrinda&amp;quot;,
  &amp;quot;ZWAdobeF&amp;quot;,
] as const

export default function getFonts(): Promise&amp;lt;string[]&amp;gt; {
  return withIframe(async (_, { document }) =&amp;gt; {
    const holder = document.body
    holder.style.fontSize = textSize

    // div to load spans for the default fonts and the fonts to detect
    const spansContainer = document.createElement(&amp;quot;div&amp;quot;)
    spansContainer.style.setProperty(&amp;quot;visibility&amp;quot;, &amp;quot;hidden&amp;quot;, &amp;quot;important&amp;quot;)

    const defaultWidth: Partial&amp;lt;Record&amp;lt;string, number&amp;gt;&amp;gt; = {}
    const defaultHeight: Partial&amp;lt;Record&amp;lt;string, number&amp;gt;&amp;gt; = {}

    // creates a span where the fonts will be loaded
    const createSpan = (fontFamily: string) =&amp;gt; {
      const span = document.createElement(&amp;quot;span&amp;quot;)
      const { style } = span
      style.position = &amp;quot;absolute&amp;quot;
      style.top = &amp;quot;0&amp;quot;
      style.left = &amp;quot;0&amp;quot;
      style.fontFamily = fontFamily
      span.textContent = testString
      spansContainer.appendChild(span)
      return span
    }

    // creates a span and load the font to detect and a base font for fallback
    const createSpanWithFonts = (fontToDetect: string, baseFont: string) =&amp;gt; {
      return createSpan(`&amp;#39;${fontToDetect}&amp;#39;,${baseFont}`)
    }

    // creates spans for the base fonts and adds them to baseFontsDiv
    const initializeBaseFontsSpans = () =&amp;gt; {
      return baseFonts.map(createSpan)
    }

    // creates spans for the fonts to detect and adds them to fontsDiv
    const initializeFontsSpans = () =&amp;gt; {
      // Stores {fontName : [spans for that font]}
      const spans: Record&amp;lt;string, HTMLSpanElement[]&amp;gt; = {}

      for (const font of fontList) {
        spans[font] = baseFonts.map(baseFont =&amp;gt;
          createSpanWithFonts(font, baseFont)
        )
      }

      return spans
    }

    // checks if a font is available
    const isFontAvailable = (fontSpans: HTMLElement[]) =&amp;gt; {
      return baseFonts.some(
        (baseFont, baseFontIndex) =&amp;gt;
          fontSpans[baseFontIndex].offsetWidth !== defaultWidth[baseFont] ||
          fontSpans[baseFontIndex].offsetHeight !== defaultHeight[baseFont]
      )
    }

    // create spans for base fonts
    const baseFontsSpans = initializeBaseFontsSpans()

    // create spans for fonts to detect
    const fontsSpans = initializeFontsSpans()

    // add all the spans to the DOM
    holder.appendChild(spansContainer)

    // get the default width for the three base fonts
    for (let index = 0; index &amp;lt; baseFonts.length; index++) {
      defaultWidth[baseFonts[index]] = baseFontsSpans[index].offsetWidth
      defaultHeight[baseFonts[index]] = baseFontsSpans[index].offsetHeight
    }

    // check available fonts
    return fontList.filter(font =&amp;gt; isFontAvailable(fontsSpans[font]))
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;br /&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;fontList&lt;/code&gt; 배열에 들어있는 폰트의 종류를 &lt;code class=&quot;language-text&quot;&gt;testString&lt;/code&gt; 문자열로 렌더링하여 &lt;code class=&quot;language-text&quot;&gt;width&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt;를 측정한다.&lt;br&gt;
그리고 &lt;code class=&quot;language-text&quot;&gt;isFontAvailable&lt;/code&gt;함수에서 이 측정값이 &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt; 배열에 들어있는 폰트들의 &lt;code class=&quot;language-text&quot;&gt;defaultWidth&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;defaultHeight&lt;/code&gt;와 하나라도 일치하지 않으면 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;를 반환하여 해당 폰트는 설치된 것으로 간주한다.&lt;br&gt;
만약 폰트가 설치되어 있지 않다면 &lt;code class=&quot;language-text&quot;&gt;baseFonts&lt;/code&gt;에 들어있는 폰트들의 &lt;code class=&quot;language-text&quot;&gt;defaultWidth&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;defaultHeight&lt;/code&gt;가 모두 일치할 것이므로 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;를 반환할 것이다.&lt;/p&gt;
&lt;p&gt;코드를 살펴보면 가질 수 있는 의문점이 하나 있다. HTML상에서 &lt;code class=&quot;language-text&quot;&gt;testString&lt;/code&gt; 이 렌더링 된다면 실제 사용자 눈에 직접 보일 수도 있지 않느냐 하는 점이다.&lt;br&gt;
이를 방지해주는 함수가 &lt;code class=&quot;language-text&quot;&gt;withIframe&lt;/code&gt; 함수이다. 이 함수는 외부 스크립트를 실행하는 것이 아닌 &lt;code class=&quot;language-text&quot;&gt;iframe&lt;/code&gt; 내부에서 실행하여 외부 HTML에는 영향을 받지 않도록 해준다. &lt;code class=&quot;language-text&quot;&gt;getFonts&lt;/code&gt; 함수의 리턴값도 &lt;code class=&quot;language-text&quot;&gt;withIframe&lt;/code&gt; 함수를 통해 실행되므로 실제 사용자 눈에 보이지 않는다.&lt;/p&gt;
&lt;p&gt;이 방법의 장점 중 하나는 &lt;strong&gt;브라우저의 종류에 영향을 받지 않는다&lt;/strong&gt;는 점이다. 아래 첨부한 이미지는 위에서부터 Chrome, Safari, Firefox 브라우저에서 내가 직접 개발하여 출시한 &lt;code class=&quot;language-text&quot;&gt;font-fingerprint&lt;/code&gt; &lt;a href=&quot;https://github.com/hjhj97/font-fingerprint&quot;&gt;패키지&lt;/a&gt;를 각각 실행한 결과이다. 보다시피 모든 브라우저에서 동일한 &lt;code class=&quot;language-text&quot;&gt;Visitor ID&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;font&lt;/code&gt; 값이 나오고 있음을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737987532/blog/assets/demo.png&quot; alt=&quot;font-fingerprint&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hjhj97.github.io/font-fingerprint/&quot;&gt;데모 페이지&lt;/a&gt;는 이곳에서 확인해볼 수 있다.&lt;/p&gt;
&lt;p&gt;두 번째 방법인 Canvas fingerprint 에서도 언급하겠지만, 일부 fingerprint 에서 사용하는 파라미터는 같은 디바이스에서도 브라우저의 종류에 따라 결과값이 달라지기 때문에, 이로 인한 영향을 받지 않기 위해서는 설치된 폰트 리스트로만 판단하는 것이 좋다.&lt;/p&gt;
&lt;h3&gt;Canvas fingerprint&lt;/h3&gt;
&lt;p&gt;Canvas fingerprint는 브라우저의 Canvas API를 통해 캔버스를 그리는 방식을 판별하는 기법이다. 캔버스에 동일한 geometry를 그리더라도 브라우저의 종류, GPU 등에 따라서 픽셀 단위에서는 다르게 그려질 수 있다.&lt;/p&gt;
&lt;p&gt;fingerprint.js에서는 크게 &lt;code class=&quot;language-text&quot;&gt;renderTextImage&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;renderGeometryImage&lt;/code&gt; 2가지 함수를 통해 판별하고 있다. 이를 담당하고 있는 &lt;a href=&quot;https://github.com/fingerprintjs/fingerprintjs/blob/master/src/sources/canvas.ts&quot;&gt;소스코드&lt;/a&gt;는 &lt;code class=&quot;language-text&quot;&gt;/src/sources/canvas.ts&lt;/code&gt; 파일이다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;./src/sources/canvas.ts&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /src/sources/canvas.ts
// 일부 주석 제거
import { isSafariWebKit, isWebKit, isWebKit616OrNewer } from &amp;quot;../utils/browser&amp;quot;

export interface CanvasFingerprint {
  winding: boolean
  geometry: string
  text: string
}

export const enum ImageStatus {
  Unsupported = &amp;quot;unsupported&amp;quot;,
  Skipped = &amp;quot;skipped&amp;quot;,
  Unstable = &amp;quot;unstable&amp;quot;,
}

export default function getCanvasFingerprint(): CanvasFingerprint {
  return getUnstableCanvasFingerprint(doesBrowserPerformAntifingerprinting())
}

export function getUnstableCanvasFingerprint(
  skipImages?: boolean
): CanvasFingerprint {
  let winding = false
  let geometry: string
  let text: string

  const [canvas, context] = makeCanvasContext()
  if (!isSupported(canvas, context)) {
    geometry = text = ImageStatus.Unsupported
  } else {
    winding = doesSupportWinding(context)

    if (skipImages) {
      geometry = text = ImageStatus.Skipped
    } else {
      ;[geometry, text] = renderImages(canvas, context)
    }
  }

  return { winding, geometry, text }
}

function makeCanvasContext() {
  const canvas = document.createElement(&amp;quot;canvas&amp;quot;)
  canvas.width = 1
  canvas.height = 1
  return [canvas, canvas.getContext(&amp;quot;2d&amp;quot;)] as const
}

function isSupported(
  canvas: HTMLCanvasElement,
  context?: CanvasRenderingContext2D | null
): context is CanvasRenderingContext2D {
  return !!(context &amp;amp;&amp;amp; canvas.toDataURL)
}

function doesSupportWinding(context: CanvasRenderingContext2D) {
  context.rect(0, 0, 10, 10)
  context.rect(2, 2, 6, 6)
  return !context.isPointInPath(5, 5, &amp;quot;evenodd&amp;quot;)
}

function renderImages(
  canvas: HTMLCanvasElement,
  context: CanvasRenderingContext2D
): [geometry: string, text: string] {
  renderTextImage(canvas, context)
  const textImage1 = canvasToString(canvas)
  const textImage2 = canvasToString(canvas)

  if (textImage1 !== textImage2) {
    return [ImageStatus.Unstable, ImageStatus.Unstable]
  }

  renderGeometryImage(canvas, context)
  const geometryImage = canvasToString(canvas)
  return [geometryImage, textImage1]
}

function renderTextImage(
  canvas: HTMLCanvasElement,
  context: CanvasRenderingContext2D
) {
  canvas.width = 240
  canvas.height = 60

  context.textBaseline = &amp;quot;alphabetic&amp;quot;
  context.fillStyle = &amp;quot;#f60&amp;quot;
  context.fillRect(100, 1, 62, 20)

  context.fillStyle = &amp;quot;#069&amp;quot;
  context.font = &amp;#39;11pt &amp;quot;Times New Roman&amp;quot;&amp;#39;
  const printedText = `Cwm fjordbank gly ${
    String.fromCharCode(55357, 56835) /* 😃 */
  }`
  context.fillText(printedText, 2, 15)
  context.fillStyle = &amp;quot;rgba(102, 204, 0, 0.2)&amp;quot;
  context.font = &amp;quot;18pt Arial&amp;quot;
  context.fillText(printedText, 4, 45)
}

function renderGeometryImage(
  canvas: HTMLCanvasElement,
  context: CanvasRenderingContext2D
) {
  canvas.width = 122
  canvas.height = 110
  context.globalCompositeOperation = &amp;quot;multiply&amp;quot;
  for (const [color, x, y] of [
    [&amp;quot;#f2f&amp;quot;, 40, 40],
    [&amp;quot;#2ff&amp;quot;, 80, 40],
    [&amp;quot;#ff2&amp;quot;, 60, 80],
  ] as const) {
    context.fillStyle = color
    context.beginPath()
    context.arc(x, y, 40, 0, Math.PI * 2, true)
    context.closePath()
    context.fill()
  }

  context.fillStyle = &amp;quot;#f9c&amp;quot;
  context.arc(60, 60, 60, 0, Math.PI * 2, true)
  context.arc(60, 60, 20, 0, Math.PI * 2, true)
  context.fill(&amp;quot;evenodd&amp;quot;)
}

function canvasToString(canvas: HTMLCanvasElement) {
  return canvas.toDataURL()
}

function doesBrowserPerformAntifingerprinting() {
  // Safari 17
  return isWebKit() &amp;amp;&amp;amp; isWebKit616OrNewer() &amp;amp;&amp;amp; isSafariWebKit()
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;br /&gt;
&lt;p&gt;canvas를 그리기에 앞서 유저의 환경에서 canvas API를 지원하는지부터 판단한다.&lt;/p&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;doesBrowserPerformAntifingerprinting&lt;/code&gt; 함수는 브라우저가 fingerprint 를 차단하는지 판단한다. 함수 내부를 살펴보면 &lt;code class=&quot;language-text&quot;&gt;webkit&lt;/code&gt; 환경으로 이뤄져있는 safari 17버전 이상의 브라우저에서는 해당 조건을 만족하기 때문에 &lt;code class=&quot;language-text&quot;&gt;ImageStatus&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;Skipped&lt;/code&gt; 로 설정된다.&lt;/p&gt;
&lt;p&gt;그런 다음 &lt;code class=&quot;language-text&quot;&gt;isSupported&lt;/code&gt; 함수를 통해서 &lt;code class=&quot;language-text&quot;&gt;document&lt;/code&gt; 객체에서 &lt;code class=&quot;language-text&quot;&gt;canvas&lt;/code&gt; 엘리먼트를 생성해주는지를 판단한다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;doesSupportWinding&lt;/code&gt; 함수를 통해서 브라우저가 캔버스를 그리는 방식을 판단한다. &lt;code class=&quot;language-text&quot;&gt;Winding&lt;/code&gt;이란 canvas에서 경로의 내부와 외부를 정의하는 방식으로, 구형 브라우저에서는 지원하지 않을 수도 있는 속성이라고 한다.&lt;/p&gt;
&lt;p&gt;이제 본격적으로 canvas위에 그려보도록 하자.&lt;code class=&quot;language-text&quot;&gt;renderTextImage&lt;/code&gt; 함수를 살펴보면 다음과 같은 과정이 일어난다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캔버스의 크기를 240x60으로 설정한다.&lt;/li&gt;
&lt;li&gt;캔버스의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textBaseline&quot;&gt;textBaseline&lt;/a&gt;을 &lt;code class=&quot;language-text&quot;&gt;alphabetic&lt;/code&gt;로 설정한다.&lt;/li&gt;
&lt;li&gt;직사각형을 그리고 색상을 &lt;code class=&quot;language-text&quot;&gt;#f60&lt;/code&gt;으로 색칠한다.&lt;/li&gt;
&lt;li&gt;폰트의 크기,종류,색상을 설정하고 &lt;code class=&quot;language-text&quot;&gt;printedText&lt;/code&gt; 문자열을 캔버스에 그린다. 문자열 맨 끝에는 이모지를 붙인다.&lt;/li&gt;
&lt;li&gt;이후에 비슷한 과정을 한번 더 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일련의 과정을 거치고 나면 아래와 같은 이미지가 캔버스에 그려진다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983309/blog/assets/4d1c7159-9a23-4473-a039-7bfe3375bf2c_zjexik.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;캔버스에 그려진 이미지를 &lt;code class=&quot;language-text&quot;&gt;canvasToString&lt;/code&gt; 함수 안에 &lt;code class=&quot;language-text&quot;&gt;canvas.toDataURL&lt;/code&gt; 함수를 통해 Base64 형태의 문자열로 변환한다. 내가 직접 크롬과 firefox 브라우저에서 각각 테스트해본 결과, 렌더링되는 이미지가 육안상으로는 동일하였으나 실제로 Base64로 인코딩된 데이터는 각기 다르게 나왔다.&lt;br&gt;
찾아보니 동일한 canvas 코드라도 실행한 브라우저의 종류에 따라서 폰트 렌더링, 안티앨리어싱 등에 따라서 결과값이 달라질 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;다음으로 &lt;code class=&quot;language-text&quot;&gt;renderGeometryImage&lt;/code&gt; 함수를 살펴보면 다음과 같은 과정이 일어난다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캔버스의 크기를 122x110으로 설정한다.&lt;/li&gt;
&lt;li&gt;3종류의 색상을 가진 원을 일부가 겹치도록 그려놓는다.(벤다이어그램처럼)&lt;/li&gt;
&lt;li&gt;큰 원과 작은원을 다시 겹쳐놓는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 과정을 거치면 아래와 같은 이미지가 캔버스에 그려진다.&lt;/p&gt;
&lt;div&gt;
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/35fca6b5-e801-4940-b341-cd2277f8bc41_glhkux.png&quot; alt=&quot;canvas-text-image&quot; style=&quot;width: 240px&quot;&gt;
&lt;/div&gt;
&lt;p&gt;과정을 통해 &apos;브라우저가 원을 처리하는 방식&apos;과 각기 다른 색상이 겹쳤을 때 &apos;색의 혼합을 어떻게 처리하는지&apos;를 판단하게 된다. 이 또한 브라우저의 종류에 따라 결과값이 달라질 수 있다.&lt;/p&gt;
&lt;h2&gt;어떤 문제(한계)가 있는가?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;fingerprint.js&lt;/code&gt;의 가장 큰 한계(단점)은 바로 신뢰성이다.&lt;br&gt;
공식문서나 레퍼런스/커뮤니티에서 말하는 fingerprint 기법의 신뢰도는 40~60% 라고 한다. fingerprint의 가장 이상적인 목표는 컴퓨터(혹은 스마트폰)을 사용하고 있는 유저가 이전에 접속한 사람과 동일인물인지 아닌지를 식별하는 것이다.&lt;/p&gt;
&lt;p&gt;하지만 위 2가지 판별함수에서 살펴보았다시피, 동일한 디바이스라 할지라도 브라우저의 종류에 따라 결과값이 달라질 수 있다. 즉 사용자가 마음만 먹으면 브라우저의 종류를 바꿈으로써 판별을 우회할 수 있다.&lt;br&gt;
실제 npm에는 fingerprint-injector 와 같이 접속한 환경을 의도적으로 조작할 수 있는 패키지도 이미 출시되어있다. 뿐만 아니라 브라우저의 종류뿐만 아니라 화면의 해상도에 영향받기도 하며, 폰트를 새로 설치하거나 삭제하더라도 식별값이 달라질 수 있다.&lt;/p&gt;
&lt;p&gt;때문에 fingerprint.js의 유료 버전인 fingerprint Pro 에서는 신뢰도를 99%까지 끌어올려서 제공하고 있다. Pro 버전이 신뢰도가 높은 이유는 식별값을 클라이언트(브라우저)가 아닌 서버에서 생성하기 때문이다. 자세한 차이점은 &lt;a href=&quot;https://github.com/fingerprintjs/fingerprintjs/blob/master/docs/comparison.md&quot;&gt;이곳&lt;/a&gt;에서 확인해볼 수 있다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hovav.net/ucsd/dist/canvas.pdf&quot;&gt;https://hovav.net/ucsd/dist/canvas.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fingerprintjs/fingerprintjs&quot;&gt;https://github.com/fingerprintjs/fingerprintjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.gmarket.com/94&quot;&gt;https://dev.gmarket.com/94&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.fingerprint.com/docs/introduction#fingerprint-identification-vs-fingerprintjs&quot;&gt;https://dev.fingerprint.com/docs/introduction#fingerprint-identification-vs-fingerprintjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Vue에서 한글을 입력할 때 생기는 2가지 이슈]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/vue/250106-vue-korean-input/</link><guid isPermaLink="false">https://juheon.dev/vue/250106-vue-korean-input/</guid><pubDate>Mon, 06 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;문제의 원인&lt;/h2&gt;
&lt;p&gt;한글은 영어와 같은 언어와 달리 조합형 언어이기 때문에 글자를 입력할 때 조합이 완성되기 전까지는 글자가 화면에 표시되지 않는다. 이러한 특성 때문에 한글 입력 시 몇 가지 이슈가 존재한다.&lt;/p&gt;
&lt;p&gt;예를 들어 사용자가 &lt;code class=&quot;language-text&quot;&gt;안전&lt;/code&gt; 이라는 글자를 입력하려는 상황을 가정해보자.&lt;br&gt;
사용자는 키보드로 &lt;code class=&quot;language-text&quot;&gt;&apos;ㅇ&apos;&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅏ&apos;&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㄴ&apos;&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅈ&apos;&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅓ&apos;&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㄴ&apos;&lt;/code&gt; 순으로 총 6번을 입력할 것이다. 설명상 편의를 위해 &lt;code class=&quot;language-text&quot;&gt;&apos;ㅇ&apos;(1)&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅏ&apos;(2)&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㄴ&apos;(3)&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅈ&apos;(4)&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㅓ&apos;(5)&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;&apos;ㄴ&apos;(6)&lt;/code&gt; 으로 인덱싱을 매겨보자.&lt;/p&gt;
&lt;p&gt;컴퓨터 입장에서는 2번째 입력까지는 &lt;code class=&quot;language-text&quot;&gt;아&lt;/code&gt; 라는 글자 조합이 완성된 상태이다. 여기서 3번째 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;이 들어왔을 때 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;을 현재 글자(&lt;code class=&quot;language-text&quot;&gt;아&lt;/code&gt;)의 받침(종성)으로 간주할 것인지, 다음 글자의 초성으로 간주할 것인지 알 수 없다는 문제가 생긴다. 이 때문에 우선 임시로 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;을 받침으로 넣어두고(&lt;code class=&quot;language-text&quot;&gt;안&lt;/code&gt;), 4번째 글자의 입력에 따라 어떻게 처리할지 결정하게 된다.&lt;/p&gt;
&lt;p&gt;4번째 글자는 &lt;code class=&quot;language-text&quot;&gt;ㅈ&lt;/code&gt;이다. 이로써 3번째 글자인 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;은 받침으로 처리하는 것은 확정되었다. 만약 &lt;code class=&quot;language-text&quot;&gt;ㅈ&lt;/code&gt;이 아닌 모음이 입력되었다면 &lt;code class=&quot;language-text&quot;&gt;안&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;은 받침이 아닌, 다음 글자의 초성으로 처리될 것이다.&lt;br&gt;
하지만 여전히 &lt;code class=&quot;language-text&quot;&gt;ㅈ&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;ㄴ&lt;/code&gt;과 결합하여 &lt;code class=&quot;language-text&quot;&gt;ㄵ&lt;/code&gt; 이라는 받침으로 처리될 여지가 있다. 따라서 4번째 입력까지도 &lt;code class=&quot;language-text&quot;&gt;앉&lt;/code&gt;일지, &lt;code class=&quot;language-text&quot;&gt;안ㅈ&lt;/code&gt;일지 알 수 없는 상태이며 5번째 글자의 종류에 의존적이게 된다. 자음이 온다면 &lt;code class=&quot;language-text&quot;&gt;앉&lt;/code&gt;으로, 모음이 온다면 &lt;code class=&quot;language-text&quot;&gt;안ㅈ&lt;/code&gt;로 처리될 것이다.&lt;/p&gt;
&lt;p&gt;5번째 입력으로 모음인 &lt;code class=&quot;language-text&quot;&gt;ㅓ&lt;/code&gt;을 받음으로써 비로소 4번째 글자&lt;code class=&quot;language-text&quot;&gt;ㅈ&lt;/code&gt;은 첫 글자의 &lt;code class=&quot;language-text&quot;&gt;ㄵ&lt;/code&gt; 받침이 아닌 다음 글자의 초성(&lt;code class=&quot;language-text&quot;&gt;안저&lt;/code&gt;)으로서 처리될 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;이처럼 &lt;strong&gt;&lt;em&gt;한글은 입력 당시에는 글자의 조합을 확신할 수 없으며, 뒤따르는 글자 입력에 의존적&lt;/em&gt;&lt;/strong&gt; 이라는 특성을 지니고 있다. 키보드에 있는 자판의 수보다 입력해야하는 글자의 종류가 많은 경우에 이러한 문제가 발생하게 되며, 이를 해결하기 위한 방법을 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9E%85%EB%A0%A5%EA%B8%B0&quot;&gt;IME(Input Method Editor)&lt;/a&gt; 라고 한다.&lt;/p&gt;
&lt;h2&gt;이로 인한 현상&lt;/h2&gt;
&lt;p&gt;IME 문제로 인하여 Vue(자바스크립트)에서는 아래와 같은 2가지 상황이 발생하게 된다.&lt;/p&gt;
&lt;h3&gt;1. 글자의 조합이 완성되기 전까지 JS에 반영되지 않음&lt;/h3&gt;
&lt;p&gt;Vue에서 제공하는 양방향 바인딩 디렉티브 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 사용할 때 문제가 발생한다.&lt;br&gt;
위에서 살펴본 사례처럼 4번째 입력(&lt;code class=&quot;language-text&quot;&gt;ㅈ&lt;/code&gt;)까지도 조합을 확신할 수 없다. 이처럼 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;에서는 조합을 확신할 수 없는 상태에서는 글자를 반영하지 않으며, 5번째 입력이 들어와 첫 글자가 확정되는 순간에야 비로소 글자를 반영하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983309/blog/assets/2babad70-e2ce-4464-9f46-5b6855f2bd19_upty1b.gif&quot; alt=&quot;vmodel&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 영상에서 보다시피 &lt;code class=&quot;language-text&quot;&gt;앉&lt;/code&gt; 을 입력할 때까지도 글자의 조합을 확신할 수 없는 상태이기 때문에 데이터가 화면에 반영되지 않는다. 5번째 글자인 &lt;code class=&quot;language-text&quot;&gt;ㅓ&lt;/code&gt; 입력되는 순간에 비로소 화면에 반영된다.&lt;/p&gt;
&lt;h3&gt;2. &lt;code class=&quot;language-text&quot;&gt;maxlength&lt;/code&gt; 속성에서 마지막 글자가 넘침&lt;/h3&gt;
&lt;p&gt;2번째 현상은 현재 입력 중인 글자(=조합이 확정되지 않는 글자)는 &lt;code class=&quot;language-text&quot;&gt;length&lt;/code&gt; 로 카운트하지 않는다는 것이다. 때문에 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그에서 &lt;code class=&quot;language-text&quot;&gt;maxlength&lt;/code&gt; 값을 설정해놓으면 마지막 한 글자가 넘쳐 보이는 현상이 발생한다. 해당 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;focus&lt;/code&gt; 가 해제되면 정상적으로 돌아오지만 사용자 입장에서는 버그라고 느낄 여지가 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/d9ad8b41-fb62-4469-a1bd-0f278b6d13f4_wtewak.gif&quot; alt=&quot;vmodel2&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 영상에서 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그에 &lt;code class=&quot;language-text&quot;&gt;maxlength=2&lt;/code&gt; 속성을 설정해놓았다. 따라서 정확히 2글자만 입력되기를 기대하지만 실제로는 3글자가 입력되는 것처럼 보이고 있다.&lt;/p&gt;
&lt;p&gt;이 현상의 원인이 IME 의 영향도 있지만, 구글링을 해보니 유니코드로 인한 문제일 수도 있자는 &lt;a href=&quot;https://mygumi.tistory.com/398&quot;&gt;블로그 포스팅&lt;/a&gt;을 찾을 수 있었다. 알파벳과 같은 영어 문자는 유니코드상에서 1바이트로 처리되지만, 한글과 같은 복합 문자는 2바이트로 처리되기 때문에 이러한 현상이 발생하는 것으로 보인다.&lt;/p&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;위 2가지 문제를 해결하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 디렉티브를 사용하지 않고 직접 이벤트를 받아 처리해야만 한다. 이는 내가 예전에 작성한 &lt;a href=&quot;https://juheon.dev/vue/230701-vmodel-and-custom-component-1/&quot;&gt;포스팅&lt;/a&gt;에서 다룬 적이 있다. 당시에는 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 받고, &lt;code class=&quot;language-text&quot;&gt;update:modelValue&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt; 하는 방식으로 처리했었다.&lt;br&gt;
이 방법도 여전히 유효하지만 이번에는 &lt;code class=&quot;language-text&quot;&gt;Vue&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;3.4&lt;/code&gt; 버전부터 제공되는 &lt;code class=&quot;language-text&quot;&gt;defineModel&lt;/code&gt; 을 사용하여 해결해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const model = defineModel&amp;lt;string&amp;gt;({ default: &amp;quot;&amp;quot; })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.vuejs.org/api/sfc-script-setup.html#definemodel&quot;&gt;공식문서&lt;/a&gt;의 설명에 따르면 &quot;&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 을 통해 사용될 수 있는 양방향 바인딩 &lt;code class=&quot;language-text&quot;&gt;prop&lt;/code&gt;을 선언하는 데 사용될 수 있습니다. 내부적으로, 이 매크로는 모델 &lt;code class=&quot;language-text&quot;&gt;prop&lt;/code&gt;과 해당하는 값 업데이트 이벤트를 선언합니다.&quot; 라고 한다.&lt;br&gt;
즉 번거롭게 &lt;code class=&quot;language-text&quot;&gt;prop&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;을 선언할 필요 없이, &lt;code class=&quot;language-text&quot;&gt;model&lt;/code&gt; 변수를 직접 조작하면 부모 컴포넌트에서 내려온 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 이 자동으로 반영된다는 것이다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
  소스 코드
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Parent.vue
&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
const MAX_LENGTH = 2;
const msg = ref(&amp;quot;&amp;quot;)
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;MyInput v-model=&amp;quot;msg&amp;quot; /&amp;gt;
  &amp;lt;p&amp;gt;{{msg.length}} / {{MAX_LENGTH}}&amp;lt;/p&amp;gt;
  &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// MyInput.vue
&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
const model = defineModel&amp;lt;string&amp;gt;({default : &amp;quot;&amp;quot;})
const handleInput = (e : Event) =&amp;gt; {
    const newValue = e.target!.value
    model.value = newValue;
}
const handleSubmit = () =&amp;gt; {
    alert(model.value)
}
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
    &amp;lt;form @submit.prevent=handleSubmit&amp;gt;
        &amp;lt;input :value=&amp;quot;model&amp;quot; @input=&amp;quot;handleInput($event)&amp;quot; /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Submit&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;br /&gt;
&lt;p&gt;이렇게 하면 첫 번째 문제는 해결되었지만 두 번째 문제였던 &lt;code class=&quot;language-text&quot;&gt;maxlength&lt;/code&gt; 속성에서 마지막 글자가 넘침 현상은 여전히 발생한다. 이를 해결하기 위해선 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;를 사용하여 &lt;code class=&quot;language-text&quot;&gt;model&lt;/code&gt; 문자열의 길이를 체크하고, 제한 길이를 초과할 경우 &lt;code class=&quot;language-text&quot;&gt;substring&lt;/code&gt; 함수를 사용하여 자르면 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/ce934d25-cc0b-4f07-bde5-506e338f1bb3_qd1lnc.gif&quot; alt=&quot;custom2&quot;&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
  소스 코드
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// MyInput.vue
&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
const model = defineModel&amp;lt;string&amp;gt;({default : &amp;quot;&amp;quot;})
const attrs = useAttrs();
const MAX_LENGTH = Number(attrs.maxlength ?? Infinity)

const handleInput = (e : Event) =&amp;gt; {
    const newValue = e.target!.value
    model.value = newValue;
}
const handleSubmit = () =&amp;gt; {
    alert(model.value)
}
watch(model, ()=&amp;gt;{
  if(!model.value)  return;
  if(model.value.length &amp;gt; MAX_LENGTH){
    model.value = model.value.substring(0,MAX_LENGTH)
  }
})
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
    &amp;lt;form @submit.prevent=handleSubmit&amp;gt;
        &amp;lt;input :value=&amp;quot;model&amp;quot; @input=&amp;quot;handleInput($event)&amp;quot; :maxlength=&amp;quot;MAX_LENGTH&amp;quot; /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Submit&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;Demo&lt;/h3&gt;
&lt;iframe src=&quot;https://play.vuejs.org/#eNqdVG1r20AM/ivqMagDib23T5njtuvC1rF2Yy1jHwzDSc6JO/ts7iVNMf7v0+ns5AKjlPqTT3p0zyOdpJZdNE24NZxNWayWsmg0KK5NA2Um1rOUaZWyJBVF1dRSw/XjlWiMhlzWFZyGUX+2F5zuQS1InkPXg5wrFctaKLzg4vefb/Obz3dfYAZvPwzmSq3xjGFBylI2svg4cnKQHA+aV02ZaU4ngPhkMoF4VWzxDPjFmzfJJ55nptSwnVT1ipdxhLbeW5Do3oFJIV3KYFplu5KLtd6g6SAMPREFxpElgMmETmQ5Zrw0SmOK8y0X2qcbqvQywoGMLE3SthgcurCugwja9hDadXHUuFikJ6g19VJsEb3CsTG+JtY7L9bhvaoFPnlLMLasq6Youfze6ALfI2VTII/1ZWVZP3wlm5aGjwf7csOXf/9jv1c7a0vZD8kVl1uesr1PZ3LNtXPPb2/4Dv/3TqyVKRH9hPMnV3VprEYH+2jECmV7OFJ7RX1YiPWdmu80F2pIygq1yI7wKcPevHwi9YPcd+F7iktFh1X0uv55Y9OCUfxCa6nG8JDp5eZoOnAK9nNg+wUnYcXzQvBr6mOlJaaSBC0aqcFt5inrcEpcUGYvxqCBIxjt5+po3G5MteAyIHi4b0U4O4Mr7AlR6EcaPBe5yWxpXR/PIODISn0+glkyVMghBX/4lZWGI4yHrmQn4dZaHIpycgaEDGiUiNU8Zrs1i6ogOp8lw9fRgXcLqqRQqqRzjDFkllBAkQcnPhhwrWgjBRKS0/P1UwWJV6dRz3qs2g9SZuGeJHg99uKG/qAaHq0vf3nRfshrWcE53oPZho3ktq4zvwQ90NtdU+K2m8QqwY1xTnY0eA8VvKKrRs9YNf3lC6N1LUA/NvZupwgb16mII+ceZEdWt83nsFRY9w9AthMl&quot; style=&quot;width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.vuejs.org/api/sfc-script-setup.html#definemodel&quot;&gt;https://ko.vuejs.org/api/sfc-script-setup.html#definemodel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mygumi.tistory.com/398&quot;&gt;https://mygumi.tistory.com/398&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[소소하지만 확실한 UX]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/essay/241221-small-ux/</link><guid isPermaLink="false">https://juheon.dev/essay/241221-small-ux/</guid><pubDate>Sat, 21 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 큼지막한 지하철 출구 번호&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983323/blog/assets/60f7b9df-cf71-4a5d-8af4-5ce1372f1615_jeo4pb.jpg&quot; alt=&quot;수인분당선 출구 번호&quot;&gt;&lt;/p&gt;
&lt;p&gt;언제부터인지 수인분당선 출구에 대문짝만하게 출구 번호가 써져 있었다. 첨부한 사진은 미금역의 모습인데, 미금역 뿐만 아니라 수인분당선의 모든 역 출구에 큼지막하게 마킹되어 있다.&lt;br&gt;
원래 지하철 출구 번호는 출구 앞 표지판에 자그마한 글씨로 써져 있기 때문에 반대편에서는 번호를 읽기 어렵다는 불편함이 있었다. 요즘은 대부분 네이버지도든 카카오맵을 통해 어디에 몇번 출구가 있는지 쉽게 알 수 있지만, 이와 친숙하지 않는 사람들 혹은 그냥 휴대폰 꺼내서 확인하기 귀찮은 사람들에게는 직관적인 표시이다.&lt;br&gt;
쉽고 단순한 조치일 수는 있지만 그 효과만큼은 확실한 UX 개선이라고 할 수 있다.&lt;/p&gt;
&lt;h2&gt;2. 남은 시간을 알려주는 보행 신호등&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/1e639a2d-ef6f-45dd-85f4-7ad7eced10a5_mwnqdi.png&quot; alt=&quot;보행 신호등&quot;&gt;
(자료 사진으로 대체함)&lt;/p&gt;
&lt;p&gt;얼마전 집 앞 횡단보도가 싹 다 교체되더니 새로운 신호등으로 바뀌어 있었다. 새 신호등에는 빨간불 → 파란불로 바뀔 때까지 남은 시간이 표시된다.&lt;br&gt;
대개 보행자 입장에서 빨간불에서 파란불로 바뀔 때까지 걸리는 시간을 참지 못하고 무단횡단을 하는 경우가 있다. 그런데 실시간으로 남은 시간이 줄어드는걸 보여주게 된다면 보행자의 인내심을 조금 더 늘릴 수 있는 원리인 것 같다. 웹페이지로 비유하자면 로딩 프로그레스 바의 역할인 셈이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Vue의 <Suspense> 컴포넌트 파헤치기]]></title><description><![CDATA[컴포넌트 Vue에서 제공하는 내장 컴포넌트 중에서  가 있다. 비동기  혹은 비동기 컴포넌트의 데이터가 준비 완료되기 전까지  템플릿을 보여주는 기능으로, React 진영의  와 사실상 동일하다고 볼 수 있다. Vue…]]></description><link>https://juheon.dev/vue/241215-suspense/</link><guid isPermaLink="false">https://juheon.dev/vue/241215-suspense/</guid><pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 컴포넌트&lt;/h2&gt;
&lt;p&gt;Vue에서 제공하는 내장 컴포넌트 중에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 가 있다. 비동기 &lt;code class=&quot;language-text&quot;&gt;setup&lt;/code&gt; 혹은 비동기 컴포넌트의 데이터가 준비 완료되기 전까지 &lt;code class=&quot;language-text&quot;&gt;fallback&lt;/code&gt; 템플릿을 보여주는 기능으로, React 진영의 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 와 사실상 동일하다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;Vue 버전 &lt;code class=&quot;language-text&quot;&gt;3.5.13&lt;/code&gt; 기준으로 아직까지는 experimental 기능이지만, github에 올라오는 discussion 에 따르면 조만간 정식 기능으로서 추가될 것으로 보인다(2년동안 그러고 있다는 건 비밀).&lt;/p&gt;
&lt;p&gt;그렇다면 어떻게 사용하는지에 대해서 알아보자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://vuejs.org/guide/built-ins/suspense.html#suspense&quot;&gt;공식문서&lt;/a&gt;에 따르면, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 가 기다릴 수 있는 2가지 유형의 의존성이 있다. 사실 2가지로 나뉘어 있다기 보단, 1번 조건(&lt;code class=&quot;language-text&quot;&gt;async setup&lt;/code&gt;)을 만족하면 자동적으로 2번 조건(&lt;code class=&quot;language-text&quot;&gt;async component&lt;/code&gt;)이 충족된다에 가깝다.&lt;/p&gt;
&lt;h3&gt;1. &lt;code class=&quot;language-text&quot;&gt;async setup&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Vue3의 Composition API에서는 기본적으로 &lt;code class=&quot;language-text&quot;&gt;setup(){...}&lt;/code&gt; 함수 안에 비즈니스 로직을 작성하게 된다. 만약 함수 내부에서 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 문을 사용하여 비동기 함수를 호출하고 싶다면 &lt;code class=&quot;language-text&quot;&gt;async setup&lt;/code&gt; 와 같이 작성하면 된다. &lt;code class=&quot;language-text&quot;&gt;script setup&lt;/code&gt; 을 사용하고 있더라도 동일하게 &lt;code class=&quot;language-text&quot;&gt;Top-level await&lt;/code&gt; 를 하면 된다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;예시코드&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  // AsyncChild.vue
  &amp;lt;script&amp;gt;
  export default {
  	async setup(){
  		const fetchData = () =&amp;gt; {...}
  		await fetchData();
  	}
  	...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;script setup&amp;gt;
  const fetchData = () =&amp;gt; {...}
  await fetchData();
  ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;2. &lt;code class=&quot;language-text&quot;&gt;async component&lt;/code&gt; (비동기 컴포넌트)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;defineAsyncComponent&lt;/code&gt; 함수와 동적 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 문을 조합하면 비동기 컴포넌트를 얻을 수 있다. 비동기 컴포넌트를 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 문의 default slot으로 넣게되면 로딩이 완료되기 전까지는 fallback slot 으로 넣은 템플릿을 보여주다가, 완료되면 비동기 컴포넌트를 보여준다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;예시코드&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Parent.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;Hello!&amp;lt;/h2&amp;gt;
    &amp;lt;Suspense&amp;gt;
      &amp;lt;AsyncChild /&amp;gt;
      &amp;lt;template #fallback&amp;gt; Loading... &amp;lt;/template&amp;gt;
    &amp;lt;/Suspense&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  import { defineAsyncComponent } from &amp;quot;vue&amp;quot;

  const AsyncChild = defineAsyncComponent(() =&amp;gt; import(&amp;quot;./AsyncChild.vue&amp;quot;))
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h2&gt;로딩 UI 만들기&lt;/h2&gt;
&lt;h3&gt;단순 텍스트 UI&lt;/h3&gt;
&lt;p&gt;이를 토대로 서버로부터 API를 요청하고 응답받기까지 걸리는 시간동안 보여줄 로딩 UI를 구성해보자.
API를 요청하는 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt; 함수에서 로딩시간에 해당하는 3000ms 는 다음과 같이 모킹했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const fetchData = async () =&amp;gt; {
  await new Promise(resolve =&amp;gt; setTimeout(resolve, 3000))
  list.value = data
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 나는 &lt;code class=&quot;language-text&quot;&gt;async setup&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;Top-level await&lt;/code&gt; 를 이용하여 부모 컴포넌트에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 안에 집어넣었다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;AsyncList.vue&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// AsyncList.vue
&amp;lt;script setup&amp;gt;
import {ref} from &amp;#39;vue&amp;#39;

const data = [
{id : 0, title: &amp;#39;This is first&amp;#39;},
 {id : 1, title: &amp;#39;This is second&amp;#39;},
 {id : 2, title: &amp;#39;This is third&amp;#39;}]
const list = ref(null)

const fetchData = async() =&amp;gt; {
  await new Promise(resolve =&amp;gt; setTimeout(resolve,3000))
  list.value = data;
}
await fetchData();
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&amp;quot;item in list&amp;quot; :key=&amp;quot;item.id&amp;quot;&amp;gt;{{item.title}}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;Parent.vue&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Parent.vue
&amp;lt;script setup&amp;gt;
  import { defineAsyncComponent } from &amp;quot;vue&amp;quot;

  const AsyncComponent = defineAsyncComponent(() =&amp;gt; import(&amp;quot;./AsyncList.vue&amp;quot;))
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;Hello!&amp;lt;/h2&amp;gt;
    &amp;lt;Suspense&amp;gt;
      &amp;lt;AsyncComponent /&amp;gt;
      &amp;lt;template #fallback&amp;gt; Loading... &amp;lt;/template&amp;gt;
    &amp;lt;/Suspense&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
여기까지 구현하고 나서 결과물을 살펴보자.  페이지를 새로고침해보면 3초간 Loading...  텍스트가 표시되다가 데이터가 나오는 걸 확인할 수가 있다.
&lt;h3&gt;작동영상&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/c65b5008-dad7-4c1a-aa33-6a6c52b9d3a2&quot; alt=&quot;suspense&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Vue Playground&lt;/h3&gt;
&lt;iframe src=&quot;https://play.vuejs.org/#eNqFU1Fv0zAQ/itHeGgqlaRsPJWs0oBJgCaYWN8IDya5tF5dO7KdtFOU/87ZabK2K1uUB/u7z77vzvc1wXVZRnWFwSxITKZ5acGgrcp5KvmmVNpCAzkWXOK1eZTZZ0WgRGmhhUKrDYzo7OhjKlOZKWksnLCuzh4OwzFczaFLEI6i2IdvubFOymg8TmUSd2pIB20sbkrBLNIOIMl57Re0XF3Mv6IQ6k0S03IP3lemRGlw7nYAHUr4ibb4NN5ngbcFE+Ivy9b7G913q1jO5TKKooEfH8lywJDZ64w7oUe8YBJYQ60q+DJ6MEpS3xtHToOMhHGB+mdpObUyDWbgIy5GctT2u8esrnDS49kKs/UZ/MHsHJYGdxoN6hrTYIhZppdou/DN/Q/c0XoIblReCWK/EPyFRonKaexonyqZk+wDnlf7zT8udWxhbnaWmtIX5YQ6Zuv5aUAv7t7kf6U/yb2MPvhzqWypi0cj88L0aiwOR/VpUnNmGc3n71Q2PIcZTCdguRU4g9FixQ3QX3Bt7MgL7Tjvn3MM0nX5IeniOcmuuCbOnz63IN2Um7SFshKC5r2PFGiz1ZdOGnMldlbx7WBbxi1I3MId1cMNhvS6StToGFT3gm9QVbZHJ5fT6dR5CXy+qGaiIqovnBxLfewuHFKGY2/kzhOvGBAywYy5cmMrLSOH0wD0NqjE4JtEcKjfFUoTk9MlwKUXkwYwW+PjHo14Tqebxq9979o2iQUffLW/8YyjgvYfHHmRWw==&quot; style=&quot;width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;
&lt;h3&gt;스켈레톤 UI&lt;/h3&gt;
&lt;p&gt;단순히 Loading 텍스트만 표시되는 건 심심하니 스켈레톤 UI를 적용하여 사용자에게 컨텐츠가 표시될 영역에 대한 힌트를 제공해주는 것 또한 가능하다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;Skeleton.vue&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Skeleton.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li v-for=&amp;quot;i in 3&amp;quot; :key=&amp;quot;i&amp;quot; class=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;style scoped&amp;gt;
  .container {
    padding: 10px;
    border-radius: 10px;
    width: 100%;
    background-color: #eaeaea;
  }
  ul {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  li {
    width: 400px;
    height: 30px;
    background-color: #bcbcbc;
    border-radius: 8px;
    list-style-type: none;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% {
      background-color: #ccc;
    }
    50% {
      background-color: #ddd;
    }
    100% {
      background-color: #ccc;
    }
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;작동영상&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/user-attachments/assets/2443c7f5-0f52-4493-b824-083586a5ddb6&quot; alt=&quot;skeleton&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Vue Playground&lt;/h3&gt;
&lt;iframe src=&quot;https://play.vuejs.org/#eNqtVdtuEzEQ/ZVhqyqp1FxoC0IhrShQCRCCivaN5cFdzyZuHXtle9NEUf6dsb27uTS9SKDNgz1zPHM8Z8ZZJOdF0Z2WmAySoc2MKBxYdGVxlioxKbRxsACOuVB4bucq+6TJqFA5WEJu9ARadLb1vgFf3aFEp1Xl7PZqg8/RSlWqMq2sg61gpztztNsHcHoGMXSbggX3d2FdiHZwkKphL5ImurRxOCkkc0g7gCEX07Cg5fjo7AtKqV8Ne7SsjFelLVBZPPM7gGgl+xa33ra/zgJ7OZPyhmV3VcQYta5Ar7EOexvEvKHJHZj2ItUNXHKYOEvFysWoe2u1IoEWHpwmGVETEs3PwgkqZpoMIHi8jwjp+2/B5kyJh7U9G2N2t8N+a2feliaXBi2aKaZJ43PMjNBF98XVD5zRunFONC8loZ9w/kKrZek5RtjHUnGivYYLbL8GeYUaXduLmaOi1JfyRD1yGfBpQpp7VR67+orucfcknEvVkqq40TRPtLnBfL2nV73KmWPUob9TtRAcBtA/BCecxAG0rsfCAv1yYaxrBaIR8/ohxiKF4+ugo4cgNxaGMH/q3JJ4U27i1lallNTxtSdHl40/R2rMXzEOSygHu2fCgcJ7uKT7CIttUlfLKXoE3ftaTFCXrrYeHvf7fT9NEPJ1p0yWBA0Xp9GmOsaATcr2AZmruj83gpBJZu2pb1vlGM04NUA9BqVczYgUMO3k2hBSUBAQKpBJExjc4byydgWn04tFWIfaLZfDnhTNXFURd04Uba2bSwQaqwI5WboNp1A2P8ojo6lNO5mW2gxgj6P/6Lbk1Yaj6RjGRWlJ4X4xC/aCcU7d21ioXKUM8biwlHs+gFxixPpFhwuDme/fAVCacqKCa8QK3zdHdQwpQgxfg06g3XHzglpF0asUDoxRjMaOur1JS0p4YLhqeEDWH1/q/P8lj9fmeE0YWtZRvDAU4MWaPKNIVVtfmLrcj8lwL7gbB2B/PwIfqonMf/+s0dstjerUJ/2azJY2O8ncZP7bdad31aHHtWf0arFIryilRTii14P+KhTVP1JL1QdSJzdsgjZiAtX+fvVe7iCUZZENnQZ48xSSc75C+oK/KOhGhybLv7jq1co=&quot; style=&quot;width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;에러 핸들링&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;Suspense&gt;&lt;/code&gt; 안에서 에러가 발생할 경우 어떻게 에러 핸들링을 해야 하는지도 알아보자.&lt;/p&gt;
&lt;p&gt;위에서 설명한 로딩 UI에서 &lt;code class=&quot;language-text&quot;&gt;defineAsyncComponent&lt;/code&gt; 함수를 사용할 때 인자로 동적 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 문을 사용했지만 &lt;code class=&quot;language-text&quot;&gt;errorComponent&lt;/code&gt; 속성 또는 &lt;code class=&quot;language-text&quot;&gt;onError&lt;/code&gt; 속성을 설정하면 에러를 핸들링 하는 것도 가능하다.&lt;/p&gt;
&lt;p&gt;그 밖의 속성들은 공식문서 상에서 아래와 같이 확인할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function defineAsyncComponent(
  source: AsyncComponentLoader | AsyncComponentOptions
): Component

type AsyncComponentLoader = () =&amp;gt; Promise&amp;lt;Component&amp;gt;

interface AsyncComponentOptions {
  loader: AsyncComponentLoader
  loadingComponent?: Component
  errorComponent?: Component
  delay?: number
  timeout?: number
  suspensible?: boolean
  onError?: (
    error: Error,
    retry: () =&amp;gt; void,
    fail: () =&amp;gt; void,
    attempts: number
  ) =&amp;gt; any
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;errorComponent&lt;/code&gt; 를 설정하면 에러가 발생했을 때 &lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt; 에 넣은 비동기 컴포넌트 대신 다른 컴포넌트를 지정할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;onError&lt;/code&gt; 는 에러가 발생했을 때 호출되는 콜백 함수이다. 인자로 4개를 받게 된다.
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;Error&lt;/code&gt; 객체이다. 에러에 대한 정보를 담고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;retry&lt;/code&gt; : 요청을 재시도한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;fail&lt;/code&gt; : 더이상 &lt;code class=&quot;language-text&quot;&gt;retry&lt;/code&gt; 하지 않고 실패로 간주한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;attempts&lt;/code&gt; : 현재까지 시도한 횟수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그래서 아래 예시코드와 같이 최대 3번까지 &lt;code class=&quot;language-text&quot;&gt;retry&lt;/code&gt; 시도 후, 실패처리하는 로직을 작성할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;onError: (error, retry, fail, attempts) =&amp;gt; {
  alert(`error, ${attempts} times`)
  if (attempts &amp;lt; 3) {
    // 최대 3번까지 재시도
    retry()
  } else fail()
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3&gt;Vue Playground&lt;/h3&gt;
&lt;iframe src=&quot;https://play.vuejs.org/#eNqtVs1uI0UQfpXaWVYeS/4jXhAanIgFIgFCsCK5MUjbmamxO2n3jLp7nFiWpT1wQGIlXmDFlQsnJA68EslDUN09PXEcOxsEGsvuqfq66uv6a6+iF1U1WNQYJdFEZ4pXBjSaujpKJZ9XpTKwghwLLvGFXsrss5KEEqWBNRSqnEOH9nY+bsEnFyjQlLJRDoZBYH10WtixUqVqMe6tAaRyOISslNrAlsPDnTziuAuHR+DtxmTMqb/m2jiD3W4q/421VSoBRMlyVJCAt+1kAIrCoiRIvISXRJxrjGOFuhQL7Ck8x8w4NEXvlM+xrAM1r4s77pSdbg8ORqOR5WWNrnv2F63qllvi4+NUpfSxSgBiB+tZImrZg4Jx0QNmDM4rozeZ2gOXAgcOH79qtr23Ctg1GGKoXzUceBEHDUxg3G2sAFAmbv58e/3mNYyv//jp77/e3Pz2Gm5+/f3m57fXv/wYUI5OHM4DKDQ6bnGXysLK7Pc6lWuCTIa+xqi66MX6FMwgvQFMcr5wC1rODo6+QCHKJ5MhLRvhSa0rlBqPvNvgfrKV2OG2PniBpwUT4oxlF41FbzUU7LCVToZ3iFlB69sxHXqqd3BRLzKaAl/w6eBcl5L6ycUxjTKixgWqbyvDKTFplIQ8pRERKi+/cjKjanQZd3tmmF3skJ/rKytLo5dUeagWmEatzjA1RePVxyff4BWtW+W8zGtB6AeU39lari1HD/u0ljnR3sA5tl+6TuNyeqqPrwwFJRzKEnWpdvg0ovazWdl39Fu648HzUCIUxTv9+8BUUlhsjiBbUL7Rc2YYtff3qVzxnPpm1KNyNwIT6JzOuAb6FFxp03FEPeb9+xiNZC7fBB3cB5kZV4T5IfgWxJt8E7dY1kJQxQdNgSabfe6pMXvEjdnCLhk3uwdLMz32TZYGNG4niiUwWDBRo51w5I56kALrPbQcXGuG5nxHT0ImmNaHto6lYTQxqSJCX9TitmkEh0W/KBUhORkBLh2ZNILkApeNdMBz2r1aubUL5no9GQreNlpjcWeL0as2S4FAfVZhTpJBy8nF0fb2VJVUt/2sFKVK4GmO9nGD6KxUNNX7iuW81pTyUXXl5BXLcyrnVkLhqoWzl3NNvpcJFAI91i76OVeUEirohCatqOfSqaassoV0EGwI7u8SikHf0e6bZUW1I2lMuQ0z5NOZofJv3VImLNAd1U2UzcuTWuH/So/NzXgjMbQMVmxiyMCjc/KOjDSxtYEJ4d6Xhkuem5kDjp554P1sIrPPf87Rh1s5Cq6fjwKZrdzsJHOW2WfXmT5qNu3PPaMxxjy9qrYX5gGNE7o7JMXfU0vlJ5SdQjG6qD3GUR09awboDkJZ5tnQboAPHkLmeX6LtAF/lNE7FUrV2f5tuzelH3fNh0vV/9t5sv9qXf8DnjqTFg==&quot; style=&quot;width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=2-jQ1v6X7vA&quot;&gt;https://www.youtube.com/watch?v=2-jQ1v6X7vA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.vuejs.org/guide/components/async&quot;&gt;https://ko.vuejs.org/guide/components/async&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.vuejs.org/guide/built-ins/suspense&quot;&gt;https://ko.vuejs.org/guide/built-ins/suspense&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vuejs.org/api/general.html#defineasynccomponent&quot;&gt;https://vuejs.org/api/general.html#defineasynccomponent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[v-memo 개념과 활용법]]></title><description><![CDATA[Vue의 3.…]]></description><link>https://juheon.dev/vue/241212-v-memo/</link><guid isPermaLink="false">https://juheon.dev/vue/241212-v-memo/</guid><pubDate>Thu, 12 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Vue의 3.2 버전부터 추가된 신규 디렉티브인 &lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 에 대해서 살펴보도록 하자.&lt;/p&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 란?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.vuejs.org/api/built-in-directives#v-memo&quot;&gt;공식문서&lt;/a&gt; 상의 설명은 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;템플릿의 하위 트리를 메모합니다. 엘리먼트와 컴포넌트 모두에 사용할 수 있습니다. 디렉티브는 메모이제이션을 위해 비교할 의존성 값의 고정된 길이의 배열을 요구합니다. 배열의 모든 값이 마지막 렌더링과 같으면 전체 하위 트리에 대한 업데이트를 생략합니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;‘의존성 배열’ 이라는 용어는 리액트를 접해보았다면 익숙하게 받아들일 수 있을 것이다. &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;useMemo&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;useCallback&lt;/code&gt; 와 같은 훅에서 사용되는 그 ‘의존성 배열’과 일맥상통하다. &lt;strong&gt;의존성 배열 안에 들어있는 값이 변하지 않는 한, 해당 디렉티브가 선언된 DOM노드를 메모이제이션함으로써 리렌더링 비용을 아낀다&lt;/strong&gt;는 것이 핵심이다.&lt;/p&gt;
&lt;h2&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;그렇다면 어떤 경우에 사용하면 좋을까? 공식문서 상에서는 &lt;code class=&quot;language-text&quot;&gt;v-for&lt;/code&gt; 를 사용하여 리스트 렌더링을 해야하는 경우, &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; 일부가 변경되어 리스트 전체가 리렌더링 되는 상황을 &lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 를 사용함으로써 방지할 수 있다고 한다.&lt;/p&gt;
&lt;p&gt;내가 작성한 예시코드에서는 이러한 상황을 모킹하기 위해 리스트의 각 원소 안에 현재 시각을 표시하는 &lt;code class=&quot;language-text&quot;&gt;new Date().getTime()&lt;/code&gt; 함수를 호출하였다. 그리고 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값을 변화시켜가면서 각 원소별로 이 값이 어떻게 변하는지 살펴보려고 한다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;예시코드&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;script setup&amp;gt;
  import { ref } from &amp;quot;vue&amp;quot;

  const activeId = ref(0)
  const list = ref([
    { id: 0, title: &amp;quot;first&amp;quot; },
    { id: 1, title: &amp;quot;second&amp;quot; },
    { id: 2, title: &amp;quot;third&amp;quot; },
    { id: 3, title: &amp;quot;fourth&amp;quot; },
    { id: 4, title: &amp;quot;fifth&amp;quot; },
  ])
&amp;lt;/script&amp;gt;

&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;button @click=&amp;quot;activeId--&amp;quot;&amp;gt;-&amp;lt;/button&amp;gt;
    &amp;lt;span&amp;gt;activeId : {{activeId}}&amp;lt;/span&amp;gt;
    &amp;lt;button @click=&amp;quot;activeId++&amp;quot;&amp;gt;+&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;without v-memo&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li
        v-for=&amp;quot;item in list&amp;quot;
        :key=&amp;quot;item.id&amp;quot;
        :class=&amp;quot;{highlighted : item.id === activeId}&amp;quot;
      &amp;gt;
        {{item.title}}
        &amp;lt;span&amp;gt;: {{new Date().getTime()}}&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;v-once (v-memo=&amp;quot;[ ]&amp;quot;)&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li
        v-for=&amp;quot;item in list&amp;quot;
        :key=&amp;quot;item.id&amp;quot;
        v-memo=&amp;quot;[]&amp;quot;
        :class=&amp;quot;{highlighted : item.id === activeId}&amp;quot;
      &amp;gt;
        {{item.title}}
        &amp;lt;span&amp;gt;: {{new Date().getTime()}}&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;h2&amp;gt;v-memo&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li
        v-for=&amp;quot;item in list&amp;quot;
        :key=&amp;quot;item.id&amp;quot;
        v-memo=&amp;quot;[item.id === activeId]&amp;quot;
        :class=&amp;quot;{highlighted : item.id === activeId}&amp;quot;
      &amp;gt;
        {{item.title}}
        &amp;lt;span&amp;gt;: {{new Date().getTime()}}&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;
  .highlighted {
    background-color: #ccc;
  }
&amp;lt;/style&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;작동영상&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/e3e56afd-4fdb-4da7-b449-3e7994a7fb3b_hfwl7j.gif&quot; alt=&quot;v-memo&quot;&gt;&lt;/p&gt;
&lt;h4&gt;Vue Playground&lt;/h4&gt;
&lt;iframe src=&quot;https://play.vuejs.org/#eNrNVbty2zAQ/JUbpLA0ejm2K4bS5OXCKZJM4s5wIYOgCAsEOABIycPhv+fAp6R47MaFC2kOt4fD7pI4luRLls2LnJOAhJYZkTmw3OXZiiqRZto4KMHwGCqIjU7hDEvPqKKKaWUdrJkTBb+JYOmLRufjTx0iBf412TuqAEoRQQDnUyec5AElsTDWUVJNB/BjD1qOTaJj9KJHXSLMCXg59NW5cckxenVwajyA92MvhKpw0QhHybhwPM3k2nFcAYSRKOoAw4fcOa3gM5OCbZeUdNpnM0pWs3DR4F21zdZq1dsTQFl2i6rCAz36St/JBPtOjvqGi47PKbnkYrUTLtG5g2KW8lSHC0y1YC7bCGMpsCDWBg8SKBWEqh8VJRBs+VObnQv0FyBgcm0t5spEbBKJP8e9lrYElstl/wZUSLY7BH0v65ra9qoa8o0t3g3Fd/AdbR6N5xvubkWK0YkzXq8UnYhFq6LzoE0fe1DMtGIcRo0HyPzunpLxG3hx1PD9G/OfLW/0Sgw2PCf13Vvj7024OLjhuLTuSfpwfsi39LUPa7bdGJ2raMa01CaAD4wxnHBIDg9t95EpcRbHVSw280erFQ7SejclTKeZkNz8ypzAmUgJamiI4SWXUu9+1Dlncl7Po3pPwtn2mfyj3fscJb8Nt9wUnJIec2uDdjTw9d+ffI9xD6Y6yiVWvwD+4VbL3HNsyr6iYqR9UFezvak/B0Jtbu313nFlO1GeqK9spiol+In49oL0ge7l/Kreh46S6h/O+RdJ&quot; style=&quot;width:100%; height:800px; border:0; border-radius: 4px; overflow:hidden;&quot; sandbox=&quot;allow-modals allow-forms allow-popups allow-scripts allow-same-origin&quot;&gt;&lt;/iframe&gt;
&lt;h3&gt;v-memo 미적용&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 를 적용하지 않은 경우엔 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값이 변경될 때마다 모든 원소의 (현재 시각)값이 변하고 있음을 확인할 수 있다. 이는 같은 파일안에 있는 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값이 반응형 변수인 &lt;code class=&quot;language-text&quot;&gt;ref&lt;/code&gt; 로 선언되어 있기에 이 값이 변할 때마다 리스트가 리렌더링되기 때문이다.&lt;/p&gt;
&lt;h3&gt;v-once (v-memo=”[ ]”)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 의 의존성 배열을 비워둘 경우 &lt;code class=&quot;language-text&quot;&gt;v-once&lt;/code&gt; 와 동일한 효과를 발휘한다. 즉 최초 mount 시에만 렌더링 되며 그 이후에는 반응형 변수의 값이 변하여 리렌더링이 일어나더라도 &lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; (&lt;code class=&quot;language-text&quot;&gt;v-once&lt;/code&gt;) 로 감싸져있는 부분은 변하지 않는다. 따라서 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값을 어떻게 변경한들, 현재 시간은 그대로이다.&lt;/p&gt;
&lt;h3&gt;v-memo 적용&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 의존성 배열에 &lt;code class=&quot;language-text&quot;&gt;item.id === activeId&lt;/code&gt; 라고 명시했다. 즉 원소의 &lt;code class=&quot;language-text&quot;&gt;id&lt;/code&gt; 값과 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값의 일치여부가 변경될 때만 리렌더링이 되도록 지정하고, 그 외에 경우엔 메모이제이션하여 리렌더링을 방지했다.&lt;br&gt;
예를 들어 &lt;code class=&quot;language-text&quot;&gt;activeId&lt;/code&gt; 값이 1 → 2로 변할 때는 오직 &lt;code class=&quot;language-text&quot;&gt;first&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;second&lt;/code&gt; 에 해당하는 아이템에서만 현재 시각이 변하며, 그 외 원소에서는 값을 그대로 유지하게 된다.&lt;/p&gt;
&lt;h3&gt;React.memo 와의 비교&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;React.memo&lt;/code&gt; 와 비슷하게 사용할 수 있는 디렉티브라고 볼 수 있다. 다만 차이점이라면 &lt;code class=&quot;language-text&quot;&gt;React.memo&lt;/code&gt; 는 컴포넌트에 적용되는 반면, &lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt; 는 엘리먼트에 적용된다는 점이다. 즉 &lt;code class=&quot;language-text&quot;&gt;v-memo&lt;/code&gt;가 훨씬 더 유연하며 넓은 범위에서 사용할 수 있는 디렉티브라고 볼 수 있다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.vuejs.org/api/built-in-directives#v-memo&quot;&gt;https://ko.vuejs.org/api/built-in-directives#v-memo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learnvue.co/articles/v-once-v-memo&quot;&gt;https://learnvue.co/articles/v-once-v-memo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[개발과 개발자 사이]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/essay/241110-develop-and-developer/</link><guid isPermaLink="false">https://juheon.dev/essay/241110-develop-and-developer/</guid><pubDate>Sun, 10 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;개발자라는 직업은 무엇일까. 단순하게 생각해보면 개발을 직업으로 삼은 사람을 일컫는다.&lt;/p&gt;
&lt;p&gt;한국에서는 코로나 사태를 겪으면서 개발자란 직업의 사회적인 위상이 최근 몇 년새 급격히 올라갔다. 자연스레 이를 선망하는 사람들이 생기고, 많은 사람들이 개발자 취업 시장에 뛰어들었다. 현재도 개발자는 2,3년 전만큼은 아니지만 여전히 보상과 워라밸을 적절하게 잡을 수 있는 좋은 직업 중 하나라고 생각한다.나 역시도 개발자란 직업에 대해 만족하고 있다. 개발은내가 좋아하는 일이면서 남들보다 조금이라도 더 잘 할 수 있는 일을 직업으로 삼는다는 건 사실 엄청난 행운이라고 생각한다. 내가 개발을 어떻게 시작했고 현재까지의 여정은 &lt;a href=&quot;https://juheon.dev/essay/230812-why-i-become-developer/&quot;&gt;이 글&lt;/a&gt;에서도 자세히 설명하고 있다.&lt;/p&gt;
&lt;p&gt;그런데 이따금씩 내가 지금 좇고 있는 것이 개발인지 개발자인지 분간이 가지 않을 때가 있다. 어렸을 때와 대학교에 다니던 시절까지만 하더라도 단순히 코드를 짜고 실행해서 결과물을 보는 일 자체가 재밌었다. 내가 의도한대로 동작하는 모습을 보면 뿌듯했고, 버그가 나면 어디서 잘못되었는지 찾아내는 과정도 고통스럽긴 하지만 그 나름의 재미가 있었다. 그 안에서 무엇이 취업 시장에서 좋은 평가를 받는지에 대해서 신경쓰지 않았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983312/blog/assets/287372ad-f481-41bd-b3cc-b38ffc2a309d_ql2u32.png&quot; alt=&quot;interview-questions&quot;&gt;&lt;/p&gt;
&lt;p&gt;하지만 본격적으로 개발자 취업전선에 뛰어들면서 이러한 원초적인 재미는 뒷전으로 밀려버리고 취업 시장에서의 가치를 따지게 되었다. 개발하면서 얻을 수 있는 순수한 재미보다는 취업을 위해서, 다시말해 회사에 뽑히기 위한 기술과 성과를 위한 개발로 노선을 변경해야 했다. 이 과정에서 난 가장 중요한 가치를 놓쳐버린게 아닐까 싶다. 그러면서 개발 공부를 하는데 있어서도 ‘이걸 알아야할 필요가 있나?’ 와 같이 취업을 위한 지식과 그렇지 않은 지식을 구분지으려 하는 나 자신을 발견하게 되었다. 이런 내 모습이 예전의 모습과 너무나 이질적이어서 현타가 온 적도 있었다.&lt;/p&gt;
&lt;p&gt;정리해보면 나는 ‘개발’은 좋아했지만 ‘개발자 준비’는 그닥 맞지 않았던 것 같다. 둘 사이의 균형을 잡는 일이 결코 쉽지는 않다. 아이처럼 항상 재미만 추구하면서 개발할 수는 없기 때문이다. ‘일’이라는 건 때로는 재미없고 지루한 레거시 개편 업무를 맡을 수도 있다. 내가 속한 조직이 겪고있는 문제를 푸는 것이 곧 개발자의 역할이기 때문이다. 조직마다 갖고 있는 문제의 형태가 각기 다를 뿐이다. 어쩌면 내가 생각하던 개발자라는 개념은 너무 좁은 범위에 국한되어 있을지도 모른다. 개념을 더 확장해서 생각해보면 결국 ‘회사의 기술적 문제를 해결하는 사람’ 이 되어야 한다.&lt;/p&gt;
&lt;p&gt;내가 진짜로 하고싶은 일, 되고 싶은 사람은 무엇일까. 개발을 하는 사람인 걸까 아니면 사회적으로 유망한 직업 중 하나가 되고 싶은 걸까. 이 질문에 대한 답을 찾아가는 과정이 내가 앞으로의 커리어에서 풀어야 할 과제로 삼아야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Web Canvas API 활용하여 GPT와 캐치마인드 하기 (3 of 3)]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/react/241104-canvas-gpt-quiz-3-of-3/</link><guid isPermaLink="false">https://juheon.dev/react/241104-canvas-gpt-quiz-3-of-3/</guid><pubDate>Mon, 04 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;여러가지 그림 테스트&lt;/h2&gt;
&lt;p&gt;지난 포스팅에서 프론트엔드와 백엔드를 연동하고 실제 그림을 그려서 문제를 맞추는 것까지 구현했다. 다만 내가 의도한 그림의 정답을 맞추지 못했는데, 다른 그림을 더 그려보고서 무엇을 잘 맞추고 못 맞추는지 경향성을 파악해보고 개선해보고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/ce60344d-9167-44cd-8a16-4410aead7672_fhdb9j.png&quot; alt=&quot;gpt-apple&quot;&gt;
다행히도 사과는 잘 맞췄다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/239257a9-c73e-423d-a829-3d9e67e6e8e8_udhqpv.png&quot; alt=&quot;gpt-grape&quot;&gt;&lt;/p&gt;
&lt;p&gt;포도도 맞췄다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/1f4a26b2-008a-45c4-a7f2-fae7fafabfaa_o6k8ar.png&quot; alt=&quot;gpt-melon&quot;&gt;&lt;/p&gt;
&lt;p&gt;수박은 못 맞춘다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/3f14367f-d163-4aca-9c0a-0a6ea0a59bcd_tdmzh7.png&quot; alt=&quot;gpt-car&quot;&gt;&lt;/p&gt;
&lt;p&gt;자동차를 그렸는데 고양이라고 추론한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/2f34f76c-af10-4b8f-9cc7-4c6d5d57b77c_qujflf.png&quot; alt=&quot;gpt-cat&quot;&gt;&lt;/p&gt;
&lt;p&gt;그런데 막상 고양이를 그렸는데도 못 맞췄다....
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/bb6698ab-9cc4-4f9c-af30-be35028c73cf_otmldc.png&quot; alt=&quot;gpt-animal&quot;&gt;
내가 그리고도 뭘 그렸는지 모르겠다. 곰과 돼지 중에서 그리고 싶었는데 잡종이 되어버렸다. 그런데 아무튼 동물인라는 사실 조차도 맞추지 못한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983311/blog/assets/9e992cad-877f-4dc4-8426-3a6d036489c0_ggqmww.png&quot; alt=&quot;gpt-human&quot;&gt;
사람을 그렸음에도 맞추지 못한다.&lt;/p&gt;
&lt;p&gt;이 외에도 최소 20개의 각기 다른 키워드로 테스트를 해보면서 느낀 점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;색깔은 상당히 큰 힌트가 된다.&lt;/li&gt;
&lt;li&gt;지나치게 추상화 된 그림은 맞출 확률이 떨어진다.&lt;/li&gt;
&lt;li&gt;gpt는 헷갈리는 이미지들은 고양이라고 대답하는 경향이 있다.(갖가지 고양이 이미지들로 학습이 된 모양이다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;앞으로 튜링테스트가 필요할 땐 여기서 해보자&lt;/del&gt;&lt;/p&gt;
&lt;h2&gt;개선할 방법이 없을까?&lt;/h2&gt;
&lt;h3&gt;프롬프트 수정&lt;/h3&gt;
&lt;p&gt;가장 먼저 생각나는 방법은 프롬프트를 수정해보는 것이다. 현재 사용되고 있는 프롬프트는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; messages: [
    {
      role: &amp;quot;user&amp;quot;,
      content: [
        { type: &amp;quot;text&amp;quot;, text: &amp;quot;What&amp;#39;s in this image?&amp;quot; },
        {
          type: &amp;quot;image_url&amp;quot;,
          image_url: {
            url: &amp;quot;https://{image_url}&amp;quot;,
          },
        },
      ],
    },
  ],&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;공식문서와 구글링을 통해 여러 포스팅을 찾아보던 중, &lt;code class=&quot;language-text&quot;&gt;role&lt;/code&gt; 에 &lt;code class=&quot;language-text&quot;&gt;system&lt;/code&gt; 속성을 추가하여 사전에 구체적인 정보나 답변의 방향성을 제시해 준다면, 모델이 더 정확한 답을 추론할 수 있다는 글을 보았다. 그래서 아래와 같이 수정해보았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; messages: [
        {
          role: &amp;quot;system&amp;quot;,
          content: [
            {
              type: &amp;quot;text&amp;quot;,
              text: &amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;,
            },
          ],
        },
        {
          role: &amp;quot;user&amp;quot;,
          content: [
            {
              type: &amp;quot;text&amp;quot;,
              text: &amp;quot;What’s in this image? Please summarize it within 30 characters&amp;quot;,
            },
            {
              type: &amp;quot;image_url&amp;quot;,
              image_url: {
                url: imageData,
              },
            },
          ],
        },
      ],&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;과연 이렇게 수정하면 정확도가 높아질까? 결론부터 얘기하면 별 차이가 없었다. 위에서 했던 테스트와 비슷한 결과가 나왔다.&lt;/p&gt;
&lt;h3&gt;파인 튜닝&lt;/h3&gt;
&lt;p&gt;OpenAI에서는 파인튜닝이라는 기능을 제공한다. 내가 직접 데이터를 준비하고 학습을 시켜서 모델을 조금 더 정확하게 만들 수 있는 것이다. &lt;a href=&quot;https://platform.openai.com/docs/guides/fine-tuning&quot;&gt;공식문서&lt;/a&gt;상에서 그 방법을 자세히 알려주고 있다. &lt;code class=&quot;language-text&quot;&gt;JSONL&lt;/code&gt; 형식의 데이터로, 최소 10개 이상의 학습 데이터가 필요하다. 나는 테스트하면서 실패했었던 그림을 위주로 학습 데이터 10개를 준비했다.&lt;/p&gt;
&lt;details&gt; 
&lt;summary&gt;학습 데이터&lt;/summary&gt;
&lt;p&gt;&lt;em&gt;참고로 &lt;code class=&quot;language-text&quot;&gt;JSONL&lt;/code&gt; 형식은 한 줄에 하나의 JSON 객체를 저장하는 텍스트 파일 형식이다. 기존 &lt;code class=&quot;language-text&quot;&gt;JSON&lt;/code&gt;파일과 대비하여 띄어쓰기나 줄바꿈에 민감하므로 주의하자&lt;/em&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/f2526a27-8b8d-4739-8fab-5e587914cca7&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;standing human&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/aa9c5a2a-58d7-4fb3-8832-a92bff1595c3&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;house&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/13165e76-fe33-4acb-af63-d2e352155da6&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;car&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/b50fc398-2aa3-44ad-bc8d-bb265c61d932&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;smile face&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/ed2d29e3-343b-4367-bb1d-c1a31bdb4894&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;grape&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/f0a0393f-ea8e-4b6b-87d2-56f3a5dbb3f6&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;apple&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/4c01e26b-f45c-46ab-9f46-516996974d38&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;laptop&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/f96edb43-017b-40f6-aea8-2a4466c73ef7&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;watermelon&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/03884c8e-a002-4dda-8e79-3f8daf9588fe&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;sword&amp;quot;}]}
{&amp;quot;messages&amp;quot;:[{&amp;quot;role&amp;quot;:&amp;quot;system&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;You are given a image file. This image is not real picture. It is a simple drawing, drawn by Canvas API.&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;What&amp;#39;s in this image? Please summarize it within 30 characters&amp;quot;},{&amp;quot;role&amp;quot;:&amp;quot;user&amp;quot;,&amp;quot;content&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;image_url&amp;quot;,&amp;quot;image_url&amp;quot;:{&amp;quot;url&amp;quot;:&amp;quot;https://github.com/user-attachments/assets/f818024e-0246-4503-88c3-d455376a75da&amp;quot;}}]},{&amp;quot;role&amp;quot;:&amp;quot;assistant&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;cat&amp;quot;}]}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;br/ &gt;
파인 튜닝은 대시보드에서 대시보드에서 파인 튜닝 탭을 들어가면 파인 튜닝을 진행할 수 있다. 파인 튜닝을 적용할 모델도 여러 종류가 있는데, 이미지를 학습시킬 수 있는 모델은 현시점에서는 오직 `gpt-4o` 모델만 가능했다. 그 외의 hyperparameter로 Batch-size나 epoch 수를 설정할 수도 있었지만, 이번에는 따로 설정하지 않고 auto 로 두었다.
&lt;p&gt;그러고 나서 job을 생성하면 학습이 시작된다. 학습이 진행되는 동안에는 아래 화면과 같이 학습의 step별로 loss가 점점 줄어드는 걸 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/ca798d26-3e3b-4522-973a-e416e087ff31_yu9gky.png&quot; alt=&quot;fine-tuning&quot;&gt;&lt;/p&gt;
&lt;p&gt;하나의 job은 총 100번의 step으로 이루어져 있으며 시간은 약 5분이 소요되었다. 학습이 완료된 모델은 &lt;code class=&quot;language-text&quot;&gt;ft:gpt-4o-2024-08-06:personal:canvas-quiz:APlr42xm&lt;/code&gt; 와 같이 고유한 모델명이 새롭게 부여되며, 백엔드에서 이 모델을 사용하도록 설정하면 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고로 파인튜닝 비용은 꽤나 비싼 편이므로 주의해야한다. 10개의 이미지 데이터를 학습시키는데 약 2달러가 소모된다. 일반 &lt;code class=&quot;language-text&quot;&gt;gpt-4o-mini&lt;/code&gt; 모델은 30회 호출당 약 0.1달러가 소모되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;파인튜닝 모델 테스트&lt;/h3&gt;
&lt;p&gt;이제 새롭게 만들어진 모델로 처음에 실패했던 그림을 다시 넣어보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983316/blog/assets/f1b43b10-aaf8-40bc-9c37-b82e8f611982_w8eg21.png&quot; alt=&quot;fine-tuning-house&quot;&gt;&lt;/p&gt;
&lt;p&gt;드디어 집을 제대로 인식하기 시작했다!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/0293559d-deb4-4bb8-b7ba-2c2ddea661c8_h1z9hg.png&quot; alt=&quot;fine-tuning-watermelon&quot;&gt;
수박도 정상적으로 인식한다. 그럼 자동차는 어떨까?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983316/blog/assets/eb8cd6f7-5f84-4c43-b915-a34d8db5d80a_z3gkwy.png&quot; alt=&quot;fine-tuning-car&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GPT Think : house&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;응??? 이게 어딜봐서 집이란 거지???&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983312/blog/assets/83f762d2-3067-4435-a9f2-8d8ed09ff277_wdswwu.png&quot; alt=&quot;fine-tuning-human&quot;&gt;&lt;/p&gt;
&lt;p&gt;사람을 그렸음에도 집이라고 인식해버렸다. 대체 왜 이런 일이 생기는 걸까?&lt;/p&gt;
&lt;h3&gt;파인튜닝 모델의 문제점&lt;/h3&gt;
&lt;p&gt;머신러닝을 조금이라도 공부해본 사람이라면 짐작하다시피, Overfitting 문제가 발생하고 있다는 걸 알 수 있다. 학습 데이터에 너무 치중되어 학습된 모델이라, 학습 데이터에 없는 데이터는 제대로 추론하지 못하는 경향이 있다. 이러한 문제를 해결하기 위해서는 더 많은 데이터를 학습시켜야만 한다. 학습 데이터를 만들기 위해서는 내가 손수 그림을 그려야 하는데, 이는 시간과 노력이 많이 소요되므로 다음으로 미뤄야겠다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;이로써 프론트엔드, 백엔드, (나름)최적화까지 모두 진행해보았다. 사실 대충 굴러가게끔만 만든 상태여서 상용에 배포하기 전까지는 몇가지 기능들을 더 다듬어야 할 것 같다. 앞으로 추가할 기능은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실행 취소(undo) 기능 추가&lt;/li&gt;
&lt;li&gt;내가 그린 그림 게시판에 자랑하기&lt;/li&gt;
&lt;li&gt;OAuth 로그인 연동&lt;/li&gt;
&lt;li&gt;상용 배포&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그래도 머릿속으로만 떠돌던 아이디어를 직접 끄집어내서 구현해낸 프로젝트라서 뿌듯하다!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Web Canvas API 활용하여 GPT와 캐치마인드 하기 (2 of 3)]]></title><description><![CDATA[지난 포스팅에서는 프론트엔드에서 Canvas API를 활용하여 그림판 페이지를 만들었다. 이번 포스팅에서는 OpenAI API와 Express 기반의 백엔드 서버와 연동하는 과정을 다루고자 한다. OpenAI API 연동 OpenAI…]]></description><link>https://juheon.dev/react/241103-canvas-gpt-quiz-2-of-3/</link><guid isPermaLink="false">https://juheon.dev/react/241103-canvas-gpt-quiz-2-of-3/</guid><pubDate>Sun, 03 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;지난 포스팅에서는 프론트엔드에서 Canvas API를 활용하여 그림판 페이지를 만들었다. 이번 포스팅에서는 OpenAI API와 Express 기반의 백엔드 서버와 연동하는 과정을 다루고자 한다.&lt;/p&gt;
&lt;h2&gt;OpenAI API 연동&lt;/h2&gt;
&lt;p&gt;OpenAI와 연동하기 위해서 &lt;a href=&quot;https://openai.com/index/openai-api/&quot;&gt;공식 사이트&lt;/a&gt;로 들어가서 가장 먼저 가격정책을 확인해보았다. 생성형 AI 모델의 API를 사용해보기는 이번이 처음이기 때문에 가격이 대략 어느정도인지 파악하기 위해서이다. 혹시나 멋모르고 API 호출을 왕창 했다가 비용이 과도하게 청구되는 참사는 미연에 방지해야 한다(예전에 AWS의 RDS를 처음 사용했을 때 5만원이 청구되었던 뼈아픈 경험이 있기 때문이다).&lt;/p&gt;
&lt;p&gt;가격정책은 &lt;a href=&quot;https://openai.com/api/pricing/&quot;&gt;이곳&lt;/a&gt;에서 확인해 볼 수 있다. 제공하는 모델도 여러개이고, 텍스트냐 이미지냐에 따라서도 가격이 천차만별이기 때문에 감을 잡기가 쉽지 않았다. 이렇게 헷갈릴 때는 그냥 직접 사용해보면서 비용을 체감하는 편이 더 나은 것 같다. 계정을 로그인 하고 나서 API 키를 발급받아야 하는데, 이 과정은 공식 사이트에 잘 나와있으니 참고하면 된다.&lt;/p&gt;
&lt;p&gt;참고로, 예전에는 제공했었던 무료크레딧 정책이 현재는 중단된 것으로 보인다. 구글링을 통해 각종 커뮤니티를 살펴보니 다들 직접 결제를 하고 나서 사용하는 추세였다. 신용카드를 등록하고 나면 크레딧을 충전할 수 있는데 최소 금액은 5달러이다. 그래서 나도 처음에는 5달러를 충전해 놓고 시작했다. 그러면 대시보드에서의 Usage 탭에서 현재 계정의 사용량과 남은 금액에 대한 정보를 볼 수 있다.
&lt;img src=&quot;https://github.com/user-attachments/assets/6aae1d06-1690-416c-8529-d50df8dd62d6&quot; alt=&quot;dashboard&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Express API 서버 구성&lt;/h2&gt;
&lt;p&gt;이제 지난 포스팅에서 만들었던 프론트엔드 서버의 API 요청을 처리해줄 API 서버를 만들고자 한다. 서버는 Express를 사용하여 간단하게 구성할 것이다. 기본적인 예제 코드들은 &lt;a href=&quot;https://platform.openai.com/docs/guides/text-generation&quot;&gt;공식 사이트&lt;/a&gt;에서 제공해주기 때문에 참고하면 편리하다. 특히나 내가 원하는 프롬프트인 &apos;이미지 파일을 전달하면 해당 이미지를 분석&apos;하라는 내용도 아래와 같이 적혀있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
const openai = new OpenAI()
const completion = await openai.chat.completions.create({
  model: &amp;quot;gpt-4o&amp;quot;,
  messages: [
    {
      role: &amp;quot;user&amp;quot;,
      content: [
        { type: &amp;quot;text&amp;quot;, text: &amp;quot;What&amp;#39;s in this image?&amp;quot; },
        {
          type: &amp;quot;image_url&amp;quot;,
          image_url: {
            url: &amp;quot;https://{image_url}&amp;quot;,
          },
        },
      ],
    },
  ],
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;url&lt;/code&gt; 부분에는 이미지 경로 혹은 Base64 인코딩된 이미지 데이터를 넣어주면 되는데, 나는 프론트엔드에서 이미지를 받아올 것이기 때문에 이미지 데이터를 넣어줄 것이다. 추후에 유저가 원할 경우에 게시판 페이지에서 본인이 그린 이미지를 업로드할 수 있는 기능을 추가할 예정이지만, 현재로서는 모든 이미지를 서버에 업로드하는 로직은 부담스럽다고 생각했다.&lt;/p&gt;
&lt;p&gt;위 예시코드를 &lt;code class=&quot;language-text&quot;&gt;/api/chat&lt;/code&gt; 엔드포인트로 감싸서 작성하면 다음과 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
app.post(&amp;quot;/api/chat&amp;quot;, async (req, res) =&amp;gt; {
  try {
    const { imageData } = req.body;

    const chatCompletion = await client.chat.completions.create({
      messages: [
        {
          role: &amp;quot;user&amp;quot;,
          content: [
            {
              type: &amp;quot;text&amp;quot;,
              text: &amp;quot;What’s in this image? summarize it within 30 characters&amp;quot;,
            },
            {
              type: &amp;quot;image_url&amp;quot;,
              image_url: {
                url: imageData,
              },
            },
          ],
        },
      ],
      model: &amp;quot;gpt-4o-mini&amp;quot;,
    });

    res.json({
      response: chatCompletion.choices[0].message.content,
    });
  } catch (error) {
    console.error(&amp;quot;Error:&amp;quot;, error);
    res.status(500).json({ error: &amp;quot;서버 오류가 발생했습니다.&amp;quot; });
  }
});
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 내가 생각했던 부분은 크게 2가지다.&lt;/p&gt;
&lt;h4&gt;1. 프롬프트를 어떻게 작성할 것인가&lt;/h4&gt;
&lt;p&gt;이미지를 분석하여 텍스트로 요약해달라는 요청을 내려야 한다. 기본 예시 코드에서도 나와있다시피 &lt;code class=&quot;language-text&quot;&gt;&apos;What&apos;s in this image?&apos;&lt;/code&gt;라는 프롬프트를 사용하고 있다. 나는 이를 그대로 사용하기로 했다. 그러면서 뒤엔 30자 이내로 요약해달라는 요청을 추가하기로 했다. 별도의 제약을 걸지 않으면 생각보다 GPT가 투머치토크 성향이 있어서인지 너무 길게 답변을 해주는 경향이 있어서 그런 제약을 추가하기로 했다.&lt;/p&gt;
&lt;h4&gt;2. 어떤 모델을 사용할 것인가&lt;/h4&gt;
&lt;p&gt;OpenAI API에서 제공하는 모델이 여러 종류이기 때문에 어떤 모델을 선택하느냐도 중요한 문제이다. 이 프로젝트에서는 이미지파일을 input으로 넣어야 하는데, 모델마다 이미지를 input 으로 받을 수 없는 모델도 존재하기 때문에 이런 모델들은 당연히 제외된다. 이미지를 받을 수 있는 모델들은 &lt;a href=&quot;https://platform.openai.com/docs/models&quot;&gt;공식 문서&lt;/a&gt;상에서 &lt;code class=&quot;language-text&quot;&gt;multimodal model&lt;/code&gt; 이라는 키워드를 찾아볼 수 있다. 대표적으로 &lt;code class=&quot;language-text&quot;&gt;gpt-4o&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;gpt-4o-mini&lt;/code&gt;가 있다. 둘의 차이는 모델 사이즈와 가격에 있는데, 나는 모델 사이즈가 작고 가격이 저렴한 &lt;code class=&quot;language-text&quot;&gt;gpt-4o-mini&lt;/code&gt;를 선택하기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983310/blog/assets/5e5a8cf5-63b5-41d5-96d7-888a07376b64_ajxann.png&quot; alt=&quot;gpt-model-pricing&quot;&gt;&lt;/p&gt;
&lt;h2&gt;프론트엔드에서 API 요청 보내기&lt;/h2&gt;
&lt;p&gt;이제 백엔드의 API 작업은 마쳤으니 다시 프론트엔드로 돌아가서 방금 만든 엔드포인트로 요청을 보내보자.
&lt;code class=&quot;language-text&quot;&gt;useCanvas&lt;/code&gt; 훅에서 &lt;code class=&quot;language-text&quot;&gt;sendImage&lt;/code&gt; 함수에서 Base64로 인코딩된 이미지 데이터를 백엔드로 보냈다. 참고로 웹페이지에서 ChatGPT를 사용하면 언어를 설정할 수 있다는 점과는 달리, OpenAI API 는 오직 영어로 된 답변만 지원하고 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// api.ts
export const sendMessage = async (imageData: string) =&amp;gt; {
  const apiResponse = await api.post&amp;lt;{ response: string }&amp;gt;(&amp;quot;/chat&amp;quot;, {
    imageData,
  });
  return apiResponse.data.response;
};


/* *********/
// useCanvas.ts
...
 const getBase64Image = () =&amp;gt; {
    if (!canvasRef.current) return;
    return canvasRef.current.toDataURL(&amp;quot;image/png&amp;quot;);
  };

  const sendImage = async () =&amp;gt; {
    const imageData = getBase64Image();
    if (!imageData) {
      throw new Error(&amp;quot;Image data is not available&amp;quot;);
    }

    try {
      setIsMessageLoading(true);
      const response = await sendMessage(imageData);
      console.log(response);
      setMessage(response);
    } catch (error) {
      alert(&amp;quot;서버 오류가 발생했습니다.&amp;quot; + error);
    } finally {
      setIsMessageLoading(false);
    }
  };
  ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;백엔드 Github는 &lt;a href=&quot;https://github.com/hjhj97/gpt-drawing-quiz.backend&quot;&gt;이곳&lt;/a&gt;에서 확인해볼 수 있다.&lt;/p&gt;
&lt;h2&gt;드디어 테스트!&lt;/h2&gt;
&lt;p&gt;드디어 프론트엔드와 백엔드의 모든 작업이 끝났다. 이제 직접 그림을 그려서 GPT가 내 그림을 제대로 분석해는지 확인해보자. 내가 그림은 썩 잘 그리는 편은 아니지만, 그래도 나름 남들이 알아볼 수 있을 정도로는 그릴 수 있다고 확신하기 때문에 GPT도 별 무리없이 맞출 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;집을 그려서 GPT한테 무엇인지 물어보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983312/blog/assets/2028f8ae-4415-4f45-9fbb-9a3db962fcc0_t9jmtz.png&quot; alt=&quot;gpt-answer-1&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GPT Think: Office desk with laptop.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;응??? 이게 어딜봐서 책상 위에 있는 랩탑인거지?????&lt;/p&gt;
&lt;p&gt;이건 그림을 대충 그렸으니 못 맞출 수도 있다. 조금 더 신중하게 다시 그려보도록 하자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983311/blog/assets/37e9d201-d75e-4b8f-8349-0aabddb76987_zqk5zz.png&quot; alt=&quot;gpt-answer-2&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GPT Think: A minimalist cat drawing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아니 왜.....&lt;/p&gt;
&lt;p&gt;왜 이렇게 못 &lt;del&gt;그리는&lt;/del&gt; 맞추는 것인지 다음 포스팅에서 알아보도록 하자...&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Web Canvas API 활용하여 GPT와 캐치마인드 하기 (1 of 3)]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/react/241102-canvas-gpt-quiz-1-of-3/</link><guid isPermaLink="false">https://juheon.dev/react/241102-canvas-gpt-quiz-1-of-3/</guid><pubDate>Sat, 02 Nov 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;배경&lt;/h2&gt;
&lt;p&gt;고전 게임 중에서 캐치마인드 라는 그림을 그리는 게임이 있다. 매턴마다 돌아가면서 그림을 그리는 사람이 정해진다. 자기 차례가 돌아오면 특정 키워드가 랜덤으로 주어지며, 그 그림에 맞게 그림을 그리는 것이다. 나머지 사람들은 그 그림을 보고 키워드를 맞추면 점수를 얻는 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983311/blog/assets/94b015c3-a47d-4f93-92f1-eb702f15e5c1_h1uxfq.png&quot; alt=&quot;catch-mind&quot;&gt;
&lt;em&gt;출처 : 캐치마인드 개드립 걸작선 게시판&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이 게임 방식에서 착안하여 웹 페이지에서 그림 퀴즈를 내는 것이 가능할까 생각하게 되었다. 그래서 이번 사이드 프로젝트에서는 캐치마인드 게임을 웹 페이지에서 구현해보려고 한다. 그런데 나는 한가지 변주를 주려고 한다. 실제 캐치마인드 게임에서는 게임이 진행되기 위해서는 최소 3명이 있어야 한다. 하지만 바쁜 현대사회에서 사는 우리들은 3명을 기다릴 여유가 없다. 싱글플레이가 가능한 캐치마인드를 만들어 보려고 한다. 그럼 누가 문제를 맞추냐고? 그래서 그림을 맞추는 주체를 &apos;사람&apos; 이 아니라 GPT 로 바꿔보려고 한다.&lt;/p&gt;
&lt;p&gt;좀 더 기술적으로 풀어서 설명하자면, Web Canvas API(+React.js)를 활용하여 웹페이지에서 그림을 그린 다음, JPG나 PNG 파일로 저장하고 이를 OpenAI API에 전달하여 키워드를 추론하게 하는 방법이다.&lt;/p&gt;
&lt;h2&gt;프로젝트 준비&lt;/h2&gt;
&lt;p&gt;프론트엔드에서는 Vanilla JS 만으로도 Canvas API를 활용하여 그림을 그릴 수도 있지만, React.js를 활용하면 좀 더 편하게 그림을 그릴 수 있다. 또한, React.js를 활용하면 컴포넌트 단위로 관리할 수 있어서 코드의 가독성도 좋아진다. 따라서 이번 프로젝트에서는 React.js를 활용하여 그림을 그리는 방법을 사용하였다.&lt;/p&gt;
&lt;p&gt;백엔드에서는 Node.js(+Express)를 활용하였다. 사실 프론트엔드 -&gt; OpenAI API를 직접 호출해서 결과를 받아오는 것도 가능하지만 이를 위해선 호출 할 때 API_KEY를 넣어줘야 한다. 다음 포스팅에서도 언급하겠지만,현재 OpenAI에서 무료 크레딧을 제공하는 정책이 막힌 것으로 보여, API를 호출하기 위해서는 현재로선 과금을 할 수 밖에 없는 상태이다(나는 이번 프로젝트를 위해 실제로 과금을 진행했다).&lt;/p&gt;
&lt;p&gt;브라우저에서 API_KEY를 넣게 되면 사용자에게 노출될 수 밖에 없기 때문에, 별도의 백엔드 서버를 두어서 호출하기로 했다. 따라서 이번 프로젝트에서는 백엔드에서 Node.js(+Express)를 활용하여 호출하는 방법을 사용하였다.&lt;/p&gt;
&lt;h2&gt;React로 프론트엔드 페이지 구성&lt;/h2&gt;
&lt;p&gt;내가 프로젝트를 끌고나가는 방식 중에 선호하는 방식은, 처음에는 가장 쉽고 간단한 기능만 구현해본다. 이후에 조금 더 복잡한 기능을 덧붙여 나가는 방식이다. 따라서 이번 프로젝트에서는 가장 먼저 캔버스를 구성하는 방법을 설명하고, 이후에 조금 더 다양한 기능(색상 선택, 지우개, 이미지 저장, GPT 연동)을 덧붙여 나가는 방법을 설명하려고 한다.&lt;/p&gt;
&lt;h3&gt;Step 1. 기본 캔버스 구성&lt;/h3&gt;
&lt;p&gt;가장 먼저 캔버스, 즉 그림을 그릴 수 있는 영역을 구성해야 한다. 이를 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&gt;&lt;/code&gt; 태그를 사용하면 된다. 캔버스 태그는 그림을 그리는 영역을 정의하는 태그로, 웹 페이지에서 그림을 그리는 데 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983312/blog/assets/0178547a-c7a1-41cb-a795-3982d913a9e9_fxnsxe.png&quot; alt=&quot;step-1&quot;&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;Canvas.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Canvas.tsx
import React, { useRef, useEffect, useState } from &amp;quot;react&amp;quot;

interface CanvasProps {
  width?: number
  height?: number
}

const Canvas: React.FC&amp;lt;CanvasProps&amp;gt; = ({ width = 800, height = 600 }) =&amp;gt; {
  const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
  const [isDrawing, setIsDrawing] = useState&amp;lt;boolean&amp;gt;(false)
  const [context, setContext] = useState&amp;lt;CanvasRenderingContext2D | null&amp;gt;(null)

  useEffect(() =&amp;gt; {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext(&amp;quot;2d&amp;quot;)
    if (!ctx) return

    ctx.strokeStyle = &amp;quot;black&amp;quot;
    ctx.lineWidth = 2
    ctx.lineCap = &amp;quot;round&amp;quot;
    setContext(ctx)
  }, [])

  const startDrawing = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.beginPath()
    context.moveTo(offsetX, offsetY)
    setIsDrawing(true)
  }

  const draw = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!isDrawing || !context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.lineTo(offsetX, offsetY)
    context.stroke()
  }

  const stopDrawing = (): void =&amp;gt; {
    if (!context) return

    context.closePath()
    setIsDrawing(false)
  }

  return (
    &amp;lt;canvas
      ref={canvasRef}
      width={width}
      height={height}
      onMouseDown={startDrawing}
      onMouseMove={draw}
      onMouseUp={stopDrawing}
      onMouseOut={stopDrawing}
    /&amp;gt;
  )
}

export default Canvas&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;Step 2. 색상 선택 기능&lt;/h3&gt;
&lt;p&gt;아직까지는 검정색으로만 그림을 그릴 수 있다. 하지마 이는 너무 단조로우므로 색상을 선택할 수 있는 기능을 추가해보자. 이를 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;color&quot;&gt;&lt;/code&gt; 태그를 사용하여 색상을 선택할 수 있는 영역을 만들고, 이를 통해 선택한 색상을 캔버스에 적용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983316/blog/assets/fe033773-a234-457b-84e0-4d0e6414af08_cso9jn.png&quot; alt=&quot;step-2&quot;&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;Canvas.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { useRef, useEffect, useState } from &amp;quot;react&amp;quot;

interface CanvasProps {
  width?: number
  height?: number
}

const Canvas: React.FC&amp;lt;CanvasProps&amp;gt; = ({ width = 800, height = 600 }) =&amp;gt; {
  const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
  const [isDrawing, setIsDrawing] = useState&amp;lt;boolean&amp;gt;(false)
  const [context, setContext] = useState&amp;lt;CanvasRenderingContext2D | null&amp;gt;(null)
  const [currentColor, setCurrentColor] = useState&amp;lt;string&amp;gt;(&amp;quot;#000000&amp;quot;)

  useEffect(() =&amp;gt; {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext(&amp;quot;2d&amp;quot;)
    if (!ctx) return

    ctx.strokeStyle = currentColor
    ctx.lineWidth = 2
    ctx.lineCap = &amp;quot;round&amp;quot;
    setContext(ctx)
  }, [])

  useEffect(() =&amp;gt; {
    if (!context) return
    context.strokeStyle = currentColor
  }, [currentColor, context])

  const startDrawing = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.beginPath()
    context.moveTo(offsetX, offsetY)
    setIsDrawing(true)
  }

  const draw = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!isDrawing || !context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.lineTo(offsetX, offsetY)
    context.stroke()
  }

  const stopDrawing = (): void =&amp;gt; {
    if (!context) return

    context.closePath()
    setIsDrawing(false)
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div style={{ marginBottom: &amp;quot;1rem&amp;quot; }}&amp;gt;
        &amp;lt;label htmlFor=&amp;quot;colorPicker&amp;quot; style={{ marginRight: &amp;quot;0.5rem&amp;quot; }}&amp;gt;
          색상 선택:
        &amp;lt;/label&amp;gt;
        &amp;lt;input
          id=&amp;quot;colorPicker&amp;quot;
          type=&amp;quot;color&amp;quot;
          value={currentColor}
          onChange={e =&amp;gt; setCurrentColor(e.target.value)}
        /&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;canvas
        ref={canvasRef}
        width={width}
        height={height}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseOut={stopDrawing}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

export default Canvas&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;Step 3. 지우개 기능&lt;/h3&gt;
&lt;p&gt;현재까지는 그림을 그리는 기능만 있기 때문에 잘못 그리게 되면 페이지를 새로고침 해야하는 번거로움이 있다. 그래서 지울 수 있는 기능을 제공해보자. 지우개 기능이 활성화 되면 &lt;code class=&quot;language-text&quot;&gt;context.globalCompositeOperation&lt;/code&gt; 을 &lt;code class=&quot;language-text&quot;&gt;destination-out&lt;/code&gt; 으로 설정하여 지우개 모드를 활성화 한다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/592135d9-00f4-4ca8-a338-cfcd6a4a5eb3_jdrqtf.png&quot; alt=&quot;step-3&quot;&gt;&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;Canvas.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { useRef, useEffect, useState } from &amp;quot;react&amp;quot;

interface CanvasProps {
  width?: number
  height?: number
}

type DrawingMode = &amp;quot;draw&amp;quot; | &amp;quot;erase&amp;quot;

const Canvas: React.FC&amp;lt;CanvasProps&amp;gt; = ({ width = 800, height = 600 }) =&amp;gt; {
  const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
  const [isDrawing, setIsDrawing] = useState&amp;lt;boolean&amp;gt;(false)
  const [context, setContext] = useState&amp;lt;CanvasRenderingContext2D | null&amp;gt;(null)
  const [currentColor, setCurrentColor] = useState&amp;lt;string&amp;gt;(&amp;quot;#000000&amp;quot;)
  const [drawingMode, setDrawingMode] = useState&amp;lt;DrawingMode&amp;gt;(&amp;quot;draw&amp;quot;)

  useEffect(() =&amp;gt; {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext(&amp;quot;2d&amp;quot;)
    if (!ctx) return

    ctx.strokeStyle = currentColor
    ctx.lineWidth = 2
    ctx.lineCap = &amp;quot;round&amp;quot;
    setContext(ctx)
  }, [])

  useEffect(() =&amp;gt; {
    if (!context) return

    if (drawingMode === &amp;quot;erase&amp;quot;) {
      context.globalCompositeOperation = &amp;quot;destination-out&amp;quot;
      context.strokeStyle = &amp;quot;rgba(0,0,0,1)&amp;quot;
    } else {
      context.globalCompositeOperation = &amp;quot;source-over&amp;quot;
      context.strokeStyle = currentColor
    }
  }, [drawingMode, currentColor, context])

  const startDrawing = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.beginPath()
    context.moveTo(offsetX, offsetY)
    setIsDrawing(true)
  }

  const draw = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!isDrawing || !context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.lineTo(offsetX, offsetY)
    context.stroke()
  }

  const stopDrawing = (): void =&amp;gt; {
    if (!context) return

    context.closePath()
    setIsDrawing(false)
  }

  const toggleMode = () =&amp;gt; {
    setDrawingMode(prev =&amp;gt; (prev === &amp;quot;draw&amp;quot; ? &amp;quot;erase&amp;quot; : &amp;quot;draw&amp;quot;))
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
          &amp;lt;label htmlFor=&amp;quot;colorPicker&amp;quot; style={{ marginRight: &amp;quot;0.5rem&amp;quot; }}&amp;gt;
            색상 선택:
          &amp;lt;/label&amp;gt;
          &amp;lt;input
            id=&amp;quot;colorPicker&amp;quot;
            type=&amp;quot;color&amp;quot;
            value={currentColor}
            onChange={e =&amp;gt; setCurrentColor(e.target.value)}
            disabled={drawingMode === &amp;quot;erase&amp;quot;}
          /&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;button onClick={toggleMode}&amp;gt;
          {drawingMode === &amp;quot;draw&amp;quot; ? &amp;quot;지우개 모드&amp;quot; : &amp;quot;그리기 모드&amp;quot;}
        &amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{
          border: &amp;quot;1px solid black&amp;quot;,
          cursor: drawingMode === &amp;quot;erase&amp;quot; ? &amp;quot;crosshair&amp;quot; : &amp;quot;default&amp;quot;,
        }}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseOut={stopDrawing}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

export default Canvas&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h3&gt;Step 4. 이미지 저장 기능, hook으로 분리&lt;/h3&gt;
&lt;p&gt;캔버스에 그린 그림의 이미지를 저장하는 기능을 추가해보자. 이를 위해서는 &lt;code class=&quot;language-text&quot;&gt;canvas.toDataURL()&lt;/code&gt; 메서드를 사용하면 된다. 이 메서드는 캔버스에 그려진 이미지를 PNG 형식의 데이터로 변환된다. 그래서 &apos;이미지 저장&apos; 버튼을 누르면 로컬 저장소에 이미지가 저장된다.&lt;/p&gt;
&lt;p&gt;그리고 점점 캔버스에서 처리해야하는 비즈니스 로직이 늘어남에 따라 &lt;code class=&quot;language-text&quot;&gt;Canvas.tsx&lt;/code&gt; 파일이 복잡해지는 것을 방지하기 위해 &lt;code class=&quot;language-text&quot;&gt;useCanvas&lt;/code&gt; 이라는 훅으로 만들어서 분리하기로 했다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;Canvas.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Canvas.tsx
import React from &amp;quot;react&amp;quot;
import { useCanvas } from &amp;quot;../hooks/useCanvas&amp;quot;

interface CanvasProps {
  width?: number
  height?: number
}

const Canvas: React.FC&amp;lt;CanvasProps&amp;gt; = ({ width = 800, height = 600 }) =&amp;gt; {
  const {
    canvasRef,
    currentColor,
    drawingMode,
    startDrawing,
    draw,
    stopDrawing,
    setCurrentColor,
    toggleMode,
    saveImage,
  } = useCanvas({ width, height })

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;
          &amp;lt;label htmlFor=&amp;quot;colorPicker&amp;quot; style={{ marginRight: &amp;quot;0.5rem&amp;quot; }}&amp;gt;
            색상 선택:
          &amp;lt;/label&amp;gt;
          &amp;lt;input
            id=&amp;quot;colorPicker&amp;quot;
            type=&amp;quot;color&amp;quot;
            value={currentColor}
            onChange={e =&amp;gt; setCurrentColor(e.target.value)}
            disabled={drawingMode === &amp;quot;erase&amp;quot;}
          /&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;button onClick={toggleMode}&amp;gt;
          {drawingMode === &amp;quot;draw&amp;quot; ? &amp;quot;지우개 모드&amp;quot; : &amp;quot;그리기 모드&amp;quot;}
        &amp;lt;/button&amp;gt;

        &amp;lt;button onClick={saveImage}&amp;gt;이미지 저장&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{
          border: &amp;quot;1px solid black&amp;quot;,
        }}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseOut={stopDrawing}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

export default Canvas&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;useCanvas.ts&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useCanvas.ts
import { useRef, useState, useEffect } from &amp;quot;react&amp;quot;

type DrawingMode = &amp;quot;draw&amp;quot; | &amp;quot;erase&amp;quot;

interface UseCanvasProps {
  width: number
  height: number
}

export const useCanvas = ({ width, height }: UseCanvasProps) =&amp;gt; {
  const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
  const [isDrawing, setIsDrawing] = useState&amp;lt;boolean&amp;gt;(false)
  const [context, setContext] = useState&amp;lt;CanvasRenderingContext2D | null&amp;gt;(null)
  const [currentColor, setCurrentColor] = useState&amp;lt;string&amp;gt;(&amp;quot;#000000&amp;quot;)
  const [drawingMode, setDrawingMode] = useState&amp;lt;DrawingMode&amp;gt;(&amp;quot;draw&amp;quot;)

  useEffect(() =&amp;gt; {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext(&amp;quot;2d&amp;quot;)
    if (!ctx) return

    ctx.strokeStyle = currentColor
    ctx.lineWidth = 2
    ctx.lineCap = &amp;quot;round&amp;quot;
    setContext(ctx)
  }, [])

  useEffect(() =&amp;gt; {
    if (!context) return

    if (drawingMode === &amp;quot;erase&amp;quot;) {
      context.globalCompositeOperation = &amp;quot;destination-out&amp;quot;
      context.strokeStyle = &amp;quot;rgba(0,0,0,1)&amp;quot;
    } else {
      context.globalCompositeOperation = &amp;quot;source-over&amp;quot;
      context.strokeStyle = currentColor
    }
  }, [drawingMode, currentColor, context])

  const startDrawing = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.beginPath()
    context.moveTo(offsetX, offsetY)
    setIsDrawing(true)
  }

  const draw = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!isDrawing || !context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.lineTo(offsetX, offsetY)
    context.stroke()
  }

  const stopDrawing = (): void =&amp;gt; {
    if (!context) return

    context.closePath()
    setIsDrawing(false)
  }

  const toggleMode = () =&amp;gt; {
    setDrawingMode(prev =&amp;gt; (prev === &amp;quot;draw&amp;quot; ? &amp;quot;erase&amp;quot; : &amp;quot;draw&amp;quot;))
  }

  const saveImage = () =&amp;gt; {
    if (!canvasRef.current) return

    const date = new Date()
    const fileName = `drawing-${date.getFullYear()}${(date.getMonth() + 1)
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}${date.getDate().toString().padStart(2, &amp;quot;0&amp;quot;)}-${date
      .getHours()
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}${date.getMinutes().toString().padStart(2, &amp;quot;0&amp;quot;)}${date
      .getSeconds()
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}`

    const image = canvasRef.current.toDataURL(&amp;quot;image/png&amp;quot;)
    const link = document.createElement(&amp;quot;a&amp;quot;)
    link.download = `${fileName}.png`
    link.href = image
    link.click()
  }

  return {
    canvasRef,
    currentColor,
    drawingMode,
    startDrawing,
    draw,
    stopDrawing,
    setCurrentColor,
    toggleMode,
    saveImage,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;h2&gt;그 이후 구현&lt;/h2&gt;
&lt;p&gt;이 이후에는 본인의 입맛에 맞춘 스타일링과 기능등을 추가하면 될 것이다. 나는 우선 &lt;code class=&quot;language-text&quot;&gt;tailwindcss&lt;/code&gt;를 활용하여 최소한의 스타일링을 하고, 그 외에 &apos;색상 팔레트&apos;와 &apos;전체 지우기&apos; 기능을 추가하였다. 각종 버튼을 담당하는 UI는 별도 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;CanvasController.tsx&lt;/code&gt; 파일로 분리했다.&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;Canvas.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Canvas.tsx
import { useCanvas } from &amp;quot;../hooks/useCanvas&amp;quot;
import { CanvasController } from &amp;quot;./CanvasController&amp;quot;

interface CanvasProps {
  width?: number
  height?: number
}

const Canvas: React.FC&amp;lt;CanvasProps&amp;gt; = ({ width = 800, height = 600 }) =&amp;gt; {
  const {
    canvasRef,
    currentColor,
    drawingMode,
    startDrawing,
    draw,
    stopDrawing,
    setCurrentColor,
    toggleMode,
    saveImage,
    clearCanvas,
  } = useCanvas({ width, height })

  return (
    &amp;lt;div className=&amp;quot;flex flex-col gap-4&amp;quot;&amp;gt;
      &amp;lt;canvas
        ref={canvasRef}
        width={width}
        height={height}
        className={`
          border border-gray-300 rounded-lg
          ${drawingMode === &amp;quot;erase&amp;quot; ? &amp;quot;cursor-cell&amp;quot; : &amp;quot;cursor-crosshair&amp;quot;}
        `}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseOut={stopDrawing}
      /&amp;gt;
      &amp;lt;CanvasController
        currentColor={currentColor}
        drawingMode={drawingMode}
        setCurrentColor={setCurrentColor}
        toggleMode={toggleMode}
        saveImage={saveImage}
        clearCanvas={clearCanvas}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

export default Canvas&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;useCanvas.ts&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// useCanvas.ts
import { useRef, useState, useEffect } from &amp;quot;react&amp;quot;

type DrawingMode = &amp;quot;draw&amp;quot; | &amp;quot;erase&amp;quot;

interface UseCanvasProps {
  width: number
  height: number
}

// 색상 상수 추가
export const COLORS = {
  BLACK: &amp;quot;#000000&amp;quot;,
  RED: &amp;quot;#FF0000&amp;quot;,
  BLUE: &amp;quot;#0000FF&amp;quot;,
  GREEN: &amp;quot;#008000&amp;quot;,
  YELLOW: &amp;quot;#FFD700&amp;quot;,
} as const

export const useCanvas = ({ width, height }: UseCanvasProps) =&amp;gt; {
  const canvasRef = useRef&amp;lt;HTMLCanvasElement | null&amp;gt;(null)
  const [isDrawing, setIsDrawing] = useState&amp;lt;boolean&amp;gt;(false)
  const [context, setContext] = useState&amp;lt;CanvasRenderingContext2D | null&amp;gt;(null)
  const [currentColor, setCurrentColor] = useState&amp;lt;string&amp;gt;(COLORS.BLACK)
  const [drawingMode, setDrawingMode] = useState&amp;lt;DrawingMode&amp;gt;(&amp;quot;draw&amp;quot;)

  useEffect(() =&amp;gt; {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext(&amp;quot;2d&amp;quot;)
    if (!ctx) return

    ctx.strokeStyle = currentColor
    ctx.lineWidth = 2
    ctx.lineCap = &amp;quot;round&amp;quot;
    setContext(ctx)
  }, [])

  useEffect(() =&amp;gt; {
    if (!context) return

    if (drawingMode === &amp;quot;erase&amp;quot;) {
      context.globalCompositeOperation = &amp;quot;destination-out&amp;quot;
      context.strokeStyle = &amp;quot;rgba(0,0,0,1)&amp;quot;
    } else {
      context.globalCompositeOperation = &amp;quot;source-over&amp;quot;
      context.strokeStyle = currentColor
    }
  }, [drawingMode, currentColor, context])

  const startDrawing = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.beginPath()
    context.moveTo(offsetX, offsetY)
    setIsDrawing(true)
  }

  const draw = (e: React.MouseEvent&amp;lt;HTMLCanvasElement&amp;gt;): void =&amp;gt; {
    if (!isDrawing || !context) return

    const { offsetX, offsetY } = e.nativeEvent
    context.lineTo(offsetX, offsetY)
    context.stroke()
  }

  const stopDrawing = (): void =&amp;gt; {
    if (!context) return

    context.closePath()
    setIsDrawing(false)
  }

  const toggleMode = () =&amp;gt; {
    setDrawingMode(prev =&amp;gt; (prev === &amp;quot;draw&amp;quot; ? &amp;quot;erase&amp;quot; : &amp;quot;draw&amp;quot;))
  }

  const saveImage = () =&amp;gt; {
    if (!canvasRef.current) return

    const date = new Date()
    const fileName = `drawing-${date.getFullYear()}${(date.getMonth() + 1)
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}${date.getDate().toString().padStart(2, &amp;quot;0&amp;quot;)}-${date
      .getHours()
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}${date.getMinutes().toString().padStart(2, &amp;quot;0&amp;quot;)}${date
      .getSeconds()
      .toString()
      .padStart(2, &amp;quot;0&amp;quot;)}`

    const image = canvasRef.current.toDataURL(&amp;quot;image/png&amp;quot;)
    const link = document.createElement(&amp;quot;a&amp;quot;)
    link.download = `${fileName}.png`
    link.href = image
    link.click()
  }

  const clearCanvas = () =&amp;gt; {
    if (!context || !canvasRef.current) return

    // 캔버스 전체 지우기
    context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height)
  }

  return {
    canvasRef,
    currentColor,
    drawingMode,
    startDrawing,
    draw,
    stopDrawing,
    setCurrentColor,
    toggleMode,
    saveImage,
    clearCanvas,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;details&gt;
&lt;summary&gt;
&lt;code&gt;CanvasController.tsx&lt;/code&gt;
&lt;/summary&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// CanvasController.tsx
import React from &amp;quot;react&amp;quot;
import { COLORS } from &amp;quot;../hooks/useCanvas&amp;quot;
import { useCanvasController } from &amp;quot;../hooks/useCanvasController&amp;quot;

interface ColorButtonProps {
  color: string
  isSelected: boolean
  onClick: () =&amp;gt; void
  disabled?: boolean
}

const ColorButton: React.FC&amp;lt;ColorButtonProps&amp;gt; = ({
  color,
  isSelected,
  onClick,
  disabled,
}) =&amp;gt; (
  &amp;lt;button
    onClick={onClick}
    disabled={disabled}
    className={`
      w-8 h-8 rounded-full transition-all
      ${isSelected ? &amp;quot;ring-2 ring-offset-2 ring-gray-400&amp;quot; : &amp;quot;&amp;quot;}
      ${disabled ? &amp;quot;opacity-50 cursor-not-allowed&amp;quot; : &amp;quot;hover:scale-110&amp;quot;}
    `}
    style={{ backgroundColor: color }}
    aria-label={`Select ${color} color`}
  /&amp;gt;
)

interface CanvasControllerProps {
  currentColor: string
  drawingMode: &amp;quot;draw&amp;quot; | &amp;quot;erase&amp;quot;
  setCurrentColor: (color: string) =&amp;gt; void
  toggleMode: () =&amp;gt; void
  saveImage: () =&amp;gt; void
  clearCanvas: () =&amp;gt; void
}

export const CanvasController: React.FC&amp;lt;CanvasControllerProps&amp;gt; = props =&amp;gt; {
  const {
    currentColor,
    drawingMode,
    setCurrentColor,
    toggleMode,
    saveImage,
    clearCanvas,
  } = useCanvasController(props)

  return (
    &amp;lt;div className=&amp;quot;flex items-center gap-4&amp;quot;&amp;gt;
      &amp;lt;div className=&amp;quot;flex items-center gap-2&amp;quot;&amp;gt;
        &amp;lt;span className=&amp;quot;mr-2&amp;quot;&amp;gt;색상:&amp;lt;/span&amp;gt;
        &amp;lt;div className=&amp;quot;flex gap-2&amp;quot;&amp;gt;
          {Object.entries(COLORS).map(([name, color]) =&amp;gt; (
            &amp;lt;ColorButton
              key={color}
              color={color}
              isSelected={currentColor === color}
              onClick={() =&amp;gt; setCurrentColor(color)}
              disabled={drawingMode === &amp;quot;erase&amp;quot;}
            /&amp;gt;
          ))}
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;button
        onClick={toggleMode}
        className={`
          px-4 py-2 rounded-md text-white transition-colors
          ${
            drawingMode === &amp;quot;erase&amp;quot;
              ? &amp;quot;bg-red-500 hover:bg-red-600&amp;quot;
              : &amp;quot;bg-blue-500 hover:bg-blue-600&amp;quot;
          }
        `}
      &amp;gt;
        {drawingMode === &amp;quot;draw&amp;quot; ? &amp;quot;지우개 모드&amp;quot; : &amp;quot;그리기 모드&amp;quot;}
      &amp;lt;/button&amp;gt;

      &amp;lt;button
        onClick={saveImage}
        className=&amp;quot;px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-md transition-colors&amp;quot;
      &amp;gt;
        이미지 저장
      &amp;lt;/button&amp;gt;

      &amp;lt;button
        onClick={clearCanvas}
        className=&amp;quot;px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-white rounded-md transition-colors&amp;quot;
      &amp;gt;
        전체 지우기
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/details&gt;
&lt;p&gt;프론트엔드 페이지의 Github은 &lt;a href=&quot;https://github.com/hjhj97/gpt-drawing-quiz.frontend&quot;&gt;이곳&lt;/a&gt;에서 확인해 볼 수 있다.&lt;/p&gt;
&lt;p&gt;다음 포스팅에서부터는 OpenAI API를 사이트에서 API_KEY를 발급받고 express를 기반으로 간단한 API 서버를 구성할 것이다. 이를 통해 캔버스에 그린 그림을 저장하고, 이를 OpenAI API에 전달하여 키워드를 추론하는 방법을 설명하려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Nuxt3의 렌더링 모드]]></title><description><![CDATA[이 포스팅은 Comparing Nuxt 3 Rendering Modes: SWR, ISR, SSR, SSG, SPA…]]></description><link>https://juheon.dev/vue/241018-nuxt-rendering-mode/</link><guid isPermaLink="false">https://juheon.dev/vue/241018-nuxt-rendering-mode/</guid><pubDate>Fri, 18 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;이 포스팅은 &lt;a href=&quot;https://blog.risingstack.com/nuxt-3-rendering-modes/&quot;&gt;Comparing Nuxt 3 Rendering Modes: SWR, ISR, SSR, SSG, SPA&lt;/a&gt;를 기반으로 재구성했습니다.&lt;/p&gt;
&lt;p&gt;이 프로젝트의 데모 페이지는 &lt;a href=&quot;https://nuxt-rendering-test-clhqu1bfq-hjhj97s-projects.vercel.app/&quot;&gt;이곳&lt;/a&gt; 에서 확인할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;기본 환경설정&lt;/h2&gt;
&lt;p&gt;이번 프로젝트에서는 &lt;code class=&quot;language-text&quot;&gt;Nuxt3&lt;/code&gt;가 제공하는 5가지의 렌더링 모드를 살펴보고자 한다. 각 페이지마다 2종류의 timestamp를 표시할 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;HTML이 서버에서 렌더링된 시간&lt;/li&gt;
&lt;li&gt;hydration을 완료한 시간(=브라우저에서 페이지를 완성한 시간)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;예를들어 SSR페이지에서는 아래와 같이 표시한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!--ssr.vue--&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;SSR&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Server Rendered Time {{ data }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;Hydration Time : {{ new Date().toUTCString() }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
  const { data } = await useFetch(&amp;quot;/api/hello&amp;quot;)
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 이를 확인하기 위해 &lt;code class=&quot;language-text&quot;&gt;/server/api/hello.ts&lt;/code&gt; 경로상에 현재 시간을 반환하는 간단한 API 함수를 작성하여 각 페이지에서 호출하려고 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// /server/api/hello.ts
export default defineEventHandler(event =&amp;gt; {
  return new Date().toUTCString()
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;각 페이지별로 렌더링 모드를 설정하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;routeRules&lt;/code&gt; 객체 안에 경로별로 명시해주면 된다(자세한건 아래에서 설명 예정)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export default defineNuxtConfig({
  ssr: true,
  routeRules: {
    &amp;quot;/isr-5&amp;quot;: { isr: 5 },
    &amp;quot;/isr-no-ttl&amp;quot;: { isr: true },
    &amp;quot;/swr-5&amp;quot;: { swr: 5 },
    &amp;quot;/swr-no-ttl&amp;quot;: { swr: true },
    &amp;quot;/csr&amp;quot;: { ssr: false },
    &amp;quot;/prerender&amp;quot;: { prerender: true },
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;CSR(SPA)&lt;/h2&gt;
&lt;p&gt;첫 번재로 Clinet Side Rendering(Single Page Application)을 살펴보자.&lt;br&gt;
CSR은 클라이언트(브라우저)가 렌더링을 담당하기 때문에 서버는 번들파일만 전달할 뿐, HTML파일을 렌더링하는 데에는 관여하지 않는다. 개발자도구의 Network 탭에서 보내준 doc파일을 확인하더라도 텅 비어있는 HTML 파일만 전달받았는 사실을 알 수 있다. 따라서 Server Rendered Time은 존재하지 않는다(첨부한 이미지에서 Server Render Time은 클라이언트에서 호출된 것이다)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983309/blog/assets/10cafdef-206e-4309-81fd-6bc9a069c32c_naojq5.png&quot; alt=&quot;nuxt-csr&quot;&gt;
한편 Hydration Time은 클라이언트 사이드에서 API를 직접 호출하여 DOM을 그렸으므로 API 응답시간과 일치한다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 에서는 설정하고자 하는 경로상에 &lt;code class=&quot;language-text&quot;&gt;{ ssr : false }&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  routeRules: {
    ...
    &amp;quot;/csr&amp;quot;: { ssr: false },
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;SSR&lt;/h2&gt;
&lt;p&gt;Server Side Rendering은 말 그대로 서버에서 직접 HTML을 렌더링하여 클라이언트에게 전달한 뒤에 클릭과 같은 상호작용을 위해서 hydration 과정이 진행된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983316/blog/assets/d976c00e-ad39-496e-805c-0823a11654dc_qui1xw.png&quot; alt=&quot;nuxt-ssr&quot;&gt;&lt;/p&gt;
&lt;p&gt;페이지에 접속하면 최초로 전달받은 HTML파일(이미지 우측에 개발자도구에서 보이는 시간)상으로는 Rendered Time과 Hydration Time이 일치하는 것처럼 보인다.&lt;br&gt;
하지만 사람들에게 실제로 보이는 화면(이미지 좌측)에서는 미세하게 Hydration Time이 Rendered Time보다 느리다는 걸 확인해볼 수 있는데, 이는 HTML파일을 받으면 브라우저에서 hydration이 진행되기 때문에 &lt;code class=&quot;language-text&quot;&gt;new Date()&lt;/code&gt;가 한번 더 실행되어 DOM에 다시 반영되기까지의 딜레이라고 생각해볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 에서는 설정하고자 하는 경로상에 &lt;code class=&quot;language-text&quot;&gt;{ ssr : true }&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  routeRules: {
    ...
    &amp;quot;/ssr&amp;quot;: { ssr: true },
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;SSG&lt;/h2&gt;
&lt;p&gt;Static Site Generation 은 빌드 당시에만 HTML이 렌더링되며 그 이후에는 재접속하더라도 리렌더링되지 않는다. 따라서 Rendered Time은 빌드된 시점으로 고정되어 있다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983314/blog/assets/c02fabeb-052a-43b3-a284-b6f3e279da34_x5ac4n.png&quot; alt=&quot;nuxt-ssg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 에서는 설정하고자 하는 경로상에 &lt;code class=&quot;language-text&quot;&gt;{ prerender : true }&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  routeRules: {
    ...
    &amp;quot;/ssg&amp;quot;: { prerender: true },
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;SWR&lt;/h2&gt;
&lt;p&gt;Stale While Reavalidate은 SSG와 SSR의 특성을 섞어놓은 방식이다. 기본적으로는 SSG처럼 정적 페이지를 제공하지만, 개발자가 지정해놓은(혹은 미지정) 주기마다 다시 페이지를 빌드하여 최신 버전의 정적 페이지로 업데이트 해놓는다. 만약 주기를 지정해놓지 않으면(No TTL) 컨텐츠의 내용이 바뀌기 전까지는 캐싱한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Nuxt.js&lt;/code&gt;의 SWR은 &lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt;의 ISR 개념과 유사하다.(&lt;code class=&quot;language-text&quot;&gt;Nuxt.js&lt;/code&gt;의 ISR과는 조금 차이가 있는데 밑에서 설명하겠다).&lt;/p&gt;
&lt;h3&gt;No TTL&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/ae4aab8c-830c-4876-994b-3e07d9de58db_a3hytp.gif&quot; alt=&quot;swr-no-ttl&quot;&gt;&lt;/p&gt;
&lt;p&gt;TTL을 설정해놓지 않으면 컨텐츠가 바뀔 때마다 페이지가 새롭게 빌드된다. 이 예제에서는 페이지가 1초마다 바뀌므로 그때마다 새롭게 페이지가 빌드된다.&lt;/p&gt;
&lt;h3&gt;5 seconds TTL&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983315/blog/assets/d66e54b6-97c9-4c80-be79-324600ea5a80_vgczbj.gif&quot; alt=&quot;swr-ttl&quot;&gt;&lt;/p&gt;
&lt;p&gt;5초 주기로 설정해놓게 되면 5초동안 접속하는 요청에 대해서는 동일한 정적 페이지를 서빙하게 된다. 실질적으로 변경되는 부분은 HTTP의 &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;max-age=5&lt;/code&gt;에 해당한다. 5초가 지난 이후의 요청에 대해서는 우선 캐싱되어있는 stale 상태의 페이지를 서빙하고, 백그라운드에서는 새로운 버전의 페이지를 준비한다. 빌드가 완료되고 난 이후에는 새로운 버전의 페이지를 받을 수 있게 된다.&lt;/p&gt;
&lt;h4&gt;업데이트 판단&lt;/h4&gt;
&lt;p&gt;업데이트 여부를 판단하는 원리를 간단하게 설명하자면 다음과 같다.&lt;br&gt;
특정 페이지에 최초로 접속해서 HTTP 요청을 보내면 페이지의 버전별로 가지고 있는 고유한 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt; 값이 HTTP Response Header에 담겨서 전달받게 된다. 이후에 재요청을 보내게 되면 Request Header 의 &lt;code class=&quot;language-text&quot;&gt;If-None-Match&lt;/code&gt; 속성에 현재 페이지 버전의 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt; 값을 담아서 서버로 보낸다.&lt;br&gt;
서버에서는 이 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt; 값과 최신 페이지 버전의 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt; 값을 비교하여 동일한 버전이라면 &apos;현재 페이지를 그대로(캐싱된 값) 사용해도 좋다&apos;라는 의미로 &lt;code class=&quot;language-text&quot;&gt;304 Not Modified&lt;/code&gt; 를 응답으로 보낸다.&lt;br&gt;
단, 여기서 5초가 지난 상태라면 백그라운드에서는 새로운 데이터(페이지)를 재생성하도록 요청을 보낸다. 재생성이 완료되면 새로운 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt;가 생성될 것이므로 이후 요청에서는 새로운 페이지로 교체된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 에서는 설정하고자 하는 경로상에 &lt;code class=&quot;language-text&quot;&gt;{ swr : number | boolean }&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  routeRules: {
    ...
    &amp;quot;/swr-no-ttl&amp;quot;: { swr: true },
    &amp;quot;/swr-5&amp;quot;: { swr: 5 },
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;ISR&lt;/h2&gt;
&lt;p&gt;ISR은 큰 틀에서는 SWR과 거의 유사하지만 중요한 차이점은 Vecel 이나 Netlify에서 제공해주는 CDN 캐시를 활용한다는 점이다. 만약 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 값으로 설정되면 CDN 캐시에 저장되어 있는 컨텐츠를 다음 배포전까지 사용하게 된다. 특정 플랫폼에 종속적인 렌더링 모드이므로 해당 플랫폼을 사용하는것이 아니라면 SWR과 차이는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nuxt.config.ts&lt;/code&gt; 에서는 설정하고자 하는 경로상에 &lt;code class=&quot;language-text&quot;&gt;{ isr : number | boolean }&lt;/code&gt; 로 설정하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  routeRules: {
    ...
    &amp;quot;/isr-5&amp;quot;: { isr: 5 },
    &amp;quot;/isr-no-ttl&amp;quot;: { isr: true },
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.risingstack.com/nuxt-3-rendering-modes/&quot;&gt;https://blog.risingstack.com/nuxt-3-rendering-modes/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nuxt.com/docs/guide/concepts/rendering&quot;&gt;https://nuxt.com/docs/guide/concepts/rendering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[신분당선의 속도제한]]></title><description><![CDATA[내가 신분당선을 오랫동안 타오면서 매번 느끼는 점은 속도제한 90km…]]></description><link>https://juheon.dev/essay/241013-shinbundang/</link><guid isPermaLink="false">https://juheon.dev/essay/241013-shinbundang/</guid><pubDate>Sun, 13 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;내가 신분당선을 오랫동안 타오면서 매번 느끼는 점은 속도제한 90km를 정말 악착같이 지키려고 한다는 점이다. 신분당선은 무인으로 운영되기 때문에 가속과 감속 방식은 미리 프로그래밍되어 있으리라 추측한다(물론 일부는 사람이 직접 중앙통제 하겠지만). 이 부분에 크게 불편함을 느껴본 적은 없지만 속도제한에 대해서는 시스템상으로 매우 엄격하게 lock 이 걸려있는 것 같다.&lt;/p&gt;
&lt;p&gt;신분당선 객차안에 모니터 상에는 속도가 표시되는데, 90km를 넘기면 곧바로 브레이크를 작동시켜 속도를 떨어뜨린다. 문제는 이 브레이크의 강도가 꽤 세기 때문인지 서있는 사람들은 모두 몸이 휘청일 정도이다. 그렇게 속도를 떨어뜨리고 나서 3초정도 지나면 다시 90km를 넘겨서 브레이크를 작동시켜 또 몸이 휘청인다. 이러한 가속과 감속의 울렁임은 다음 역에 도착할 때까지 계속 반복된다. 예민한 사람이라면 다들 신분당선을 타면서 이러한 불편한 승차감을 직접 체감했을 것이다.&lt;/p&gt;
&lt;p&gt;왜 이런 방식의 로직으로 설계되었는지 의아하다. 90km를 넘기면 정말 엄청난 큰일이라도 나는걸까? 하다못해 브레이크 작동 방식이라도 조금 매끄럽게 수정하면 훨씬 승차감이 나아질텐데 말이다. 만약 열차가 아니라 일반 승용차를 이런 방식으로 운전한다면 실로 비효율적인 운전이 아닐 수 없다. 가속페달을 밟다가 특정 속도에 도달하면 브레이크를 밟으면 그만큼의 동력손실이 생기기 때문이다. 코드 관점으로 가속/감속 방식을 생각해보면 아래 유사코드처럼 가장 단순무식한 형태로 코딩되지 않았을까 싶다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;while(!다음역 도착)
  if(speed &amp;gt;= 90) 브레이크()
  else 가속()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제 현업에서는 내가 모르는 중대한 기술적 문제로 인해 이러한 방식이 불가피할수는 있다.하지만 개발자 입장에서는 떠올리기 쉬운 로직일지는 모르지만, 그 &lt;strong&gt;로직이 적용되고 있는 현장에서는 예상치 못한 불편함이 따라올 수도 있다&lt;/strong&gt;는 점을 항상 명심해야한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[<img>와 background-image 의 차이점]]></title><description><![CDATA[vs background-image HTML상에 이미지를 첨부하는 방법에는 크기  태그와 CSS의  속성을 부여하는 2가지 방법이 있다. 이 둘의 차이점에 대해서 찾아보았다. stackoverflow…]]></description><link>https://juheon.dev/html_css/241009-img-vs-background-image/</link><guid isPermaLink="false">https://juheon.dev/html_css/241009-img-vs-background-image/</guid><pubDate>Wed, 09 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; vs background-image&lt;/h2&gt;
&lt;p&gt;HTML상에 이미지를 첨부하는 방법에는 크기 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 태그와 CSS의 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; 속성을 부여하는 2가지 방법이 있다. 이 둘의 차이점에 대해서 찾아보았다. stackoverflow 에 검색을 해보면 예전에도 비슷한 주제로 여러 사람들이 질문을 올린 글들을 찾아볼 수 있다. 그 중에서 가장 간단명료하게 정리해놓은 답변은 아래와 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; : content&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; : design&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 태그는 컨텐츠이고 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt;는 디자인 이라고 생각하면 된다는 뜻이다. 그렇다면 이 둘의 차이는 무엇일까?&lt;/p&gt;
&lt;p&gt;일단 첫 번째로 접근성(accessibility)의 차이가 있다. 스크린리더로 웹페이지를 읽는 경우에 &lt;code class=&quot;language-text&quot;&gt;img&lt;/code&gt; 태그는 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성을 참고하여 정보를 제공할 수 있는데 반해, &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt;는 별도의 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성이 존재하지 않기 때문에 이미지에 대한 정보를 알 수 없다. 따라서 이미지가 페이지의 컨텐츠에 중요한 맥락을 제공하는 경우라면 반드시 &lt;code class=&quot;language-text&quot;&gt;img&lt;/code&gt; 태그를 사용하도록 하자.&lt;/p&gt;
&lt;p&gt;비슷한 원리로 SEO의 측면에서도 차이가 있다. 검색엔진이 이미지의 정보를 가져갈 때 &lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt; 속성을 참고하므로 SEO에 유리한 쪽은 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt; 라고 할 수 있다. 반면 글의 내용과 관련없이 순전히 디자인 목적으로만 첨부된 이미지들은 &lt;code class=&quot;language-text&quot;&gt;background-image&lt;/code&gt; 로 설정하면 된다고 한다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17288500/img-vs-background-image-css-in-performance&quot;&gt;https://stackoverflow.com/questions/17288500/img-vs-background-image-css-in-performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/492809/when-to-use-img-vs-css-background-image&quot;&gt;https://stackoverflow.com/questions/492809/when-to-use-img-vs-css-background-image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maheshkonne.medium.com/html-img-tag-vs-css-background-image-23f9e2e9c8aa&quot;&gt;https://maheshkonne.medium.com/html-img-tag-vs-css-background-image-23f9e2e9c8aa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[왜 fetch 함수는 await를 2번 해야 하는걸까?]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/js_ts/241008-why-fetch-await-twice/</link><guid isPermaLink="false">https://juheon.dev/js_ts/241008-why-fetch-await-twice/</guid><pubDate>Mon, 07 Oct 2024 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt; 함수&lt;/h2&gt;
&lt;p&gt;자바스크립트의 내장함수인 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt;를 사용하여 데이터를 갖고 오기 위해서는 아래 코드와 같이 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 두번 사용해야 한다는 번거로움이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const response = await fetch(&amp;quot;/api&amp;quot;)
const data = await response.json()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;왜 굳이 이렇게 만들었을까 하는 의문이 생긴다. 처음부터 한 번의 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;로 데이터를 갖고오게끔 만들면 더 편리했을텐데 말이다.&lt;/p&gt;
&lt;p&gt;그 이유는 HTTP 요청의 특성을 생각해보면 짐작할 수 있다. HTTP 요청은 header와 body 로 구성되어 있다. header 상에는 요청 메소드의 종류와 응답결과, 상태코드 등이 담겨 있다. 보통 header의 용량이 body의 용량보다 작을 것이므로 더 먼저 응답결과를 받아볼 수 있다는 점을 염두에 두고 아래 공식 문서를 살펴보자.&lt;/p&gt;
&lt;p&gt;mdn의 fetch &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&quot;&gt;공식문서&lt;/a&gt;에서는 아래와 같이 설명하고 있다.&lt;br&gt;
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983316/blog/assets/fetch-mdn_fqb83d.png&quot; alt=&quot;fetch-mdn&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;fetch()&lt;/code&gt; 메소드는 당신이 fetch 하려는 리소스가 있는 경로라는 한 개의 필수적인 인자만 받는다. 그것은 해당 요청을 resolve 할 수 있는 &lt;code class=&quot;language-text&quot;&gt;Response&lt;/code&gt;객체를 내놓는 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 반환한다 - &lt;strong&gt;서버가 header로 응답을 받자마자&lt;/strong&gt; - 설령 서버의 응답이 error 상태라 하더라도.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;fetch()&lt;/code&gt; 는 body는 신경쓰지 않고 일단 header만 도착하게 되면 응답할 수 있는 상태를 준비해준다는 것이다. 그리고 body안에 들어있는 데이터를 받기 위해서는 그때 비로소 &lt;code class=&quot;language-text&quot;&gt;Response.json()&lt;/code&gt;함수를 호출하면 된다는 뜻이다. 또한 만약에 header의 응답결과가 error 로 받았다면 우리는 body 를 아예 받지 않아도 되므로 네트워크 리소스를 절약할 수도 있다.&lt;/p&gt;
&lt;p&gt;이처럼 fetch 메소드는 데이터를 받는 단계를 두 단계로 나눠놓는 이유는 HTTP 요청의 특성을 생각해보면 납득할 수 있다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tomontheinternet.com/why-two-awaits/&quot;&gt;https://tomontheinternet.com/why-two-awaits/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#concepts_and_usage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[2024년 반기 회고]]></title><description><![CDATA[부끄럽지만 이전 글이었던 '2023년 회고' 다음으로 쓰는 글이 올해 반기 회고 글이다. 일에 치이다보니 개발 블로그에 글 쓰는 일에 소홀했다. 회사 업무 작년 1…]]></description><link>https://juheon.dev/essay/240805-2024-first-review/</link><guid isPermaLink="false">https://juheon.dev/essay/240805-2024-first-review/</guid><pubDate>Mon, 05 Aug 2024 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;부끄럽지만 이전 글이었던 &apos;2023년 회고&apos; 다음으로 쓰는 글이 올해 반기 회고 글이다. 일에 치이다보니 개발 블로그에 글 쓰는 일에 소홀했다.&lt;/p&gt;
&lt;h2&gt;회사 업무&lt;/h2&gt;
&lt;p&gt;작년 10월에 입사하여 온보딩 기간을 거친 후, 올해 초부터 본격적으로 실제 개발 업무에 투입이 되었다. 처음 맡은 일은 SEO 개선 작업이었다. 개발자도구 Lighthouse 검사를 수백번씩 돌려가면서 점수를 조금씩 올려 나갔다. 마지막으로 SEO 100점을 찍었을 때는 마치 게임에서 최종보스를 잡고 클리어하는 듯한 쾌감을 느꼈다.&lt;/p&gt;
&lt;p&gt;그 다음 태스크는 랜딩페이지 로딩속도 개선이었다. 기존 랜딩페이지는 레거시가 쌓여있어 개발자도구 Network 기준 약 2초 중반대의 로딩속도를 보여주고 있었다. CSR의 특성상 한번에 많은 chunk 데이터를 받아와야 하고, 용량이 큰 이미지들도 받아와야 헸기 때문에 오래 걸릴 수밖에 없었다. 나는 부분적으로 작업하면서 1차적으로는 폰트 리소스의 용량을 줄여 1.2초대까지 줄였고, 2차로 CSR -&gt; SSR(Nuxt) 기반으로 옮기면서 훨씬 더 시간을 줄일 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;이밖에도 유사 인플루언서 추천, 영상 캠페인, 리워드 제안하기 등의 신규 피쳐를 개발했다. 또한 리팩토링과 같은 레거시 정리 작업도 적지 않았다. 둘 중에 어떤 업무가 더 재밌냐고 묻는다면 솔직히, 아니 당연히 신규 피쳐를 개발하는 일이 훨씬 더 재미있다. 예전에 작성된 히스토리조차 알 수 없는 코드를 들여다 보는 일에 썩 재미를 붙이기란 쉽지 않다. 또한 리팩토링이라는 게 아무리 내가 시간을 들여서 열심히 하더라도 사용자 입장에선 차이가 체감되지 않는 경우가 대부분이다(차이를 체감할 수 있는 리팩토링은 둘 중 하나이다. 엄청 잘했거나, 엄청 잘못되었거나).&lt;/p&gt;
&lt;p&gt;특히 영상 캠페인을 작업할 때는 당초 예상했던 개발기간인 한달 반을 훌쩍 넘어서 3달 넘게 진행되었다. 그 중 한달이 넘는 기간동안은 리팩토링을 하는데 할애했다. 기존 코드는 SNS플랫폼의 종류가 인스타그램과 네이버블로그 2종류만 존재했던 과거의 상황에 맞춰져 하드코딩된 부분이 많아 릴스,유튜브,틱톡과 같은 신규 플랫폼을 추가하는 일이 어려웠기 때문이다.&lt;br&gt;
굳이 리팩토링하지 않고서 개발하는 선택지가 있기는 했지만 나는 그로 인한 사이드이펙트가 더 커질 것이라고 판단했다. 앞으로 신규 플랫폼이 추가될 때마다 코드의 복잡성이 기하급수적으로 늘어날 것이기 때문이다. 소위 &apos;모래성 위에 모래성 쌓기&apos;인 상황을 방지하기 위해서 당장은 시간이 더 소요되더라도 리팩토링이 필요하다고 판단했다.&lt;/p&gt;
&lt;p&gt;회사의 프로덕트가 대부분 구독형 B2B Saas 이다보니 개발자와 유저와의 거리가 가까운 편은 아니다. 커머스 같은 서비스라면 외부에서 랜덤하게 유입될 수 있는 잠재 고객이 있겠지만, B2B Saas 프로덕트를 필요로 하는 고객층은 극히 한정되어있고 쓸 사람만 돈 내고 쓰고 안 쓸 사람은 이탈하는 경향이 강하기 때문이다. 그래서인지 나도 어떻게하면 사용자들과 최대한 가까운 거리에서 허들을 낮춰 만날 수 있을지를 고민했던 것 같다.&lt;/p&gt;
&lt;h2&gt;권고사직&lt;/h2&gt;
&lt;p&gt;갑자기 뜬금없는 전개인데 7월 말에 회사로부터 권고사직 통보를 받았다. 실제로 그 소식을 전해들은 나 역시도 어안이 벙벙했다. 경영 악화로 인한 인건비를 감축해야 한다는 것이 이유였다. 회사의 수익구조상 프로덕트는 적자가 계속 누적되고 있었고, 이를 다른팀의 수익으로 메꾸는 상황이 지속되고 있다가 한계에 다다라서 결국 터져버린 것이다. 그렇다고 프로덕트가 완전히 서비스종료 하는 건 아니고 최소한의 유지보수를 위한 개발인원만 남겨두고 나를 포함한 나머지 인원은 모두 짐을 싸야하는 상황이 되었다.&lt;/p&gt;
&lt;p&gt;나도 회사의 사정을 이해하고 덤덤하게 받아들이기로는 했지만 마음이 착잡해지는 건 사실이다. 긴 시간은 아니지만 약 10개월 남짓한 기간동안 프로덕트에 애착을 갖고 노력을 쏟아부었다. 목표기간까지 피쳐를 완성하기 위해서 야근과 주말근무도 했고, 버그 리포트가 나오면 밤이건 쉬는 날이건 할 것없이 집에서 디버깅하고 핫픽스를 배포하기도 했다. 이런 고생이 돈을 더 받는다거나 남들에게 인정을 받기 위해서가 아니다. 내가 관여하고 있는 프로덕트를 조금이라도 더 나은 방향으로 개선하고 싶은 욕심이 있었기 때문이다.&lt;br&gt;
개발자마다 직업의 성취를 느끼는 기준은 각자 다르겠지만 나에게는 프로덕트와 사용자가 맞닿아있는 사이의 지점에서 상호작용하는 순간이 해당된다. 프로덕트에 기여하고 있다는 확신만 든다면 내가 고생하더라도 자부심을 가지고 일할 수 있었다.&lt;/p&gt;
&lt;p&gt;공교롭게도 지난 포스팅에서 이 회사에 들어오게 된 가장 큰 이유는 바로 스타트업의 &apos;낭만&apos;을 좇기 위해서라고 밝혔다. 성공할지 실패할지도 모르는 불확실성이라는 파도에 내 커리어를 맡겨보고 싶었다. 이 무모한 도전이 지금 시점에서는 판정패를 받은 것으로 보인다. 솔직히 말해서 작년 이맘때 쯤 &apos;합격통보를 받은 다른 회사에 들어갔더라면?&apos; 하는 또다른 평행세계를 떠올려 보곤 한다. 최소한 권고사직을 당했을리는 없을테니 말이다.&lt;/p&gt;
&lt;p&gt;그렇다고 이제와서 생각한들 뭐가 달라지겠는가. 지나간 과거를 탓하기보단 거기서 무엇을 얻었는지와 앞으로 어떻게 해야할지를 고민하는 게 정신건강에 더 도움이 된다. 일단 내가 얻은 가장 큰 수확은 동료들과 협업하는 경험을 얻었다. 첫 직장에서는 프론트를 거의 나 혼자서 도맡아서 개발했기 때문에 브랜치 전략이나 커뮤니케이션 방법을 익히기에 한계가 있었지만 이번 회사에서는 프론트 뿐만 아니라 백엔드, 데이터, 마케팅팀과 같이 하면서 이 2가지의 필요성을 절감하고 익힐 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;또한 일회성 개발 성격이 강한 외주 프로젝트가 아닌 회사에서 서비스하는 프로덕트를 개발하다보니 코드퀄리티와 유지보수에도 더 신경쓰게 되고 코드리뷰를 받으면서 내가 미처 신경쓰지 못했던 부분에 대해 다른 개발자들의 피드백을 받을 수 있던 점이 값진 경험이었다.&lt;/p&gt;
&lt;h2&gt;앞으로의 계획&lt;/h2&gt;
&lt;p&gt;앞으로 당분간은 쉬면서 이력서를 정리하려고 한다. 1년 전이나 지금이나 개발자 취업시장은 여전히 어렵기 때문에 긴 호흡을 갖고 여유롭게 생각하는게 마음이 편하다. 무엇보다도 멘탈을 잘 추스려서 멘붕에 빠져있지 않고 다시 달릴 수 있도록 준비해야겠다. 이번 권고사직이 현재 시점에서는 고난일지는 몰라도 개발자 커리어에선 그저 스쳐 지나가는 해프닝에 불과할지도 모른다. 남들은 쉽게 겪어보지 못했던 경험을 해봤으니 내 인생이 더 재밌어졌다고 생각해보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2023년 회고]]></title><description><![CDATA[조금 뒷북이지만 지나간 2023년을 되돌아보고 2024년은 어떻게 보낼 지 정리해보려고 한다. 퇴사 2022년 6월부터 학생 인턴으로 다니기 시작했던 회사는 1년을 다니다가 지난…]]></description><link>https://juheon.dev/essay/240120-review-2023/</link><guid isPermaLink="false">https://juheon.dev/essay/240120-review-2023/</guid><pubDate>Sat, 20 Jan 2024 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;조금 뒷북이지만 지나간 2023년을 되돌아보고 2024년은 어떻게 보낼 지 정리해보려고 한다.&lt;/p&gt;
&lt;h2&gt;퇴사&lt;/h2&gt;
&lt;p&gt;2022년 6월부터 학생 인턴으로 다니기 시작했던 회사는 1년을 다니다가 지난 6월에 퇴사하였다. 대단한 이유 때문은 아니고, 단지 내가 더 넓고 깊은 경험이 필요하다고 판단해서였다. 회사의 프로젝트는 시간이 지나고 나의 숙련도는 쌓여갈수록 업무가 점점 단순해지고 기술적으로도 도전해볼만한 여지도 적었다. 만약 내 성향이 안정 지향적이었다면 계속 머물러있기에는 좋은 업무환경일 수는 있었지만, 나는 안정만 추구하려고 개발자가 된 건 아니다.&lt;/p&gt;
&lt;p&gt;개발을 하면서 여러가지 암초에도 부딪히면서 문제를 해결해 나가고, 새로운 기술도 배우면서 자신이 발전해 나가고 있다는 성취감이 개발자로서 느낄 수 있는 가장 큰 매력이라고 생각하며 나 또한 이런 낭만을 추구하기 위해서 개발자라는 진로를 선택했다. 그래서 업무가 익숙해지고 스스로가 정체되었다고 느껴질 때 변화를 줘야겠다고 마음을 먹게 되었다.&lt;/p&gt;
&lt;h2&gt;휴식, 졸업, 공부&lt;/h2&gt;
&lt;p&gt;당초에는 6월에 퇴사를 하고 나서 최대한 빠른 시일 내로 다른 회사로 이직하는 것이 목표였다. 하지만 당장은 꽤나 지쳐있는 상태였다. 몸보다는 오히려 정신이 더 지쳐있는 상태였다. 업무를 하면서도 강박에 시달렸었기 때문에 자기 자신을 괴롭히곤 했다. 그때 나에게는 휴식이 절실히 필요했다.&lt;/p&gt;
&lt;p&gt;그래서 퇴사를 하고나서 1달 동안은 거의 아무 것도 하지 않고 재충전을 하는 데에만 집중했다. 친구들과 여행도 다니고 보고 싶었던 영화들도 이 시기에 다 정주행하는 등 평소에 시간이 없어서 밀려있었던 일들을 모두 해치울 수 있었다.&lt;/p&gt;
&lt;p&gt;그러면서도 틈틈이 이직을 위한 준비도 하고있었다. 나의 이력서는 일주일에 한번씩 고쳐쓰면서 일종의 &apos;이력서 최적화&apos; 작업을 수행하고 있었고, 이 이력서를 바탕으로 꾸준히 회사에도 지원하고 있었다. 그렇다고 막무가내로 공고가 뜨는 모든 회사에 지원하는 건 무의미하다고 생각하였고, 내 나름대로 기준을 설정하여 이에 부합하는 회사 위주로 지원했다. (이직 과정에 대한 상세한 설명은 추후 포스팅에서 소개할 예정이다.)&lt;/p&gt;
&lt;p&gt;그러는 사이 8월이 되었다. 나는 이미 2월에 대학교 졸업 유예를 걸어놓았었고, 다시 한번 유예를 연장할지 아니면 졸업을 확정할 것인지 결정해야 했다. 그 전에 이직을 완료했다면 고민없이 졸업했겠지만 아직까지는 취업(이직)준비생 신분이기 때문에 마음 편하게 한번 더 미루고 싶은 마음도 있었다.&lt;/p&gt;
&lt;p&gt;마음이 오락가락하기를 몇 번 반복하다가 그냥 졸업하기로 마음 먹었다. 졸업을 계속 미루면서 안전영역에 머물러 있으려는 건, 애시당초에 회사를 이직하려는 목적과도 맞지 않았기 때문이다. 이왕 마음을 먹은 김에 아예 배수의 진을 치고 모험을 하는게 맞다고 생각했다. 지금 생각해보면 무모하다 싶을 정도로 배짱이 두둑했는데, 결과적으로 보면 금새 이직은 성공했으니 나름 효과가 있었다고 볼 수도 있다.&lt;/p&gt;
&lt;h2&gt;이직&lt;/h2&gt;
&lt;p&gt;새 회사로는 10월에 이직했다. 이전 회사에 퇴사한 지 4달이 지난 후다. 예상보다 오래 걸리긴 했지만 채용시장의 상황이 너무나 차가웠기 때문에 오히려 4달 정도면 선방했다고 생각될 정도다.&lt;/p&gt;
&lt;p&gt;사실 현재 회사(편의상 A로 칭함)로 합격하기 전에 이미 다른 B회사의 최종 합격까지 받았고, 실제로 80%이상 B회사로 마음이 기운 상태였다. 그래서 처음 A회사로부터 1차 면접 제안을 받았을 당시에도 &apos;이미 B를 붙었는데 굳이 봐야하나&apos; 생각이 들었다. 그래도 나를 좋게 봐준 A회사에 대한 최소한의 예의이자, 면접 경험치도 쌓을 겸 해서 가벼운 마음으로 면접에 응했다. 그런데 왠걸, 1차 통과 후 2차 기술면접과 3차 최종면접까지 통과하여 합격을 받았다. 좀 얼떨떨한 기분이었는데 아무튼 선택지로 회사 한 군데가 늘었다는 건 나에게도 호재이다.&lt;/p&gt;
&lt;p&gt;여기서 선택의 갈림길에 서게 되었다. 이전에 합격한 B회사는 인원과 매출규모는 꽤나 큰 편이었고 비즈니스도 나름 안정적인 궤도로 들어선 상태였다. A회사의 규모는 그 보다는 작은 편이었고 비즈니스도 아직 안정적이라기 보다는 그 방향을 향해 열심히 달려나가고 있는 상태였다.&lt;/p&gt;
&lt;p&gt;다만 B회사는 어느정도 연차가 있었고 기술적인 레거시도 쌓여있었다(면접 당시에 면접관에게 질문했던 내용이었다). 그래서 내가 입사하더라도 맡게될 일은 새로운 피쳐를 개발하는 쪽보다는 기존에 잘 돌아가고 있는 시스템을 유지보수하거나 일부 레거시를 개편하는 정도였다.&lt;/p&gt;
&lt;p&gt;반면에 A회사는 이제 막 새로운 피쳐를 치열하게 개발하고 있는 시기였다. 레거시도 전혀 없는 건 아니었지만, 그로 인해 스트레스를 받을 정도는 아닌 상태였다. 따라서 내가 들어간다면 본격적으로 피쳐를 개발할 수도 있고, 새로운 기술도 (도입이 합리적이라면)얼마든지 쓸 수 있는 환경이었다.&lt;/p&gt;
&lt;p&gt;이 두 회사 사이에서 너무나도 고민되었다.결국 이 상황도 요약하자면 &lt;strong&gt;안정적 회사&lt;/strong&gt; vs &lt;strong&gt;도전적 회사&lt;/strong&gt;이었다. 둘 중에서 어느 회사를 선택했는지는 이 포스팅에서 열심히 쌓아올린 빌드업을 보면 눈치챘겠지만, 나는 도전을 택하기로 했다.&lt;/p&gt;
&lt;p&gt;애초에 기존 회사를 퇴사한 이유부터 나는 &apos;안정&apos;을 버리고 &apos;도전&apos;이라는 낭만을 택하기 위해서였다. 현실 앞에서 낭만은 금새 죽어버린다고는 하지만, 그럼에도 나는 미련하게 나의 낭만을 믿어보기로 했다. 설령 내 선택이 잘못되었다고 한들, 그때 다시 일어나면 된다. 지금이 아니면 언제 낭만을 쫓아보겠는가?&lt;/p&gt;
&lt;h2&gt;올해 잘한 점 / 부족한 점&lt;/h2&gt;
&lt;p&gt;2023년에 잘한 점은 아무래도 인생 첫 이직을 잘 마무리 했다는 점이다. 이력서를 수십번 고쳐쓰면서 채용시장이 어려웠음에도 불구하고 몇몇회사는 기술면접을 보고 경험치를 쌓을 수 있었다. 대부분 떨어지기는 했지만 앞으로 내 커리어를 쌓는데에 있어서는 좋은 밑바탕이 되리라고 생각한다. 그 밖에도 주말같은 개인시간에도 공부를 꾸준히 했다는 점 역시 좋은 습관으로 굳힐 수 있어서 다행이다. 남는 시간에 공부든 운동이든 습관을 형성하는 일이 참 중요하다고 느낀다.&lt;/p&gt;
&lt;p&gt;부족한 점을 꼽자면 신체/멘탈 관리였던 것 같다. 사실 몸이 아픈 날은 많지 않았다. 1월 1일부터 코로나 증상(음성이긴 했지만)으로 인해 3~4일 시름시름 앓느라 회사를 빠진 것 말고는 1년 중에서 일을 못할 정도로 아프거나 다친 적은 없었다.&lt;/p&gt;
&lt;p&gt;몸보다는 멘탈을 더 신경써야 할 것 같다. 아직까지도 업무강박 + 욕심이 있어서 그런지 스스로에게 엄격한 잣대를 들이미느라 평일날 퇴근 이후는 물론이고 주말에도 계속 업무생각을 떨쳐내기가 힘들다. 현재 회사는 재택근무를 제약없이 원하는대로 할 수 있음에도 불구하고 나는 꾸준히 사무실 출근을 고집하는 이유도 &apos;일&apos;과 &apos;삶&apos;을 최대한 분리하기 위해서이다. 이를 지키기 위한 가장 중요한 방법이 바로 &apos;일&apos;하는 물리적 공간의 분리라고 생각한다.&lt;/p&gt;
&lt;p&gt;오직 사무실에서만 일하고, 퇴근하고 집에 돌아가면 최대한 일 생각을 하지 않으려고 노력한다. ON/OFF 스위치 마냥 켜고 끄고 싶은데 현실적으로 쉽지는 않다. 그래서 2024년에는 스스로 욕심을 절제해 나가면서 자신의 멘탈을 갉아먹지 않는 게 중요할 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[shake! 출제 및 운영 후기]]></title><description><![CDATA[2022-02-20에 작성된 원문을 수정한 버전입니다 poster 지난 1월 15일, '2021 경인지역 6개대학 연합프로그래밍 경시대회'인 shake…]]></description><link>https://juheon.dev/essay/231011-shake-prepare-review/</link><guid isPermaLink="false">https://juheon.dev/essay/231011-shake-prepare-review/</guid><pubDate>Wed, 11 Oct 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2022-02-20에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/209&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983320/blog/assets/poster_ck6x2y.jpg&quot; alt=&quot;poster&quot;&gt;&lt;/p&gt;
&lt;p&gt;지난 1월 15일, &apos;2021 경인지역 6개대학 연합프로그래밍 경시대회&apos;인 shake! 가 열렸다. 지금 글을 쓰는 시점과는 시간이 꽤 흐르긴 했는데 나름대로 &lt;del&gt;고통스러운&lt;/del&gt; 흥미로운 경험을 하기도 했고, 회고할 만한 일도 있었다고 생각하기에 지금이 되어서야 후기를 남기게 되었다.&lt;/p&gt;
&lt;h2&gt;배경&lt;/h2&gt;
&lt;p&gt;내가 소속된 아주대학교 소학회 A.N.S.I.는 2015년부터 shake! 대회를 주관하고 있다. 내가 입학한 2017년 이전에는 잘 모르겠지만, 2017년 이후로는 A.N.S.I.의 회장이 shake!의 대회 운영을 맡는 게 관례였다.&lt;br&gt;
다만 회장이 shake! 대회에 참가를 하게 되는 경우, 운영 과정이 매끄럽지 않을 수도 있다는 점이 우려되어 이런 경우에는 별도의 인원이 대신 대회 운영을 맡을 수밖에 없었다. 이번 대회가 정확히 이 케이스에 해당되었고 결국 내가 대회 운영을 맡게 되었다. 전년도(2020년)에 회장직을 맡다가 도중에 군 입대로 인해 회장직의 소임을 다하지 못하고, 나 대신 고생해준 다른 분들에게 미안함과 책임감 때문이라도 내가 맡는 게 맞다고 생각했다.&lt;/p&gt;
&lt;h2&gt;시작&lt;/h2&gt;
&lt;p&gt;원래 이상적인 방향대로라면 나는 운영 파트만 담당하고 출제 파트는 (내가 포함되지 않은) 출제진들이 담당하는 것이다. 하지만 이렇게 진행할 경우 큰 문제가 하나 있다. 그건 바로 학교로부터 &apos;운영 업무에 대한 급여&apos;를 받을 수 없다는 것이다. 정확한 학교 사정은 모르겠지만, 예전부터 오직 &apos;운영&apos;업무 만으로는 급여를 받을 수 없다는 안내를 받았기 때문에 어쩔 수 없이 나는 &lt;strong&gt;운영도 하면서 출제도 해야하는&lt;/strong&gt;, 양다리를 걸칠 수밖에 없는 상황이다(출제진은 급여가 나오기 때문이다).&lt;/p&gt;
&lt;p&gt;그렇다면 누군가 &apos;운영도 하면서 출제 하는 게 뭐가 힘듦?&apos;이라고 되물을 수도 있겠다. 하지만 shake!는 운영 난이도가 그리 호락호락 하지가 않다. 사실 난이도가 어렵다기보다는 자잘하게 신경써야 할 일이 정말 많다. 왜냐하면 6개 대학이 합쳐서 하나의 대회를 만드는 특수성때문에 하나의 사안을 두고도 각 학교의 대표인들에게 동의를 구해야만 진행할 수 있다. 즉 하나의 의사결정 과정을 처리함에 있어서 단순 교내 프로그래밍 경시대회보다도 훨씬 복잡하고 시간도 많이 소요된다.&lt;/p&gt;
&lt;p&gt;게다가 더 큰 산이 하나 더 남아있었으니, 바로 대회 &lt;strong&gt;후원사를 섭외해야한다&lt;/strong&gt;는 점이다. 교내 대회인 APC는 학교 자체 후원으로 진행되었지만 shake!는 대대적으로 &apos;산학 연계&apos;라는 기조로 이어져왔기 때문에 매년 후원사를 두세군데 섭외해왔다. 후원사가 먼저 &apos;저희가 대회 후원해드릴게요~&apos; 먼저 나서주면 좋으련만 안타깝게도 그런 사례는 거의 없었다.&lt;/p&gt;
&lt;p&gt;지금까지는 대부분 대회 운영 담당자(나 같은 포지션)가 이곳저곳에 후원 제안 메일을 뿌리면서 직접 맨땅에 헤딩하는 식으로 업체를 섭외해왔다. 물론 아무 업체에 제안을 한 건 아니고 주로 졸업하신 선배분들의 직장을 위주로 메일을 보냈기 때문에 섭외 성공 확률이 조금은 높았을 수는 있겠으나 거절도 적잖게 당했었다. 아무튼 운영 담당자는 후원 업체를 섭외하는 데도 부담스러울 수 밖에 없는 노릇이었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983320/blog/assets/manage-structure_rd1bks.png&quot; alt=&quot;manage&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;내가 해야할 일은 위와 같았다&lt;/p&gt;
&lt;p&gt;그래도 뭐 어쩌겠는가. 결국에는 내가 해야한다. &apos;하다보면 어떻게든 되겠지&apos;라는 심정으로 시작했다.&lt;/p&gt;
&lt;h2&gt;출제를 하자&lt;/h2&gt;
&lt;p&gt;기왕 출제를 맡게 되었으니 즐거운 마음으로 하고자 마음을 먹었다. 출제진은 약 (2021년) 10월 초에 꾸려졌으며, 지난 대회 수상자와 타 대학 출제진으로 나를 포함해 총 5명으로 이루어졌다. 나도 APC 출제 경험이 있고 다들 출제 경험이 어느정도 있었기에 수월하지 않을까라고 예상했다.&lt;/p&gt;
&lt;p&gt;출제 프로세스는 먼저 2주 간격으로 3번씩 선제를 진행하여 문제 pool을 모으고 이 중에서 대회에 출제할 문제를 확정 짓는다. 문제를 확정 짓고 나면 각자 본인이 맡은 문제를 대회 출제 플랫폼인 polygon 에서 데이터를 작업한다. 데이터 작업이 완료되면 대회 플랫폼인 BOJ의 대회 준비 플랫폼인 BOJ stack에 문제를 옮긴 후 최종적으로 문제를 다듬은 뒤에 검수를 맡기면 된다.&lt;/p&gt;
&lt;p&gt;다만 출제 과정이 쉽지 않다. 지난 두 번의 APC 출제에서 익히 경험했었다. 가장 큰 난관은 내가 &apos;어떤 문제를 내야할까&apos;이다. 사람마다 문제를 내는 성향도 각기 다르다.&lt;br&gt;
보통 두 부류로 나뉘는데 하나는 상황을 먼저 생각한 뒤에 문제화 시키는 방식과, 반대로 문제를 먼저 생각한 뒤에 상황을 끼워 맞추는 방식이 있다. 둘 중 어느 방식이 더 좋다고는 말은 못하겠으나 나 같은 경우에는 주로 후자의 방식으로 출제해왔다. 나는 특정 자료구조나 알고리즘같은 틀을 하나 생각해놓고 이 틀에 맞는 상황을 위에 덧씌우는 방식으로 한다.&lt;/p&gt;
&lt;p&gt;보통은 출제 기간 전부터 &apos;이 분야를 출제하고 싶다&apos;로 마음 속에 염두에 두는 몇 문제가 있었는데, 이번 대회는 교내 대회인 APC가 끝난 직후에 바로 출제에 들어가다보니 쉽지가 않았다. 이미 내 머릿속에 있는 문제 pool은 고갈된 상태였는데 여기서 억지로 문제를 짜내야 하는 상황이었다. 그렇게 계속 머리를 굴려보다가 수직선상에서의 선분을 겹치는 문제를 내보고 싶다는 생각이 강하게 들어서 이쪽으로 방향을 틀었다.&lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;union-find&lt;/code&gt; 를 활용한 선분겹치기 문제를 내고 싶어서 문제 상황을 만들어봤는데, 나중에 선제 과정에서 얘기를 하면서 굳이 &lt;code class=&quot;language-text&quot;&gt;union-find&lt;/code&gt;를 쓰지 않고도 더 쉬운 풀이가 있다는 걸 알았다. 그래서 이 문제를 고수할 지 다른 새로운 문제를 만들지를 결정해야했다. 평소대로라면 새로운 문제를 만들려고 시도해봤을텐데 이번엔 그러질 못했다.&lt;br&gt;
아무래도 출제뿐만 아니라 다른 업무도 겸해야하고, 무엇보다 머릿속에 문제가 완전 고갈된 상태였기 때문에 자신이 없었다. 그래서 처음 나온 문제를 디벨롭하기로 결정했다.&lt;/p&gt;
&lt;p&gt;10월 말에 1차 선제를 진행했다. 대회 전체 문제수는 통상적으로 8문제를 내는데 여기서는 예상보다 많은 13문제나 나왔다. 선제 과정에서는 출제진들끼리 각 문제를 두고 문제의 솔루션이나 난이도, 그리고 대회장에서 참가자들이 어떻게 받아들일지를 토의한다. 그래서 어떤 문제는 너무 typical 하다거나, 혹은 디스크립션이 이해하기 어렵다거나 하는 식으로 피드백을 주고 받는다.&lt;/p&gt;
&lt;p&gt;1차 선제는 가장 처음으로 하는 토의고 출제진간의 시각 차이가 크므로 이 과정이 길어질 수밖에 없다. 이 과정에서 나의 (문제를 만든)발상과 나의 워딩이 다른 사람들에게 어떻게 전달되는지를 파악할 수 있는 좋은 기회라고 생각한다.&lt;br&gt;
예를 들어 본인 입장에선 멋진 발상으로 만든 문제인 줄 알았는데 알고보니 뻔한 문제였다라든가, 문제 설명만 보고 누구나 다 이해할 줄 알았는데 실제로는 난해하다는 평을 받기도 한다.&lt;/p&gt;
&lt;p&gt;그렇게 2차,3차 선제를 거듭하면서 문제 pool중에서 출제할 만한 &apos;옥석&apos;같은 문제을 가리고 다듬는 과정이 반복하면서 최종적으로 9문제가 선정되었다. 문제 선정까지 완료되면 출제 플랫폼인 polygon에서 문제 데이터를 위한 또다른 업무가 시작된다. 이 과정 역시 사람들의 학교 시험기간이 겹치면서 2주가량 소요되었다.&lt;/p&gt;
&lt;p&gt;출제상의 오류는 없는지 확인하기 위해서 외부인의 검수 과정도 필요하다. 데이터 작업까지 모두 끝나고나서 검수를 시작할 수도 있지만, 시간이 촉박했기 때문에 데이터 작업과 검수를 동시에 시작했다. 문제의 디스크립션 상의 모호한 점이나, 대회의 체감 난이도, 데이터의 엣지 케이스와 카운터 케이스를 미리 피드백 받을 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;이 험난한 과정을 거친 뒤에 나온 문제들은 아래에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/category/detail/2984&quot;&gt;출제된 문제 (BOJ)&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;후원사를 구해야한다&lt;/h2&gt;
&lt;p&gt;12월 초중순쯤 되자 데이터 작업도 완료하며 출제 프로세스는 어느 정도 막바지에 이르렀다. 이제 본격적으로 후원 업체를 섭외하러 가야한다. 그 전에 다행히도 몇 가지 희소식이 있었다. 첫 번째는 11월에 내가 네이버 D2에 대회 후원 요청 메일을 보냈는데, 후원해줄 의향이 있다고 답장이 온 것이다! D2는 지난 대회에서도 여러번 후원해준 사례도 있었고 대체로 대학생 행사 후원에 대해서 상당히 호의적이다.&lt;/p&gt;
&lt;p&gt;그리고 두 번째는 소학회 담당 교수님께서 우리만 괜찮다면 네트워크를 활용하여 후원기업을 섭외를 도와주실 수도 있다고 말씀해주셨다. 나는 당연히 교수님께 도움을 요청드렸고 덕분에 한시름 놓을 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;그래도 가만히 앉아서 안주하고 있기에는 혹시나 섭외가 틀어질 수도 있는 상황을 대비해야 했기에 다른 업체 한 곳만 더 찾아보기로 했다. 여러 업체가 물망에 올랐는데(대부분 졸업 선배와 연계된 곳) 작년 대회를 후원해준 업체에 한번 더 요청을 드리기로 했다.&lt;/p&gt;
&lt;p&gt;이곳 역시 졸업 선배님이 계신 곳이었기 때문에, 페이스북 메신저로 개인적으로 연락을 드려봤는데 안타깝게도 답장이 없으셨다(아마 확인을 못하셨던 것 같다). 그리고 그 무렵에 학교로부터 (교수님이 말씀하신대로) 후원기업을 찾았다는 연락을 받았기 때문에 우선 대회를 개최할 수 있는 최소한의 후원 기업은 확보되었다. 그래서 그냥 그만둘까 싶기도 했는데 그래도 혹시 모르는 심정으로 회사 대표 메일로 &apos;후원 제안 메일&apos;을 보냈다.&lt;/p&gt;
&lt;p&gt;회사의 정문을 내가 쿵쿵 두드린 것과 마찬가지인 행위여서 좀 무모했다고 생각했다. 선배님께 직접 이 메일이 닿게 될 지도 확신할 수 없었다.며칠동안 답장이 없어서 그냥 거절당했구나 생각했다.&lt;br&gt;
그러다가 일주일 만에 답장을 받았다! 다행히 회사에 계신 선배님까지 닿아서 직접 연락할 수 있게 되었다. 회사도 후원에 대해서 긍정적이라는 뜻을 전달받고 학교 측과 연결해주었다. 정말 다행이다 싶었다. 메일을 보내길 잘한 것 같다.&lt;/p&gt;
&lt;h2&gt;수 많은 잡다한 일&lt;/h2&gt;
&lt;p&gt;12월 말쯤 되었을 땐 후원사 섭외랑 출제 부분같은 큼직한 부분은 해결이 되었지만 아직 수많은 작고 작은 일들이 산적해있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이제 학교별 대회 참가자 명단을 받아야 한다. 그리고 감독해줄 각 학교별 스태프도 구해야한다.&lt;/li&gt;
&lt;li&gt;대회 포스터도 만들어야 한다. 사실 처음부터 만든 건 아니고 작년에 쓰던 포스터 시안을 내가 살짝만 바꿨다. 썸네일에 걸려있는 포스터가 내가 바꾼 버전이다.&lt;/li&gt;
&lt;li&gt;BOJ에 문제의 최종 버전을 확인받고 대회용 계정을 받아야한다.&lt;/li&gt;
&lt;li&gt;참가자들에게 대회 안내 메일을 발송해야 한다.&lt;/li&gt;
&lt;li&gt;온라인 대회이므로 zoom 을 통한 회의실 배정과 대회 매뉴얼도 만들어서 공지해야한다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shake.codes&quot;&gt;대회 페이지&lt;/a&gt;를 수정해야 한다.&lt;/li&gt;
&lt;li&gt;후원사 등장 문제를 만들어야 한다. 조금 늦게 결정되는 바람에 새로운 문제를 만들 여력은 없었고, 내가 기존에 출제했던 문제의 디스크립션을 각색하는 방향으로 했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;대회 당일, 사회자&lt;/h2&gt;
&lt;p&gt;대회 당일이 되었다. 나는 그 날 대회 개회식의 사회자 역할을 맡게 되었다. 살다보니 이런 날도 온다. 개회식은 온라인 생방송으로 진행되고 대회 참가자들과 교수님들이 참석하시는 나름 부담감 넘치는 자리이다. 이런 곳에서 내가 사회를 해야 한다니... 처음에는 아무렇지 않을 줄 알았는데 생방송 시간이 다가오니 살짝 떨리더라.&lt;br&gt;
물론 스크립트가 있고 나는 그냥 따라 읽으면 되는 간단한 역할이기는 한데 생방송이기도 하고 참가자들 앞이 아니라 카메라 앞에서 하려니깐 더 긴장되었던 것 같다. 차라리 오프라인으로 하는 게 훨씬 편할 것 같다.&lt;/p&gt;
&lt;p&gt;그렇게 무사히 개회식이 끝나고 약간의 휴식시간 뒤에 대회가 시작되었다. 대회가 진행되는 도중에는 &apos;제발 문제에 출제오류가 없기를...&apos;하면서 계속 빌고 있었다. 아무리 검수를 거친다고는 하지만, 검수 과정에서도 필터되지 않은 오류가 있기도 마련이다. 그 오류가 제발 이번 대회만큼은 피해가기를 빌었다. 다행히 대회가 끝날 때까지 아무런 오류는 없었다. 그리고는 스코어보드를 공개하며 수상자를 발표했고 대회의 모든 일정이 마무리되었다. 다 끝나고나니 긴장이 싹 풀리면서 안도의 한숨을 내쉬었다. 지난 3달간 바쁘게 달려온 행사가 드디어 막을 내리게 된 것이다.&lt;/p&gt;
&lt;h2&gt;대회가 끝난 뒤&lt;/h2&gt;
&lt;p&gt;대회가 끝나고 난 뒤에도 여전히 할 일은 남아있다. 대회 스태프와 검수진들의 급여를 지급하기 위한 각종 서류들을 취합해서 학교에 전달해야 한다. 그리고 대회 수상자 목록도 정리해서 알려줘야 하고, 출제진들이 각자 출제한 문제들의 풀이를 슬라이드로 만들고 나는 이것들을 한꺼번에 모아서 merge한 후에 배포해야 한다. 마지막으로 참가자들에게 대회 종료 및 결과 안내 전체 메일을 발송하면 내가 할 일은 모두 마무리 된다.&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;h4&gt;1. 서류지옥,서류지옥...&lt;/h4&gt;
&lt;p&gt;작성해야할 서류가 정말 어마무시하게 많다. 덕분에 한동안 내 컴퓨터의 바탕화면은 서류파일로 가득 차 있었다.&lt;/p&gt;
&lt;h4&gt;2. 코로나 이슈&lt;/h4&gt;
&lt;p&gt;기존에는 프로그래밍 대회가 오프라인으로 진행되었지만, 최근 2년동안에는 코로나로 인해서 모두 온라인 대회로 전환되었다. 나도 지난 APC에서 이미 온라인 대회를 치룬 적이 있었기 때문에 이번 대회 운영이 그렇게 생소하지는 않았으나 여전히 온라인 대회에는 어려운 점이 많다.&lt;/p&gt;
&lt;p&gt;그 중 하나는 부정행위와 관련된 사안이다. 오프라인 대회 시절에는 강의실에서 참가자들이 모여서 진행하기 때문에 관리 감독하기에 용이했지만 온라인 대회에서 우리가 참가자들을 볼 수 있는 건 오직 zoom을 통해 송출되는 화면 뿐이다. 나 말고도 감독스태프가 있기도 하고, 참가자들의 양심을 신뢰해야겠지만 만약 소수의 악의적인 참가자가 온라인 대회의 특성을 악용하는 게 아닐까 하는 불안한 마음이 대회 진행 내내 머릿속에 맴돌았다(그런 사람이 절대 없기를 바란다).&lt;/p&gt;
&lt;p&gt;그리고 도중에 참가자가 모르는 사이에 캠이 꺼져서 스태프가 화면을 볼 수 없는 경우도 생기는데, 이럴 경우에 일정 시간내에 재접속하지 않으면 실격처리된다. 이 또한 일일이 공지하고 신경쓰느라 애를 먹었던 부분이다.
또한 부차적인 문제이지만 온라인 대회라서 그런지 오프라인 대회보다 중도 포기자가 훨씬 더 많이 발생해서 아쉬운 마음이 들었다.&lt;/p&gt;
&lt;h4&gt;3. 일정 관리&lt;/h4&gt;
&lt;p&gt;이번 대회는 1월 15일에 열렸고, 프로세스는 10월 중순 쯤 시작했으니 약 3달 동안의 준비기간이 있었다. 3달이 그렇게 촉박한 시간까지는 아니었을 수 있으나 위에서도 얘기했듯이 한 사람이 &lt;strong&gt;출제&lt;/strong&gt; + &lt;strong&gt;운영&lt;/strong&gt; + &lt;strong&gt;섭외&lt;/strong&gt; 업무를 동시에 담당해야 한다는 점을 감안한다면 결코 넉넉치는 않은 시간이었다.&lt;/p&gt;
&lt;p&gt;그래서 이번에는 특히 일정 관리에 주의를 기울였던 것 같다. 3가지 요소 중에서 어느 하나라도 진도가 뒤쳐지면 대회에 차질이 생기기 때문에 각 요소별로 &apos;언제까지는 이만큼을 만들어놓자&apos; 식으로 타임라인을 정해가면서 준비했던 게 주효했다.&lt;/p&gt;
&lt;p&gt;또한 각 학교별로 참가자 명단 같은 정보들을 취합해야 하는 경우가 많았는데, 이런 타입의 업무는 내가 열심히 한다고 끝나는 일이 아니라, 각 사람이 모두 협조를 해주어야만 끝날 수 있기 때문에 특히 더 시간적으로 예민해졌다. 이때 가장 중요하다고 생각하는 게 사람들에게 &apos;나는 지금 이러이러한 일을 처리해야하기 때문에, 여러분들은 OO일 OO시까지 이 업무가 완료되도록 해야한다&apos; 는 의사전달을 확실히 표현해야한다는 점이다. 여기서 강조하고 싶었던 것은,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내가 어떤 일을 해야하는 이유와 배경&lt;/li&gt;
&lt;li&gt;그래서 상대방이 해야할 일&lt;/li&gt;
&lt;li&gt;그 일의 마감시간 이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;모든 일을 처리할 때에 있어서 항상 3가지 원칙을 상대방에게 전달하고자 했으며, 이를 통해 상호간 일의 능률이 향상된다는 점을 몸소 체험했다.&lt;/p&gt;
&lt;h4&gt;4. 설문조사 결과&lt;/h4&gt;
&lt;p&gt;대회가 끝나고 난 뒤, 참가자들이 실시한 설문조사 결과를 받았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983321/blog/assets/survey_d00rfk.png&quot; alt=&quot;survey&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;문제 난이도 &apos;적절함&apos; 72.4%, &apos;어려움&apos; 24.1%&lt;/p&gt;
&lt;p&gt;설문에 여러가지 항목이 있었는데 내가 가장 관심있는 항목은 참가자들이 느끼는 문제 난이도였다. 대회 문제의 난이도 세팅은 내가 대회를 앞두고 가장 조마조마했던 부분이었다. 지금까지 출제한 대회(그리고 대부분의 프로그래밍 대회)에서 출제 회의 당시에 문제의 예상 난이도를 책정하는데, 출제진은 참가자들보다 문제의 난이도를 하향평가하는 경향이 짙기 때문이다(2021 APC에서 제대로 경험했다).&lt;/p&gt;
&lt;p&gt;따라서 참가자들에게 적절한 난이도를 제공하기 위해서는 출제 당시에는 &apos;조금 쉬울 것 같다&apos; 라는 느낌이 들어야 출제진과 참가자들의 체감 난이도 간극을 좁힐 수 있다고 생각했다. 그래서 이번 출제 과정에서도 문제 난이도 배정과 관련하여 출제진들과 신경써서 많은 얘기를 나눴었는데, 실제 대회에서도 제대로 반영된 것 같아서 다행이었다.&lt;/p&gt;
&lt;p&gt;그리고 그 밖의 대회에서 아쉬웠거나 보완되었으면 하는 점도 응답을 받았는데 다음과 같은 의견들이 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대회 일정, 규칙 공지를 더 빨리 해 주었으면 좋겠다. (7명)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이건 명백한 내 잘못이었다. 대회 사이트와 각 학교 대표진들에게는 미리 공지를 하긴 했었는데 참가자들에게 직접적으로 전달하는 방식이 아니었기에 확인하지 못한 참가자는 대회 공지를 늦게 확인할 수 밖에 없었을 것이다.&lt;/p&gt;
&lt;p&gt;다음부터는 조금 더 여유있고 직접적인 방식으로 참가자들에게 안내를 할 수 있도록 바꿔야겠다. 대회 규칙 또한 온라인대회이다 보니 참가자 입장에서도 어떤 행위가 허용되는지 안되는지 혼란스웠을 것이다. 나 역시도 온라인 대회 운영은 익숙치 않다보니 규칙을 제정함에 있어서도 놓치거나 서툴렀다. 다음부터는 대회 규칙을 사전에 자세하게 안내할 수 있도록 해야겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대면으로 진행되었으면 좋겠다.(2명)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;저두요...&lt;/p&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;10월 중순부터 대회 당일날까지 꽤나 바쁘게 살았다. 처음 내가 운영을 맡고자 했을 땐 &apos;누군가가 해야할 일이라면 내가 하는게 낫다&apos;라는 심정으로 나섰다. 출제도 몇 번 해봤겠다, 내친김에 대회 운영까지도 못할 게 뭐가 있겠냐 싶어서 달려든 마음도 있었던 것 같다.&lt;/p&gt;
&lt;p&gt;그런데 운영은 출제와는 다른 운영만의 어려움이 있다. 출제에서 필요한 역량과 운영에서 필요한 역량은 확연히 다르다. 결이 다르다고나 할까? 그래서 대회를 운영하면서 나한테 부족했던 역량을 확인하고, 또 내가 잘 처리할 수 있는 업무는 무엇인지 확인할 수 있게 되었다.&lt;br&gt;
그리고 다양한 위치와 입장에 있는 사람들과 컨택을 해보면서 그 사람에게 필요한 것, 그 사람이 요구 하는 것, 그리고 내가 그 사람에게 해줄 수 있는 것이 무엇인지 빠르게 파악하는 능력이 중요하는 것도 깨달았다.&lt;/p&gt;
&lt;p&gt;지금 이 글이 shake!의 차기대회를 준비하게 될 누군가, 또는 프로그래밍 경시 대회를 준비하는 누군가에게 조금이나마 도움이 될 수 있기를 바란다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[nextTick()은 언제쓸까?]]></title><description><![CDATA[nextTick()이란? Vue를 공부하다보면 Global API의 한 종류로서 이라는 함수를 접하게 된다.
Vue 공식문서에서는 이렇게 설명하고 있다. When you mutate reactive state in Vue, the resulting…]]></description><link>https://juheon.dev/vue/230906-nexttick/</link><guid isPermaLink="false">https://juheon.dev/vue/230906-nexttick/</guid><pubDate>Wed, 06 Sep 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;nextTick()이란?&lt;/h2&gt;
&lt;p&gt;Vue를 공부하다보면 Global API의 한 종류로서 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;이라는 함수를 접하게 된다.
&lt;a href=&quot;https://vuejs.org/api/general.html#nexttick&quot;&gt;Vue 공식문서&lt;/a&gt;에서는 이렇게 설명하고 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When you mutate reactive state in Vue, the resulting DOM updates are not applied synchronously. Instead, Vue buffers them until the &quot;next tick&quot; to ensure that each component updates only once no matter how many state changes you have made.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt; can be used immediately after a state change to wait for the DOM updates to complete. You can either pass a callback as an argument, or await the returned Promise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue에서 반응형 변수의 값을 변경할 때, 그 결과는 DOM에 동기적으로 반영되지 않는다. 대신 Vue는 각 컴포넌트가 몇번이나 변경되었느냐와 상관없이, &quot;next Tick&quot;까지 버퍼에 담아놓아서 반드시 한번만 업데이트 됨을 보장한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;은 DOM의 업데이트가 완료될 때까지 기다리는 데 사용할 수 있다. 콜백함수나 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 await할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;쉽게 얘기해서, &apos;코드 상에서 데이터가 바뀌더라도 DOM에는 즉각적으로 반영되지 않으니 강제로 반영하고 싶다면 이 함수를 호출해라&apos; 라는 의미다.&lt;/p&gt;
&lt;p&gt;스크립트단에서 적용된 코드가 곧바로 DOM에 반영되지 않는다는 사실은 vue뿐만 아니라 react를 접해본 사람이라면 생소한 얘기는 아닐 것이다. 최적화를 위하여 화면을 그리는 렌더링 과정은 batch로 처리되기 때문이다. 그래서 react, vue 라이브러리를 처음 공부하는 시기에는 내가 생각했던 렌더링 결과와 다르게 나와서 당황했던 경험이 다들 한번씩은 있을 것이다. 그래서 이런 불편한 상황을 해결하기 위하여 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수가 존재하는 것이다.&lt;/p&gt;
&lt;h2&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;사실 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수의 사용빈도가 많지는 않지만, 가끔씩 필요한 상황은 있기 때문에 이런 함수의 존재여부를 알고있다는 자체만으로도 도움이 된다. 지금까지의 경험상 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;이 필요한 상황은 다음과 같았다.&lt;/p&gt;
&lt;h4&gt;비동기로 데이터를 받아온 후에 container의 size를 조정해야할 때&lt;/h4&gt;
&lt;p&gt;아래와 같이 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt; 라는 비동기 함수를 통해 데이터를 받아와서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;에 보여주는 상황을 생각해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;textarea class=&amp;quot;container&amp;quot; v-model=&amp;quot;data&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  const data = ref(&amp;quot;&amp;quot;)
  const fetchData = () =&amp;gt; {...}

  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 data가 담기는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt; 에는 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;width, height, overflow-y:scroll&lt;/code&gt;가 있어 정해진 사이즈로만 렌더링되어야 하는 제약이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.container {
  width: 200px;
  height: 100px;
  overflow-y: scroll;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;에 스크롤이 생긴 채로 보이게 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983314/blog/assets/before.png_kznlff.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;여기서 한가지 요구사항을 추가해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;의 길이에 따라서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;의 높이가 자동적으로 조정되어야 한다. 즉 스크롤이 생기지 않고 한 화면에 모든 텍스트가 다 들어와야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단순하게 생각해보면 css에 &lt;code class=&quot;language-text&quot;&gt;{height : fit-content}&lt;/code&gt;속성을 추가해주면 될 것 같지만 실제로는 작동하지 않는다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 비동기로 받아오기 때문에 &lt;strong&gt;화면을 렌더링하는 시점에는 아직 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;의 길이를 알 수 없기 때문&lt;/strong&gt;이다.&lt;br&gt;
따라서 우리는 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 받아오고 난 후(=길이가 얼마인지 알 수 있는 시점)에 DOM에 다시 접근하여, 그 길이에 맞춰서 다시 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;의 높이를 &lt;code class=&quot;language-text&quot;&gt;JS&lt;/code&gt;를 통해 조절해야 한다.&lt;/p&gt;
&lt;p&gt;그래서 아래와 같이 &lt;code class=&quot;language-text&quot;&gt;scrollHeight&lt;/code&gt;값을 받아와서 직접 높이값을 설정해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;textarea class=&amp;quot;container&amp;quot; v-model=&amp;quot;data&amp;quot; ref=&amp;quot;textRef&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  ...
  const textRef = ref(null);
  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
    const scrollHeight = textRef.value?.scrollHeight; // scrollHeight 설정!
    textRef.value.style.height = scrollHeight + &amp;#39;px&amp;#39;;
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;를 받아올 때 까지 &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt;를 걸어주었으니 높이가 딱 맞게 조정될 것 같다. 하지만 실제로 실행해보면 결과는 여전히 위와 동일하다. 왜 반영되지 않은 것일까?&lt;/p&gt;
&lt;p&gt;그 이유는 글 초반부에 설명했다시피, &lt;strong&gt;스크립트단에서 적용된 코드가 곧바로 DOM에 반영되지 않기 때문&lt;/strong&gt;이다.&lt;br&gt;
즉 &lt;code class=&quot;language-text&quot;&gt;data.value = await fetchData()&lt;/code&gt;라는 코드가 실행된 직후라도, 실제로는 &lt;code class=&quot;language-text&quot;&gt;data&lt;/code&gt;가 DOM에는 반영되지 않은 것이다!&lt;/p&gt;
&lt;p&gt;그렇다면 우리에게 필요한 것은? 드디어 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수가 등장할 차례이다. 해당 코드 다음 줄에 &lt;code class=&quot;language-text&quot;&gt;nextTick()&lt;/code&gt;함수를 호출하면 &lt;em&gt;&apos;지금까지의 변경사항을 DOM에 적용해줘!&apos;&lt;/em&gt; 라고 요청하는 것과 같은 의미이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;...&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  ...
  onMounted(async () =&amp;gt; {
    data.value = await fetchData()
    await nextTick(); // DOM에 곧바로 반영!
    const scrollHeight = textRef.value?.scrollHeight; // scrollHeight 설정!
    textRef.value.style.height = scrollHeight + &amp;#39;px&amp;#39;;
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;그러면 이제 요구사항처럼 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;textarea /&gt;&lt;/code&gt;가 스크롤 없이 텍스트 길이에 맞춰서 높이가 조정된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/after_c2ahs8.png&quot; alt=&quot;after&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[내가 대학교에서 배운 것]]></title><description><![CDATA[대학생활 회고(라 쓰고 '추억팔이'로 읽는다) 지난 주에 드디어 대학교를 졸업했다. 2017년 2월에 입학한 나의 대학생활은 장장 6년…]]></description><link>https://juheon.dev/essay/230901-what-i-learn-in-college/</link><guid isPermaLink="false">https://juheon.dev/essay/230901-what-i-learn-in-college/</guid><pubDate>Fri, 01 Sep 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;대학생활 회고(라 쓰고 &apos;추억팔이&apos;로 읽는다)&lt;/h2&gt;
&lt;p&gt;지난 주에 드디어 대학교를 졸업했다. 2017년 2월에 입학한 나의 대학생활은 장장 6년 6개월에 걸친 여정 끝에 막을 내리게 되었다. 이대로 나의 대학 생활이 아득한 추억 속에서 휘발되기에는 아쉽다고 생각해서 내가 대학교에 다니면서 들었던 강의들, 그 외에 의미있었던 활동들을 기억 깊숙한 곳에서 끄집어내서 박제하려고 한다. 전공과목 여부와 상관없이 나의 대학 생활에서 의미있는 영향을 끼친 강의들과, 어떤 방식으로 영향을 끼쳤는지를 중점적으로 소개하려고 한다.&lt;/p&gt;
&lt;h2&gt;유난히 독특했던 한 컴공생...&lt;/h2&gt;
&lt;p&gt;내가 들었던 강의들이 다른 컴공과 학생보다 유별난 구석이 있다. 특히나 교양과목에서 두드러지는데, 나는 교양과목을 선택할 때 나름의 철칙이 있었다. 바로 전공과 관련없는 분야의 학문의 강의를 많이 들으려고 했다는 점이다.&lt;/p&gt;
&lt;p&gt;사람마다 대학교에서 얻으려는 목표는 각기 다를 수 있다. 누군가는 졸업장만 필요할 수 있고, 누군가는 높은 학점을 받아서 좋은 회사나 대학원을 가는 게 목표일 수 있다. 하지만 나의 경우에 그보다 더 중요시 여긴 목표는 &lt;strong&gt;내가 모르는 세상을 최대한 많이 접해보자&lt;/strong&gt; 였다.&lt;/p&gt;
&lt;p&gt;우리는 대부분 초중고등학교부터 항상 점수에 얽매인 인생을 살아왔다. 그리고 흔히들 대학교에 가면 시험으로부터 해방된다, 마음대로 해도 된다는 이야기를 하는데 막상 대학교에 와서도 크게 달라진 게 없다는 인상을 받았다. 대학교에서 와서도 또다른 학점 경쟁, 수강신청 경쟁을 하고 있는 내 자신의 모습에서 현타가 느껴지면서 회의감을 품게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983318/blog/assets/graduate_pqegiu.jpg&quot; alt=&quot;졸업식&quot;&gt;&lt;/p&gt;
&lt;p&gt;그래서 나는 대학생활만큼은 정말 &apos;즐겜&apos; 하고 싶었다. 점수에 연연하지 말고 내가 정말 듣고 싶은 과목, 궁금한 분야의 과목을 들어보고 싶었다. 어차피 컴공이 전공이기 때문에 컴퓨터 관련과목은 실컷 듣게 될테니, 교양과목은 완전히 반대되는 분야인 인문/사회 계열을 듣고 싶었다. 단순히 그 분야의 지식이 궁금했기 때문이기도 하지만, 더 궁금했던 건 그 분야를 &lt;strong&gt;몇십년동안 연구했던 학자들이 세상을 바라보는 시선&lt;/strong&gt;을 알고 싶었기 때문이다.&lt;/p&gt;
&lt;p&gt;한 분야를 오랫동안 공부한 사람은 자연스럽게 세상을 바라보는 시선 또한 자신의 분야에 맞춰져서 바라보는 경향이 짙어진다.일반인의 시선으로는 발견하지 못했던 부분들도 연구자에게는 다르게 보이기 마련이다. 마치 카메라에 색깔 필터를 적용하면 세상이 온통 그 색깔로만 보이는 것처럼 말이다. 나는 세상을 하나의 필터로만 바라보고 싶지 않았다. 나에게는 여러 종류의 필터가 있었으면 하는 바람이 있었다.&lt;/p&gt;
&lt;p&gt;대학교에서 등록금을 내고 수업을 듣는다는 건, 그 연구자의 시선으로 세상을 바라보는 방법을 조금이나마 배울 수 있는 기회를 제공받는다고 생각한다. 대학교는 이러한 다양한 분야의 연구자들을 한 곳에 모아둔 공간이고 인생에서 몇 안되는 값진 기회이기 때문에 나는 이 기회를 충분히 활용하고 싶었다.&lt;/p&gt;
&lt;h2&gt;기억에 남는 강의&lt;/h2&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;글쓰기&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;1학년 신입생들은 반드시 들어야하는 강의였다. 대부분의 이과생들에게 &apos;글쓰기&apos;란 물과 기름처럼 친해질래야 친해질 수 없는 관계이다. 나 역시도 처음에는 글쓰기와 거리가 먼 사람이라고 단정지어왔다. 하지만 이 강의를 들으면서 그 생각이 조금씩 바뀌게 되었다.&lt;/p&gt;
&lt;p&gt;일단 교수님이 딱딱하지 않고 유쾌하신 분이었다. 내가 대학교 입학 전에 생각했던 &apos;대학교수&apos;하면 떠오르는 이미지는 엄격하고 보수적인 사람이었는데, 내가 만난 교수님은 학생들과 같이 농담도 나누면서 그 고정관념을 어느정도 깨주셨다. 그리고 &apos;글쓰기&apos;라는 행위에 대해서도 너무 어렵게 접근할 필요없이 &apos;자신이 가장 흥미를 가질만한 분야&apos;를 토대로 글을 작성하면 된다는 식으로 학생들이 갖고있는 글쓰기에 대한 막연한 두려움을 없애기 위해서 계속 우리를 격려해주셨다.&lt;/p&gt;
&lt;p&gt;그리고 중간고사로 과제가 하나 주어졌는데, 아무 주제를 하나 선정해서 1000자 이내의 글을 하나 작성하는 것이었다. 처음 글을 쓸 당시에는 이렇게 쓰는게 맞는지 긴가민가 했다. 머릿속에는 분명 얘기하고 싶은 주제가 있었는데, 그 내용을 텍스트로 옮기려고하면 연기처럼 사라져버렸다. 나의 생각을 텍스트로 실체화하여 변환하는 작업에는 손실이 생기게 되는데, &apos;글쓰기&apos;란 최대한 그 손실을 줄이면서 텍스트로 옮겨내는 과정이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그렇게 내가 쓴 글을 계속 지웠다 썼다를 반복해나가면서 자연스럽게 읽힐 때까지 퇴고했다. 과제를 제출하는 마지막 순간까지도 내 글이 과연 남들에게 어떻게 읽힐지에 대해 불안한 마음을 숨길 수 없었다. 하지만 예상을 뒤엎고 내 글은 교수님으로부터 호평을 받게 되었다. 무엇보다 자신의 이야기를 가감없이 솔직하게 드러냈다는 점이 인상깊었다는 의견을 주셨다.&lt;br&gt;
이 일을 계기로 &lt;code class=&quot;language-text&quot;&gt;&apos;나 생각보다 글쓰기에 소질이 있을지도...?&apos;&lt;/code&gt;하는 자신감을 얻게 되었고 지금의 개발 블로그를 운영하게 되는 시작점이 될 수 있었다고 생각한다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;영화의 세계&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;내가 입학해서 처음으로 선택한 교양과목이라 기억에 남는다. 강의는 이름 그대로 여러가지 영화를 보면서 분석해보고 어떤 의도가 숨겨져 있는지 알아보는 과목이다. 그 당시에 내가 영화 보는 걸 좋아하기도 했고, 보면서 느꼈던 점을 다른사람들과 공유해보고 싶다는 생각이 들어서 신청했다. 나름 인기있는 과목이라 수강신청이 치열했었다.&lt;/p&gt;
&lt;p&gt;중간고사는 단편영화 하나를 보고 분석하는 글을 쓰고, 기말고사는 조별로 영화 한 편을 선정하여 직접 분석해야했다. 내가 있었던 조는 &apos;컨택트&apos;라는 영화를 선정했다. 외계생명체가 지구를 침략하는 내용이었는데,. 그 영화 분석하느라고 당시에 20번 정도 돌려봤다. 지금 생각해보면 교양 과목 하나에 뭐 그렇게 시간을 많이 쏟았나 싶기는 한데, 열정 가득한 1학년 시절이다보니 가능했었던 일인 것 같다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;컴퓨터 구조&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;운영 체제&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;수업도 수업이지만 과제가 어렵기로 유명한 두 과목이다. 아직도 기억에 남는 건 컴퓨터 구조의 첫 번째 과제였는데, C언어로 MIPS Processor를 구현하는 것이었다. 과제 기한은 3주정도 주었는데, 다른 과목이라면 3주가 엄청 널널한 기간이었겠지만, 컴구에서는 과제의 내용을 이해하는데 1주정도 걸리고, 구현하는데 1주가 걸렸었던 기억이 난다.&lt;/p&gt;
&lt;p&gt;과제는 어려웠던 대신에 교수님의 강의력이 뛰어났기 때문에 수업시간에 딴짓하지 않고 100% 강의에 집중하면서 들었던 과목이었다. 컴퓨터의 프로세서, 메모리 구조, 연산 원리, 가상메모리에 대해서 배웠던 기억이 난다. 배울 당시에는 이 지식들을 언제 써먹나 싶었지만 지금 생각해보니 CS지식의 근간을 세우는데 큰 도움이 되고 있어 여러모로 열심히 공부해두길 잘 했다고 생각한 과목이었다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;웹 시스템 설계&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;내가 개발자의 진로를 프론트엔드 개발자로 선택하게된 결정적인 계기가 된 과목이었다. 웹 페이지를 하나 개발하는 프로젝트성 강의였는데, 공교롭게도 이 강의에서 사용한 라이브러리가 &lt;code class=&quot;language-text&quot;&gt;vue.js&lt;/code&gt;였다. 이 라이브러리가 4년이 지난 지금 나의 메인 기술스택이 되리라곤 상상치도 못했다.&lt;/p&gt;
&lt;p&gt;사실 이 과목을 들을 당시에는 내가 웹개발에 대한 경험이 거의 전무하다시피했다. 그래서 DOM이 무엇인지, &lt;code class=&quot;language-text&quot;&gt;vue.js&lt;/code&gt;가 무엇인지 그 때 처음 알게 되었다. 조금 늦게 시작하긴 했지만 그 전까지 내가 공부하던 C,C++와는 완전히 다른 세계였다.맨날 운영체제같은 low-level만 다루는 코딩을 하다가, 처음으로 사용자가 직접 맞닿는 영역에서 개발을 접해보니 신세계였다. 내가 몰랐던 세상 중에서도 이렇게 재밌는 분야가 있었구나, 하는 신선한 충격을 받게 되었다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;정수론&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;많은 사람들은 왜 컴공이 정수론 강의를 들었냐고 물어보겠지만, 그 질문에 대한 나의 답변은 그냥 &apos;궁금해서&apos;이다. 정확히 얘기하자면 당시의 나는 알고리즘 소학회에서 마침 정수론과 관련된 지식(페르마 소정리, 중국인 나머지 정리)들을 공부하고 있었는데 겸사겸사 수학과 강의로 열리니 한번 들어보자는 호기심이 발동해서였다.&lt;/p&gt;
&lt;p&gt;학교를 다니면서 처음으로 타학과의 전공 강의를 들어보았는데, 수학과의 수업은 컴공의 그것과는 상당히 분위기가 달랐다. 가장 결정적인 차이는 수학과는 강의실의 자리가 앞에서부터 채워진다는 점이다. 그리고 강의실의 모든 사람들이 수업에 집중하면서 듣는다는 점도 놀라웠다. 어찌보면 당연한 얘기일 수도 있지만, 컴공과 수업은 보통 자리가 뒤에서부터 채워지고 수업도 일부 듣는 사람만 듣기 때문이다.&lt;/p&gt;
&lt;p&gt;이것이 수학과의 위엄인가...? 나랑 다른 세상에 살고 있는 사람들 같았다. 이 강의를 듣는 내내 수학과 학생들과 교수님이 모두 존경스러웠다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;영화와 사회심리&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;나는 교양과목 중에서 심리학 관련 강의를 유독 좋아했다. 인간은 어떻게 움직이는가, 그리고 인간의 내면을 들여다본다는 점에서 나의 평소 관심사와 상통하는 부분이 있기 때문이다. 그래서 여러 심리학 강의를 들어보았는데 아직까지도 이 강의가 기억에 남는다.&lt;/p&gt;
&lt;p&gt;강의에서는 기본적으로 &apos;사회심리학&apos;관련 이론들을 가르쳐주는데 학생들의 이해를 돕기위해 영화의 한 장면을 예시로 들어서 보여준다는 점이 독특하다. 강의 내용도 심리학 이론을 어렵지 않게 잘 풀어냈기 때문에 재밌게 느껴지기도 했었고, 무엇보다 교수님이 정말 열정적으로 강의해주시는 게 인상적이었다.&lt;/p&gt;
&lt;p&gt;자신의 전공 분야에 있어서 자부심을 느끼면서 강의를 하시는 모습이 듣는 사람에게도 전달될 정도였다. 어쩌면 내가 위에서 언급했던 &apos;세상을 바라보는 시각을 배우기 위해서&apos;라는 취지에 가장 알맞은 강의가 아니었을까 싶다. 나뿐만 아니라 모든 학생들이 그렇게 느끼는건지 강의 평가도 매우 높은 편에 속했고 수강신청 난이도도 어려운 과목이었다.&lt;/p&gt;
&lt;h2&gt;아쉬웠던 점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;책을 많이 못 읽었다.&lt;/strong&gt;&lt;br&gt;
대학교 다니면서 내 나름의 목표 중 하나는 한달에 책 한권씩 읽기였다. 통학할 때 왕복으로 2시간이 넘게 걸렸기 때문에 시간이 그냥 버려지는게 아쉬워서 책을 읽기 시작했다. 1,2학년에는 시간이 널널해서 책을 읽을만한 여유가 있었지만, 3학년부터는 과제와 취업준비에 치이면서 독서에 소홀했었던 점이 아쉽다.&lt;/p&gt;
&lt;p&gt;졸업할 때쯤 대출이력을 살펴보니 약 50권정도 빌린 것으로 나타났는데, 이 중에는 기술서적이나 강의 교재도 포함되어 있어서 실질적으로는 독서를 위한 책은 40권 정도이다.&lt;br&gt;
40권 중에서는 소설이 가장 많았다. 공대생이기 때문에 오히려 정반대 분야의 책을 읽는 게 삶의 균형을 맞추는데 도움이 될 거라고 생각했다. 실제로도 소설을 읽을 때에는 공부할 때와는 다른 뇌의 영역이 활성화되는 느낌이었다(과학적인 근거는 없다). 가장 재미있게 읽은 책은 무라카미 하루키의 &lt;em&gt;&apos;해변의 카프카&apos;&lt;/em&gt; 였다. 나머지는 주로 내가 관심있는 분야인 심리학과 진화학 관련 분야의 책을 빌렸다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;더 다양한 사람들을 만나보고 싶었다.&lt;/strong&gt;&lt;br&gt;
나 자신이 지나치게 안전영역(safe area)에만 안주해있었던 게 아닐까 되돌아보게 된다. 개인 성격상 새로운 사람을 만나기 위해 애써 나서지 않는 성격이다보니 항상 아는 사람만 만나게 되었다. 이게 꼭 나쁜 것만은 아니지만 인생에서 &apos;대학교&apos;라는 시기만큼은 조금 더 외향적인 성격으로 나아갔어도 최소한 손해볼 일은 없었을 것이라 생각한다. 하지만 누구나 그렇듯, 자신의 성격은 바꾸기란 쉬운 일은 아니었다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;개발분야를 좀 더 빨리 접해보고 싶었다.&lt;/strong&gt;&lt;br&gt;
내가 대학교 때 했던 코딩의 90%는 알고리즘과 PS(Problem Solving)이었을 것이다. 어떻게 보면 나의 코딩이 지나치게 PS에 overfitting 되어있었고, 개발이라는 분야는 3학년 후반이 되어서야 처음 접하게 되었다. 늦은 시기는 아니었지만 조금만 일찍 개발을 접했더라면 프론트,백엔드,모바일,ML 등 여러 분야를 두루두루 공부해보면서 내 진로를 찾기까지 충분한 시간이 주어졌더라면 하는 아쉬움이 남는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;이제는 사회 초년생으로&lt;/h2&gt;
&lt;p&gt;대학교는 이제 막 졸업했지만 사회인으로는 아직 병아리에 불과하다. 좀 얼떨떨한 기분이다. 내가 진짜로 사회인이 될 준비가 되어 있는걸까? 세월이 절벽 앞에 서있는 나의 등을 떠미는 바람에 억지로 밀려난 기분이다.&lt;/p&gt;
&lt;p&gt;사회인은 사회인으로서 요구되는 역량이 대학생과 달라지기 때문에 나는 또 다시 공부해야한다. 특히나 내가 가장 걱정인건 금융/재테크 관련 분야이다. 사실 나 이 분야에 관해서는 정말 문외한이다. 내 주변 친구들은 요즘 금리가 어떻고, 주식이 어떻고에 대해서 토론하던데 나는 무슨 소리인지 하나도 모르겠다. 개발자로서는 개발 공부도 해야하지만, 더 큰 범주에서 나는 사회인이기에 이쪽 분야의 공부도 결코 소홀히 할 수 없는 처지이다.&lt;/p&gt;
&lt;p&gt;결국에 내 지식이 다시 초기화되었다. 대학교에 처음 입학했을 때 느꼈던 기분과 유사하다. 이제 좀 대학 생활에 익숙해졌다 싶으니깐 졸업해버리고 새로운 타이틀을 달게 되었다. 인생은 항상 불완전함의 연속이다. 언제쯤되면 나도 사회인으로서 익숙해질 수 있을지 가늠조차 되지 않는다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[개발자가 된 이유]]></title><description><![CDATA[…]]></description><link>https://juheon.dev/essay/230812-why-i-become-developer/</link><guid isPermaLink="false">https://juheon.dev/essay/230812-why-i-become-developer/</guid><pubDate>Sat, 12 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;아주 단순한 계기&lt;/h2&gt;
&lt;p&gt;어린 시절에 나는 컴퓨터를 아주 좋아하는 아이였다. 당연히 주 컨텐츠는 게임이었다. 메이플스토리, 카트라이더, 그랜드체이스를 열심히 했던 기억이 난다. 하지만 그 무렵 대부분의 내 또래가 그렇듯 하루에 사용할 수 있는 컴퓨터 시간은 정해져 있었다. 그래서 나는 어떻게 하면 컴퓨터를 원하는만큼 할 수 있을까 고민에 빠지다가 문득 한가지 생각이 뇌리를 스쳤다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;프로그래머가 된다면 하루종일 컴퓨터를 할 수 있지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 단순무식한 발상이 내가 개발자가 되기로 마음을 먹은 최초의 계기다.&lt;br&gt;
이때 내 나이는 중2(15살), 2011년이었다.&lt;/p&gt;
&lt;p&gt;그날부로 프로그래머라는 직업에 대해서 조사하기 시작했다.&lt;br&gt;
당시에는 프로그래머(개발자)라는 직업에 대한 인식이 지금처럼 좋지만은 않았다. 대부분 야근은 많이하면서 박봉을 받는 일명 3D 직군에 속했기 때문이다. 하지만 중2 시절의 나에게는 겨우 그런 이유들 따위로 꿈을 꺾을 수는 없었다. 오히려 너무 어린 나이였기 때문에 아직 현실의 높은 벽을 마주해보지 못했기
때문일 수도 있다.&lt;/p&gt;
&lt;p&gt;다음으로 개발자가 되기 위해서는 어떻게 해야하는지 찾아 보았다.&lt;br&gt;
&lt;em&gt;&apos;프로그래머는 기본적으로 프로그래밍 언어를 사용하면서 컴퓨터와 상호작용을 하는 직업이다. 그 중에서도 가장 기본은 C언어이다.&apos;&lt;/em&gt;&lt;br&gt;
라는 맥락의 글을 읽었다. 곧바로 나의 다음 목표는 &apos;C언어 마스터&apos;로 정해졌다.&lt;/p&gt;
&lt;h2&gt;프로그래밍과의 첫 만남&lt;/h2&gt;
&lt;p&gt;요즘이야 서점이든 온라인 강의든 C언어를 비롯한 각종 프로그래밍 언어를 학습할 수 있는 방법이 널리고 널렸지만, 그 당시에 프로그래밍 입문자가 독학으로 공부할 수 있는 방법은 거의 전무했다. 그렇지만 나 같은 입문자를 구원해준, 가뭄에 콩 나듯 출시된 입문서가 한 권 있었으니 그 책이 &apos;윤성우의 열혈 C프로그래밍&apos;이었다(이 글을 쓰며 교보문고에서 검색을 해보았는데 놀랍게도 아직까지 절판되지 않고 판매량에서도 상위권에 위치하고 있었다).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983314/blog/assets/c-book.png_agfeax.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;내가 처음으로 구입한 열혈 C프로그래밍. 아직도 고이 보관 중이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;나는 조금의 고민도 없이 바로 책을 사서 공부하기 시작했다. 그 당시에 C언어로 프로그래밍 처음 공부하는 사람들은 공감하겠지만 초기 환경 세팅하기까지 거쳐야하는 난관이 상당했다. 우스갯소리로 가장 먼저 배우는 &lt;code class=&quot;language-text&quot;&gt;&quot;Hello World!&lt;/code&gt;를 출력하기만 하면 프로그래밍 공부 고비의 절반은 넘었다는 말이 있을 정도였다.&lt;/p&gt;
&lt;p&gt;그 이유는 우선 비주얼 스튜디오를 설치해야 했는데 설치 파일이 상당히 무거울뿐더러 게임이나 일반인을 대상으로 하는 상업용 소프트웨어와 달리, 개발자를 대상으로 하는 프로그램이다보니 설치 과정이 썩 친절하기 못한 걸로 기억한다. 게다가 왠만한 컴퓨터 사양이 좋지 않고서는 실행하는데에도 시간이 1분 가까이 걸리기도 한다. 아무튼 여러 우여곡절을 겪으며 설치를 완료하고 나면 새 프로젝트(단축키 Ctrl + Shift + N) -&gt; 새 소스코드(Ctrl + Shift + A) -&gt; &lt;code class=&quot;language-text&quot;&gt;hello.c&lt;/code&gt; 파일을 생성하면 모든 준비를 마치게 된다.&lt;/p&gt;
&lt;p&gt;이제 드디어 코드를 작성할 수 있게 된다. 아주 유명한 코드인 &lt;code class=&quot;language-text&quot;&gt;printf(&apos;Hello World!&apos;);&lt;/code&gt; 를 작성하고나서 &apos;실행&apos;버튼을 누르면서 두근두근했던 심정, 콘솔창이 뜨면서 &lt;code class=&quot;language-text&quot;&gt;Hello World!&lt;/code&gt;가 적혀있는 걸 확인했을 때의 그 짜릿한 순간의 기억은 아직까지도 생생하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 때 나는 이 일을 직업으로 삼아야 되겠다고 확신하게 되었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그렇게 책의 내용을 하나씩 습득해나갔다. 아무도 내게 공부하라고 시킨 적도 없고 알려주지도 않았지만 프로그래밍 공부가 정말 재미있었다. 내가 작성하는 코드에 따라서 컴퓨터가 이를 해석하고 결과가 나오는 일이 신기하다고 느껴졌다. 나는 이 매력에 빠져서 주말마다 게임 대신에 C언어 공부를 했다.&lt;br&gt;
비록 포인터를 공부할 때 살짝 위기가 찾아오기는 했지만 이해가 안 될때는 두번 세번이고 반복하면서 익숙해질 때까지 연습했다. 나에게 프로그래밍 공부는 억지로 해야하는 &apos;숙제&apos;가 아니었다. 내 인생에서 처음으로 찾은 &apos;내가 하고 싶은 공부&apos;였기 때문이다.&lt;/p&gt;
&lt;p&gt;이 책은 여전히 나의 책장 한 켠에 꽂혀있다. 비록 본인이 웹 개발자라는 이유로 인해 각종 자바스크립트 서적에 둘러싸여 있어서 펼쳐볼 일이 거의 없지만, 나의 개발자 커리어의 첫 스타트를 끊어주었다는 기념비적인 책이기 때문에 앞으로 내가 개발자로서 어떤 커리어를 선택하더라도 이 책을 위한 공간은 항상 남겨두려고 한다.&lt;/p&gt;
&lt;h2&gt;장래희망 : 개발자&lt;/h2&gt;
&lt;p&gt;초중고에서는 매년 학기 초에 장래희망 조사를 했었다. 보통 초등학교까지는 정말 순수한 마음으로 자기가 좋아하는 일, 커서 하고싶은 일을 적기 마련이지만, 중고등학교부터는 현실과 마주함에 따라 장래희망마저 자신의 꿈을 양보하게 된다. 그리고 그 자리는 안정적이거나 사회적 지위가 높은 직업으로 획일화 되기 마련이다.&lt;/p&gt;
&lt;p&gt;그럼에도 나는 중3부터 고3에 이르기까지 장래희망 조사칸을 모두 &apos;개발자&apos;라고 적었다. 내 주변에 장래희망을 개발자라고 적은 친구들은 매우 드물었다. 지금처럼 중고등학교에서 코딩이 교육과정으로 포함되어 있지 않았기 때문에 그만큼 프로그래밍에 대한 학생들의 인식이 높진 않았다. 무엇보다 부모님조차도 개발자라는 직업을 썩 탐탁치 않게 여기셨다. 위에서 언급했다시피 3D 직종이고 생소한 분야이다보니 나에게 다른 직업도 권유하셨지만 나는 확고했다.&lt;/p&gt;
&lt;p&gt;그 나이의 대부분의 남자아이들이 그렇듯, 나 역시도 하나에 꽂히면 끝을 보는 성격이다. 나는 아래와 같은 근거를 준비해서 열심히 부모님을 설득했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내가 지금 C언어를 공부하고 있고...나는 이 공부가 재밌고...몇 년 뒤에는 개발자가 유망한 직종이 될 거고...그래서 남들보다 앞서갈 수 있고....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나의 간절함이 통했는지 부모님은 일단 잠정적으로는 허락해주셨다. 그리고 내가 부모님에게 요구한 조건 한 가지, 바로 &lt;strong&gt;&apos;앞으로 컴퓨터 사용시간에 간섭하지 않기&apos;&lt;/strong&gt; 이다. 부모님께는 프로그래밍을 공부해야한다는 핑계로 대충 얼버무리면서 말했는데 이 요구를 수용해주셨다. &lt;em&gt;(솔직히 그 시간동안 공부만 하지는 않았다. 부모님께는 공부한다 말하고 실제로는 몰래몰래 게임을 했다....)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이로써 나는 개발자가 되기 위한 모든 만반의 준비를 갖추게 되었다.&lt;/p&gt;
&lt;img height=&quot;500&quot; src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983317/blog/assets/high-school_gcpf9n.png&quot;&gt;
&lt;p&gt;&lt;em&gt;당시 고등학교 생활기록부. 고1까지는 아직 부모님을 100% 설득시키지는 못하였다...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;고등학교에 와서는 정말 입시공부로 인해 프로그래밍 공부를 할 여유가 없어졌다. 다행히 교내 방과후 프로그램의 일종으로 프로그래밍 교실이 있어 신청해서 들을 수 있었다. 이미 내가 공부했던 C언어 기초 내용을 복습하는 수준이었지만 갈증을 해결해 줄 수는 있었다. 이 시절에는 하루빨리 입시공부 때려치우고 대학교에 가서 컴퓨터 공부나 하고 싶다는 생각밖에 없었다.&lt;/p&gt;
&lt;p&gt;하지만 고3 현역 때 수능을 망치는 바람에 모의고사보다 훨씬 못한 성적표를 받아야했다. 여기서도 갈등이었다. 나는 가고자하는 전공이 확고하다보니 대학교의 네임밸류를 포기하더라도, 학과 공부와 개발 공부 열심히 하면 충분히 개발자로서 경쟁력이 있을 수 있다 생각했다.&lt;br&gt;
다른 한편으로는 불안감도 지울 수 없었다. 대학은 평생을 따라다닐 이름표인데 1년 정도는 시간을 더 투자할만 하지 않을까? 여기서 멈춰버리면 너무 아깝지 않을까?&lt;/p&gt;
&lt;p&gt;결국에 재수를 선택하게 되었고 나는 1년을 더 공부했다. 다행히 재수생때는 수능을 그럭저럭 보고 나름 괜찮은 성적을 받았다. 나는 묻지도 따지지도 않고 컴퓨터공학(소프트웨어)학과에만 정시 원서를 넣었다. 사실 학과를 바꾸면 더 높은 학교로 진학할 수 있는 선택지도 있었지만 나에게는 오직 단 하나의 목표, 컴퓨터를 전공하고 싶은 마음 뿐이었다.&lt;/p&gt;
&lt;h2&gt;소프트웨어 전공생&lt;/h2&gt;
&lt;p&gt;그리고 나는 마침내 소프트웨어 전공생이 되었다. 이제 지긋지긋한 &apos;공부를 위한 공부&apos;는 때려치우고 &apos;나를 위한 공부&apos;를 할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;사실 컴공(소웨)으로 대학에 들어오더라도 1학년부터 대단한 프로그래밍을 하진 않는다. 1,2학년은 C프로그래밍, 자료구조, 네트워크, 컴퓨터구조, 운영체제 등을 배우며 기본적인 CS지식의 기반을 다지는 단계이다. 그래서 저학년에는 코드를 작성하는 시간보다는 강의자료를 보면서 필기하는 데 더 많은 시간을 투자했다.&lt;/p&gt;
&lt;p&gt;그래서 나는 코딩을 하고 싶었다. 갓 입학한 컴공과 학생이 해볼만한 코딩 중 한가지는 바로 프로그래밍 문제를 푸는 일이다. 그래서 나는 학과의 알고리즘 소학회에 가입하게 된다. 여기서부터 본격적으로 나의 6년동안의 문제풀이(소위 &apos;PS&apos;라고 부른다) 인생이 시작되었다. 그 소학회의 C언어 스터디의 커리큘럼이 조금 빡센 편이었는데, 나는 중고등학교 시절의 예습을 한 덕분인지 그럭저럭 따라갈 수 있었다.&lt;/p&gt;
&lt;p&gt;이후 2,3학년이 되어서도 남들보다 쪼금 더 알고리즘 공부에 시간을 투자했다. 그 덕분에 전국 대학생 프로그래밍 경시대회인 ACM-ICPC 에 출전해보고, 소학회의 회장직을 맡아서 100명 이상의 사람들이 모인 커뮤니티 운영하며 C언어 기초 스터디의 강의(무려 3년이나)도 맡아보고, 그리고 교내 프로그래밍 경시대회의 문제 출제도 해볼 수 있었다.&lt;/p&gt;
&lt;p&gt;이 시간은 대학 생활에서 값진 경험을 가져다 주었다. 그 경험의 교훈은 단순히 문제를 어떻게 푸는 지에 대한 방법보다 훨씬 더 귀중한 것이었다.
내가 생각해낸 풀이를 남들이 쉽게 이해할 수 있도록 설명하는 방법, 다른 사람이 생각해낸 풀이에 귀 기울이는 방법, 많은 사람들이 모인 커뮤니티를 운영하는 방법, C언어 스터디를 진행하며 포인터를 쉽게 설명하는 방법, 내 의견을 포기하고 남의 의견을 받아들이는 방법을 배웠다. 또한 축적된 경험이 알게 모르게 개발 공부를 하면서도 탄탄한 밑거름이 되어주었다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(알고리즘 문제 풀이가 개발실력에 도움을 줄 수 있느냐는 사람들마다 의견이 갈리는 주제이지만 나의 의견, 그리고 같이 알고리즘을 공부한 선배들의 의견들은 모두 만장일치로 &apos;도움이 된다&apos;는 의견이다. 다익스트라 알고리즘이나 DP가 실무의 문제를 직접적으로 해결해주지는 않지만 &apos;데이터를 효율적으로 처리하는 방식&apos;에 대한 직관력을 키울 수 있다.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;내 대학 생활의 또 다른 특이점 중 하나는 (필수)전공과목 말고도 다른 학과의 강의를 많이 들었다. 개인적으로 흥미가 있었던 정수론, 사회심리학, 진화론과 같은 강의들을 들었다. &lt;em&gt;&apos;대학교 때 아니면 언제 이런 강의 들어보겠어? 재밌을 것 같은데 한번 들어보자&apos;&lt;/em&gt; 라는 생각을 갖고 있었다. 내가 궁금한 건 단순히 그 과목에서 가르치는 지식보다, 그 분야를 수십년동안 연구했던 교수님들이 세상을 바라보는 시선을 알고 싶었기 때문이었다. 대학교에서 마저도 중고등학교처럼 점수따기에 목숨 걸 필요는 없다고 생각했다.&lt;/p&gt;
&lt;p&gt;나는 그렇게 3학년까지 학교를 다니다가 군 입대를 하게 된다. 보통 1학년 마치고 다녀오는 게 일반적인데 나는 타이밍을 놓쳐서 시간이 흐르다가 결국 그제서야 가게 되었다. 그나마 다행인 건 특기병으로 지원했기 때문에 야전으로 가지는 않았지만, 교대근무를 하며 하루종일 컴퓨터를 보는 일을 맡아 군생활의 1/4를 밤 새는 일로 보냈다 (평생 할 밤샘을 군대에서 다 했다).&lt;/p&gt;
&lt;p&gt;군 복무 중에도 그냥 흘러만 가는 시간이 아까웠다. 그래서 부대 내 컴퓨터를 사용할 수 있는 사이버 지식 정보방(일명 &apos;사지방&apos;)에서 나는 알고리즘 문제를 풀었다. 주로 코드포스에서 문제를 풀었는데 군 복무 기간동안 대략 400문제 정도 풀었다. 사지방 컴퓨터에는 로컬 IDE 설치가 불가능 했기 때문에 온라인 IDE를 찾아 헤매면서 코딩했던 기억이 난다. 게다가 정말 기막힌 우연 중 하나는, 같은 생활관의 후임 중 한명이 PS를 하는 친구였다. 나만큼 혹은 나보다도 더 문제 풀이에 진심인 친구였기 때문에 외롭지 않게 코딩할 수 있었다.&lt;/p&gt;
&lt;h2&gt;FE 개발자의 길&lt;/h2&gt;
&lt;p&gt;군대를 전역하고 복학하니 4학년이 되어있었다. 이제 나도 본격적으로 취업 전선에 뛰어들 준비를 해야한다. 보통 개발자로 취준을 한다면 먼저 진로를 선택하기 마련이다. 마치 RPG 게임에서 초보자가 직업을 선택할 때 전사/마법사/궁수/도적으로 전직하는 것처럼 개발자도 마찬가지이다. 일반적으로 프론트엔드/백엔드/모바일/ML 중에서 본인의 진로를 정하게 된다.&lt;/p&gt;
&lt;p&gt;내 주변의 컴공 전공생들은 80% 이상이 백엔드로 진로를 선택하는 경우가 많았다. 백엔드 분야가 전공자로서의 이점을 가장 잘 살릴 수 있으면서 대부분의 회사에서 널리 필요한 직종이었기 때문이다. 모바일은 처음 공부를 시작하기 위한 허들이 조금 있는 편이고, ML은 대학원이 90% 필수였다. 그리고 프론트엔드는 상당히 애매한 포지션에 위치한다. 4개 분야 중에서 그나마 CS 지식을 덜 필요로한다는 인식이 있기 때문에 비전공자나 디자인 파트에서 전향하는 사례가 꽤 있는 편이다.나도 그 당시에 프론트엔드와 백엔드를 두고 고민을 많이 했다. 전공자의 이점을 살릴 수 있는 백엔드를 선택할 수도 있었다.&lt;/p&gt;
&lt;p&gt;하지만 프론트엔드는 개발하는 과정이 너무 재미있었다. 마치 중2때 처음 C를 접하고 코딩했었던 기억과 흡사했다. 내가 만든 결과물(웹페이지)이 다른 사람들에게 어떻게 보여질지 상상해면서 코딩을 하는 과정이 행복했고, 그 힘이 마치 무한동력처럼 작용해서 밤을 새서 코딩을 해도 힘들지가 않았다. 비록 프론트엔드 개발자의 진로가 상대적으로 치열하더라도, 내가 하고 싶은 일을 선택하는게 나중에 후회할 일을 만들지 않을 것이라고 생각했다.&lt;/p&gt;
&lt;p&gt;이제 막 FE개발자 경력 1년을 채운 시점에서 돌이켜보자면 1년 전보다 상황이 더 치열해진 건 사실이다. 솔직히 &apos;만약 내가 백엔드 개발자였다면?&apos;을 몇 번 생각해 본 적도 있다.&lt;br&gt;
그래도 후회는 하지 않는다. 인생을 살아가는 나만의 신조 중 하나는 &lt;em&gt;&apos;내가 내린 선택에 대해서는 절대 의심하지 말자&apos;&lt;/em&gt; 이다. 1년 전으로 다시 돌아가도 나는 (조금 고민은 하겠지만)프론트엔드 개발자를 선택할 것이다.&lt;/p&gt;
&lt;p&gt;내가 선택한 길이니 모든 책임은 나의 몫이다. 내가 더 열심히하면 극복할 수 있다고 생각한다.&lt;/p&gt;
&lt;h2&gt;어떤 개발자가 될 것인가&lt;/h2&gt;
&lt;h4&gt;1. 나만의 서비스를 제로베이스부터 개발해서 출시해보고 싶다.&lt;/h4&gt;
&lt;p&gt;나만의 서비스를 처음부터 개발하여 세상에 출시해보고 싶은 바람이 있다. 마치 요리사가 몇년동안 식당에서 일을 하다가 경력이 쌓이면 본인의 식당을 차리듯이 말이다. 창업일 수도 있고 사이드 프로젝트일 수도 있겠지만 형식에는 연연하지 않는다. 그렇다고 이 서비스가 반드시 성공해야 한다는 사명감을 갖고 시작하려는 것도 아니다. 단지 &apos;세상에 이런 서비스를 만든다면, 사람들은 어떻게 이용할까?&apos; 라는 근본적인 호기심으로부터 시작되었다.&lt;/p&gt;
&lt;p&gt;나는 고객(사용자)과 직접 맞닿아서 개발할 때 가장 재미있고, 내가 서비스를 직접 만들면서 이 서비스의 &lt;code class=&quot;language-text&quot;&gt;기획-디자인-개발-출시-유지보수&lt;/code&gt; 같은 라이프사이클을 모두 겪어보면서 동고동락할 수 있다면 그야말로 개발자를 하면서 얻을 수 있는 최고의 성취감이라고 생각한다.&lt;br&gt;
하지만 이를 위해서는 요구되는 역량도 고려해야 한다. 프론트엔드뿐만 아니라 백엔드나 데브옵스 또한 어느정도 다룰 수 있는 역량을 갖춰야 할 것이다. 상황에 따라서는 기획과 디자인과 같은 기술 외적인 분야에서도 신경써야 할 일이 많을 것이다.&lt;/p&gt;
&lt;h4&gt;2. 교육 컨텐츠를 만들고 싶다.&lt;/h4&gt;
&lt;p&gt;최근에 인프런이나 유튜브에서 여러 강의를 보면서 느낀 점은 나도 나중에 어느 분야에 대해 전문가가 된다면 꼭 강의를 만들어보고 싶다는 것이다.&lt;br&gt;
나는 대학교에서 알고리즘 소학회를 입학할 때부터 시작하여 졸업할 때까지 (총 6년 6개월)활동했었다. 이 기간 동안 스터디 활동을 하면서 내가 남들로부터 지식을 얻기도 했지만, 내가 가진 지식을 남에게 알려주기도 했다. 이 경험을 통해 남에게 가르쳐주는 일이 재밌고 의외로 나랑 잘 맞는 일이구나를 깨닫게 되었다. 특히나 많은 사람들이 이해하기에 어려운 개념이 있을 수 있는데, 내가 직접 가르칠 때는 사람들이 어떤 점을 어려하는지를 파악하고 그 부분에 대해서 쉽게 풀어서 설명하는 것에 자신이 있다.&lt;/p&gt;
&lt;h2&gt;지금의 나&lt;/h2&gt;
&lt;p&gt;우리 사회에서 개인의 직업이 정해지는 과정이 그렇게 필연적이기는 어렵다. 자신이 좋아하는 일을 직업으로 삼기는 현실적으로 어렵기 때문이다. 꿈을 쫓다보면 대개 현실적인 제약에 부딪히기 마련이다. 그러다보니 많은 사람들은 어쩔 수 없이 점수에 맞춰서 들어간 대학교와 학과에 따라서 직업이 정해지는 경우가 부지기수이다.&lt;/p&gt;
&lt;p&gt;하지만 나에겐 &apos;개발자&apos;라는 직업의 의미는 결코 가볍지 않다. 27살이 된 지금, 프로그래머가 되고자 처음으로 마음을 먹었던 15살을 기점으로 12년동안 간직해온 꿈이고 그 꿈을 직업으로 삼을 수 있다는 점에서 나는 프로그래밍을 하고 있는 순간이 너무나 소중한 기회라 여기고 있다. 내가 살아온 인생의 여정에서 개발자라는 직업은 너무나도 강하게 결합되어 있다.&lt;/p&gt;
&lt;p&gt;내가 남들보다 더 훌륭하다거나 돈을 더 많이 버는 개발자는 아닐 수도 있지만 한 가지는 확신할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이 일을 내가 하고 싶은 일이다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[모바일 환경에서 모달 닫기]]></title><description><![CDATA[2023-03-0…]]></description><link>https://juheon.dev/vue/230803-vue-modal-close/</link><guid isPermaLink="false">https://juheon.dev/vue/230803-vue-modal-close/</guid><pubDate>Thu, 03 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/222&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;모달 닫기&lt;/h2&gt;
&lt;p&gt;모바일 환경에서 모달창이 떠 있는 상태에서 모달을 닫는 방법은 여러가지가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;첫 번째 방법은 모달 창 내부에 별도의 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 표시해서 이 영역을 터치하면 닫히게 하는 방법이 있다. 가장 직관적인 방법이지만 버튼을 위한 별도의 공간을 확보해야 하기 때문에 디자인상 의도치 않은 공간을 차지한다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;이런 단점을 해결하기 위한 두 번째 방법은 모달 바깥의 영역을 터치를 감지했을 때 모달을 닫는 방법이 있다. 다만 이 방법 역시 명시적인 &apos;닫기&apos;버튼이 보이지 않기 때문에 이러한 UI/UX가 낯선 사용자에게는 모달을 어떻게 닫아야 하는지 헤맬 수도 있다는 단점이 있다.&lt;/p&gt;
&lt;p&gt;세 번째 방법은 (안드로이드 환경에서) 뒤로가기 버튼을 눌렀을 때 모달이 닫히게 하는 방법이다. 이 방법의 경우, 모달창과 직접적인 상호작용이 일어나지 않으므로 개발자 입장에서는 뒤로가기 이벤트를 감지해야 하는 등 꽤나 까다로운 작업이다. 이번 글에서는 그 방법에 대해서 설명하겠다.&lt;/p&gt;
&lt;h2&gt;뒤로가기&lt;/h2&gt;
&lt;p&gt;&apos;뒤로가기&apos;를 눌렀을 때 모달창이 닫히게 만들기 위해서는, 모달창이 열려있는 상태를 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;객체의 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 저장(push)해야 한다. 이때 사용하는 함수가 &lt;code class=&quot;language-text&quot;&gt;window.history.pushState()&lt;/code&gt;함수이다. 이 함수에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&quot;&gt;자세한 설명&lt;/a&gt;은 MDN을 참고하기 바란다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pushState()&lt;/code&gt;함수의 첫 번째 인자로는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;를 전달해야 하는데, 정해진 양식이 있는 것이 아니라 개발자가 식별할 수 있는 정보를 담아서 객체 형태로 넘기기만 하면 된다. 나는 &lt;code class=&quot;language-text&quot;&gt;{state : &apos;modal&apos;}&lt;/code&gt; 객체를 넣었다. 두 번째 인자는 아무 의미는 없지만 생략할 수는 없으므로 빈 문자열이나 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;를 넣으면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;openModal&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;Modal @close-modal=&amp;quot;closeModal&amp;quot; /&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const isModalOpen = ref(false);

  const openModal = () =&amp;gt; {
    isModalOpen.value = true;
  };
  const closeModal = () =&amp;gt; {
    isModalOpen.value = false;
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이전 포스팅에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;안의 코드는 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;라는 별도의 컴포넌트로 분리해두었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);
  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
  });
  const closeModal = () =&amp;gt; {
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이제 버튼을 누르면 모달이 열리면서 &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;이 추가됨을 확인할 수 있다. 하지만 여기서 뒤로가기를 누르더라도 모달이 닫히지는 않는다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;isModalOpen&lt;/code&gt;값은 여전히 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;이기 때문이다. 따라서 &apos;뒤로가기&apos;가 실행되면 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수가 실행되게끔 만들어야 한다.&lt;/p&gt;
&lt;h2&gt;popstate&lt;/h2&gt;
&lt;p&gt;자바스크립트에서 뒤로가기 이벤트를 감지하려면 &lt;code class=&quot;language-text&quot;&gt;popstate&lt;/code&gt;라는 함수를 이벤트리스너에 등록해야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;함수에 아래와 같이 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;onMounted(() =&amp;gt; {
  window.history.pushState({ state: &amp;quot;modal&amp;quot; }, undefined)
  window.addEventListener(&amp;quot;popstate&amp;quot;, closeModal)
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &apos;뒤로가기&apos;를 누르면 모달창도 닫힌고, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;도 다시 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 아직 한 가지 문제점이 남아있다.&lt;/strong&gt; &apos;뒤로가기&apos;를 누르지 않고 그냥 &lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫게 되면 모달을 닫히지만, &lt;code class=&quot;language-text&quot;&gt;history&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;되지 못하고 쌓여있게 된다. 즉 모달은 닫혀 있지만 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;를 찍어보면 &lt;code class=&quot;language-text&quot;&gt;{state:&apos;modal&apos;}&lt;/code&gt;인 상태로 남아있다는 것이다.&lt;/p&gt;
&lt;p&gt;즉 모달이 닫힐 때 &apos;뒤로가기&apos;를 눌러서 닫힌 건지,&lt;code class=&quot;language-text&quot;&gt;X&lt;/code&gt;버튼을 눌러서 닫힌 건지 구분해주어야 한다. 따라서 &lt;code class=&quot;language-text&quot;&gt;closeModal&lt;/code&gt;함수의 인자로 뒤로가기가 눌렸는지를 확인하는 인자를 받도록 수정한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const closeModal = (isBackward = false) =&amp;gt; {
  if (!isBackward) {
    history.back()
  }
  emit(&amp;quot;close-modal&amp;quot;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;버튼을 눌러서 닫았다면 &lt;code class=&quot;language-text&quot;&gt;isBackward&lt;/code&gt;값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;로 들어오고 &lt;code class=&quot;language-text&quot;&gt;history.back()&lt;/code&gt;를 호출하여 상태를 한단계 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;해주면 된다. 작동하는 모습은 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737988551/blog/assets/vue-modal-backward_ibefok.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;완성된 &lt;code class=&quot;language-text&quot;&gt;Modal.vue&lt;/code&gt;코드는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Modal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
      &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
      &amp;lt;button @click=&amp;quot;closeModal(false)&amp;quot;&amp;gt;X&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  const emit = defineEmits([&amp;#39;close-modal&amp;#39;]);

  onMounted(() =&amp;gt; {
    window.history.pushState({ state: &amp;#39;modal&amp;#39; }, undefined);
    window.addEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  onUnmounted(() =&amp;gt; {
    window.removeEventListener(&amp;#39;popstate&amp;#39;, () =&amp;gt; closeModal(true));
  });
  const closeModal = (isBackward = false) =&amp;gt; {
    if (!isBackward) {
      history.back();
    }
    emit(&amp;#39;close-modal&amp;#39;);
  };
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;생각&lt;/h2&gt;
&lt;p&gt;사실 웹뷰 환경에서 모달창이 열려있는 상태를 굳이 &apos;뒤로가기&apos;를 통해서 닫히게 동작해야 할까에 대해 고민이 많았다. 웹뷰는 웹만의 고유한 동작 방식이 있기 때문에 네이티브 앱을 흉내내는 일에 대해서는 회의적이었다. 하지만 개발자가 아닌 일반 사용자 입장에서는 자신이 사용하는 앱이 웹 기반인지 네이티브 기반인지는 별 관심은 없을 것이고, 개인마다 여러 앱을 사용해오면서 축적되어온 경험(&apos;뒤로가기&apos;하면 모달이 닫힘)이 그대로 적용되리라는 기대를 할 것이다.&lt;/p&gt;
&lt;p&gt;그래서 이번 개발을 계기로 유명하다싶은 앱은 모두 다운받아서 과연 &apos;모달창이 뒤로가기로 닫히는가&apos;를 시험해보았다(족히 30개의 앱으로 확인해보았다). 대략 90%의 앱이 네이티브 기반이었고, 이 앱들은 전부 다 뒤로가기를 통해 모달이 닫힘을 확인하였다. 나머지 10%의 웹뷰 기반 앱은 반반이었다. 어떤 앱은 뒤로가기를 누르면 모달이 닫힘과 함께 아예 이전 페이지로 이동해버리는 문제가 있었고, 이 경우의 사용자 예상과 다른 결과로 인하여 사용성이 떨어진다는 인상을 받았다.&lt;/p&gt;
&lt;p&gt;그래서 내가 내린 결론은 웹뷰는 사용자의 경험을 해치지 않는 선에서는 네이티브처럼 동작하게끔 최소한의 기대되는 동작은 구현해줘야 한다는 것이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue로 모달 구현하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert…]]></description><link>https://juheon.dev/vue/230802-vue-modal-open/</link><guid isPermaLink="false">https://juheon.dev/vue/230802-vue-modal-open/</guid><pubDate>Wed, 02 Aug 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/224&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;웹사이트를 이용하다 보면 모달창을 마주하게 된다. 일반적인 모달은 화면이 어두워지면서 기존의 화면은 fade out되면서, 화면 한가운데에서 focus되는 alert창과 같은 형태이다. 이를 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 어떻게 구현하는지 살펴보자.&lt;/p&gt;
&lt;h2&gt;모달 구현&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;로 모달을 구현하는 방법에는 여러가지가 있을 수 있다. 가장 간단한 형태는 하나의 파일 안에 모달을 다 집어넣는 방식일 것이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// MyModal.vue
&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style&amp;gt;
  @import url(&amp;#39;.../modal.css&amp;#39;)
&amp;lt;/style&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* modal.css */
.modal {
  position: fixed;
  z-index: 10;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}
.modal .modal-content {
  position: absolute;
  width: 600px;
  height: 400px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;이 방식의 경우 아래 사진과 같이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;태그는 기존 화면이 위치하고 있는 DOM노드 하위에 종속될 수 밖에 없다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983322/blog/assets/vue-modal-1.png_gnfctl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;여기서 한 가지 아쉬운 점이 생긴다. modal 창은 기존의 화면과 구분되는 속성인데 DOM 노드상에서도 이를 구분할 수 없을까? 즉 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;app&quot;&gt;&lt;/code&gt;과 같은 레벨로 끌어올릴 수 없을까? 하는 생각을 품게된다.&lt;/p&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;이를 해결하기 위해 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt; 기능을 적용해보자. &lt;code class=&quot;language-text&quot;&gt;teleport&lt;/code&gt;란 &lt;a href=&quot;https://ko.vuejs.org/guide/built-ins/teleport.html#basic-usage&quot;&gt;공식문서&lt;/a&gt;상에서는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;컴포넌트 템플릿의 일부를 해당 컴포넌트의 DOM 계층 외부의 DOM 노드로 &quot;이동&quot;할 수 있게 해주는 빌트인 컴포넌트입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;라고 설명하고 있다. 간단하게 요약하자면 기존에 보여지고 있던 화면과 논리적/기능적으로 구분된 또다른 화면을 표시해야할 때, 기존의 DOM 노드가 아닌 별도의 DOM노드로 마치 teleport(순간이동)할 수 있는 기능이다.&lt;/p&gt;
&lt;p&gt;이를 사용하기 위해서는 일단 DOM이 그려지는 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt;안에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이라는 새로운 태그를 추가한다. (id 대신에 class를 사용하더라도 작동은 정상적으로 하지만, 중복 문제를 피하기 위해 관습적으로 id를 사용하는 듯 하다.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    ...
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;noscript&amp;gt; ... &amp;lt;/noscript&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;modal&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 기존에 있던 &lt;code class=&quot;language-text&quot;&gt;MyModal.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;한 겹을 벗겨내고 대신에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport to=&quot;#modal&quot;&gt;&lt;/code&gt;을 넣어주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;modal&quot;&gt;&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div id=&quot;id&quot;&gt;&lt;/code&gt;와 DOM상에서 같은 레벨에 생성된 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983321/blog/assets/vue-modal-2.png_roscpy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;모달 열고 닫기&lt;/h2&gt;
&lt;p&gt;그렇다면 이제 이 모달을 동적으로 열고 닫을 수 있어야 한다. 방법은 예상하다시피 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;
나 &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하면 된다. 하지만 사용 방식에는 조금 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에는 오직 &lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;만 사용할 수 있고, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;는 작동하지 않는다. &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;를 사용하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;하위의 최상단 root노드에 걸어야만 작동한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;v-if&lt;/code&gt;는 값이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;일 경우 렌더링 시점에서 아예 제외되므로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;에 걸면 하위의 모든 노드들이 렌더링되지 않지만, &lt;code class=&quot;language-text&quot;&gt;v-show&lt;/code&gt;의 경우에는 일단 렌더링하고나서 값에 따라 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;으로 처리하는데 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;teleport&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;html&lt;/code&gt; 태그가 아닌 &lt;code class=&quot;language-text&quot;&gt;vue&lt;/code&gt;에서 제공하는 기능에 불과하므로 &lt;code class=&quot;language-text&quot;&gt;display:none&lt;/code&gt;이 걸리지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;
    &amp;lt;button @click=&amp;quot;isModalOpen = true&amp;quot;&amp;gt;open&amp;lt;/button&amp;gt;

    &amp;lt;!-- Modal --&amp;gt;
    &amp;lt;teleport to=&amp;quot;#modal&amp;quot; v-if=&amp;quot;isModalOpen&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;modal&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;modal-content&amp;quot;&amp;gt;
          &amp;lt;p&amp;gt;This is Modal&amp;lt;/p&amp;gt;
          &amp;lt;button @click=&amp;quot;isModalOpen = false&amp;quot;&amp;gt;close&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/teleport&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
  import { ref } from &amp;#39;vue&amp;#39;;
  const isModalOpen = ref(false);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[두 번째 프로젝트 회고]]></title><description><![CDATA[1. pinia와 typescript…]]></description><link>https://juheon.dev/essay/230712-second-project-review/</link><guid isPermaLink="false">https://juheon.dev/essay/230712-second-project-review/</guid><pubDate>Wed, 12 Jul 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. pinia와 typescript의 도입&lt;/h2&gt;
&lt;p&gt;이번 프로젝트(커머스)에서 드디어 벼르고 벼르어왔던 기술을 도입하게 되었다. 바로 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;원래는 더 빨리 도입하고 싶었으나, 이전 프로젝트가 생각보다 늘어짐 + 숙련도 이슈로 인하여 늦어진 감이 있다. 하지만 그만큼 더 철저하게 준비해서 도입 안하느니만 못한 상황이 벌어지지 않게끔 신경썼다. 여기서 &apos;도입 안하느니만 못한 상황&apos;이란 기껏 타입스크립트 도입해놓고 모든 타입을 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;로 정의한다든가, 에러 해결을 못해서 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 회귀한다든가 하는 상황이다. 도입 초반부에는 이런 일이 실제로 벌어질 위기가 몇 번 있었으나, 그때마다 구글링하고 공식문서 열심히 읽다보니 어찌어찌 해결은 할 수 있었다.&lt;/p&gt;
&lt;p&gt;도입해놓고 나서 느낀 점은 확실히 타입스크립트가 개발경험을 엄청나게 개선시켜준다. VScode에서 제공해주는 자동완성 기능을 맛보면 헤어나올 수가 없다. 특히나 내가 진행한 커머스는 그 특성상 프론트에서 다뤄야할 데이터가 많다. 하나의 상품 데이터 하나에도 그 속성이 20개가 넘고, 이 상품을 주문 로직을 태우려면 또 다시 주문을 위한 데이터 20여개가 추가된다.&lt;/p&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;로 개발을 했다면 40개가 넘는 데이터 중에서 하나라도 오타가 나거나 타입이 어긋나면 직접 시연해보며 그 에러를 찾는데 시간이 잡아먹혔겠지만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 사용함으로써 런타임 이전 시점에 어디서 문제가 생기는지 쉽게 찾을 수 있게 되었다.&lt;br&gt;
왜 사람들이 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;를 제대로 쓸 줄 알기 시작하면 쓰기 이전으로 돌아갈 수 없다고 말하는지 깨달았다. 아직 내가 &apos;제대로 쓴다&apos;라고 말하기엔 어설프긴 하다만, &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;학습 허들의 고비점은 넘긴 느낌이다.&lt;/p&gt;
&lt;p&gt;또 다른 기술 도입은 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 vue 커뮤니티에서 출시한 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신할 새로운 전역 상태관리 라이브러리이다. 사실 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신한다고는 해도, 그 개발진 대부분이 옮겨간 수준이라 크게 달라진 점은 없다.&lt;br&gt;
기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 사용하면서 느꼈던 불편한 점들, 그리고 &lt;code class=&quot;language-text&quot;&gt;ts&lt;/code&gt;와의 호환성 증대로 인하여 서로의 시너지를 극대화시킬 수 있다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에 대한 도입기는 &lt;a href=&quot;https://juheon.dev/vue/230704-start-pinia/&quot;&gt;이전 포스팅&lt;/a&gt;에 자세히 적어놓았다.&lt;/p&gt;
&lt;h2&gt;2. 페이지 / 컴포넌트 구조에 대한 고민&lt;/h2&gt;
&lt;p&gt;개발을 시작한지 얼마 되지 않은 초창기의 개발 스타일은 가급적이면 한 페이지에 내에 많은 기능을 압축적으로 집어넣으려고 했다. 개발이 익숙하지 않을 시기에는 파일을 여러 개로 쪼개는 것에 대한 부담감(두려움)도 있고, 상대적으로 규모가 작은 프로젝트를 맡았었기에 &apos;페이지,컴포넌트 구조론&apos;에 대해 고민이 깊지는 않았다.&lt;br&gt;
하지만 프로젝트의 규모가 점점 커질수록 페이지,컴포넌트의 개수가 많아지게 되고, 여러 파일을 다루는 일도 익숙해지면 자연스레 이 파일들을 어떤 기준으로 나눠야 효율적일지 고민하게 되었다.&lt;/p&gt;
&lt;p&gt;일단 &lt;strong&gt;페이지&lt;/strong&gt;란 사용자가 서비스에서 제공하는 특정한 기능 &lt;strong&gt;한 가지&lt;/strong&gt;를 수행하기 위해 만들어진다. 커머스 서비스로 예를 들자면 상품 전시, 결제, 장바구니, 주문조회와 같은 기능에는 모두 고유한 페이지가 존재한다. 그리고 페이지는 각자마다 고유한 &lt;code class=&quot;language-text&quot;&gt;path(url)&lt;/code&gt;를 부여받는다. 이 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;가 사용자와 개발자간의 접점이 되어서 상호작용이 가능한 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컴포넌트&lt;/strong&gt;는 그 페이지를 구성하고 있는 일종의 부속품이다. 컴포넌트에는 버튼이나 헤더,푸터, input창 하나하나도 개발자의 판단에 따라서 컴포넌트가 될 수도 있다. 컴포넌트를 분리하는 기준은 저마다 다를 수 있지만 나같은 경우에는 프로젝트 내에서 반복적으로 사용되는 여부와 기능을 구성하는 최소한의 단위를 따져서 만들게 된다.&lt;br&gt;
즉 하나의 페이지 안에도 수십개의 컴포넌트가 존재할 수 있고, 이 말은 곧 작은 기능을 담당하는 부품(컴포넌트)이 여러개가 합쳐짐에 따라 기능을 수행할 수 있게 되는 것이다.&lt;/p&gt;
&lt;p&gt;그래서 내가 페이지를 나누는 기준은 사용자의 행동 단위를 큼직하게 잘라서 구성하는데, 이 기준이 칼로 두부자르듯이 항상 말끔하게 구분되지는 않고 애매모호한 지점이 생긴다. 때로는 특정 행동에서 파생된 기능을 다뤄야 할 때가 있다.
예를 들어 &apos;주문조회&apos; 페이지에서 &apos;배송조회&apos;라는 파생기능이나, &apos;상품 주문&apos;페이지에서 &apos;주소 검색&apos;같은 기능들이다. 이러한 파생기능을 구현하려면 둘 중 하나의 방식을 선택해야 한다.&lt;/p&gt;
&lt;h4&gt;1. 메인 페이지에 녹여내기&lt;/h4&gt;
&lt;p&gt;가장 간단한 방법은 한 페이지에 두 기능을 다 표시하면 된다. 하지만 2가지의 별도의 행동을 하나의 페이지 안에 모두 보여주기에는 부담이 있다. 위에서 언급했던 &lt;strong&gt;페이지&lt;/strong&gt;의 정의와 같이 하나의 페이지 안에서는 &lt;strong&gt;한 가지&lt;/strong&gt; 기능만 수행하도록 하는 원칙에 위배되기 때문이다. 파생된 기능을 욱여넣음으로써 그 페이지만의 맥락을 모호하게 만들고 싶지는 않았다.&lt;/p&gt;
&lt;h4&gt;2. 별도의 페이지(&lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;)로 만들기&lt;/h4&gt;
&lt;p&gt;1번의 방법이 싫다면 페이지 자체를 분리하면 된다. 하지만 페이지를 남발하게 되면 그 만큼 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;의 수가 많아지게 된다. 한 페이지 내에서 파생 기능이 10가지라면 새로운 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt; 10가지가 추가된다는 뜻인데 과연 이게 효율적인 방법인지는 고민해봐야 한다.&lt;br&gt;
무엇보다 페이지를 쪼개면 메인 페이지 =&gt; 파생 페이지 로 데이터를 전달하기가 난처해진다. 페이지 =&gt; 컴포넌트 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;를 통해 전달할 수 있지만, 페이지 =&gt; 페이지 구조에서는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;전달이 불가능하다. 따라서 상태관리의 힘을 빌린다거나, 파생 페이지에서 다시 새로운 데이터를 &lt;code class=&quot;language-text&quot;&gt;fetch&lt;/code&gt;해야하는 비효율적인 문제가 발생한다.&lt;/p&gt;
&lt;p&gt;결국 방법 1,2 중 완벽한 방법은 없다. 하나의 페이지라는 제한적인 공간(맥락)안에서도 여러가지 파생된 기능을 넣어야 한다. 나는 이를 해결하기 위해서 &lt;strong&gt;모달&lt;/strong&gt;을 사용하였다. 모달은 별도의 &lt;code class=&quot;language-text&quot;&gt;path&lt;/code&gt;를 부여하지 않더라도 공간을 분리시킬 수 있다. 평소에는 메인페이지를 보여주고 있다가 사용자가 파생 기능을 선택했을 때에만 모달이 기존 화면을 덮음으로써 공간을 분리할 수 있다.&lt;/p&gt;
&lt;p&gt;그래서 결론을 얘기하자면 이번 프로젝트에서는 모달을 적극적으로 사용하였다. 모달은 &apos;페이지와 컴포넌트 사이 고민&apos;의 산물이다. 나는 페이지는 가능한 적게 만들면서 컴포넌트는 최대한 쪼갤 수 있을만큼 쪼개는 방식을 선호하다보니 이런 고민을 하게 된 것 같다.&lt;/p&gt;
&lt;h2&gt;3. 셀프 코드리뷰(클린 코드)&lt;/h2&gt;
&lt;p&gt;셀프 코드리뷰라는 말이 이상하게 들릴 수 있다. 하지만 회사에 프론트 개발자가 나 혼자밖에 없으니 누군가에게 코드 리뷰를 부탁하기 어려운 상황이다. 그래서 나는 회사에 다니는 동안 &apos;좋은 코드&apos;란 무엇일까에 대해 고민을 많이 할 수밖에 없었다. 그리고 이번 프로젝트에서 주안점으로 둔 3가지는,&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;시간이 지난 뒤에 다른 사람이 읽어도 자연스럽게 읽히는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;내가 짤 때는 나름 잘 짠 것 같은데, 나중에 다른사람이 내 코드를 읽고서 읽기 어렵다는 피드백을 들은 적이 있었다.
내가 보기에 잘 짠 것 같은 코드는 아무 의미가 없다. 모두가 이해할만한 보편적인 코드를 짜야한다.
특히 변수명과 함수명을 잘 짓는 일이 중요하다고 생각한다. 이름이 좀 길어지더라도 해당 변수(함수)가 하는 역할이 이름만 보고도 짐작할 수 있어야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;버그가 발생했을 때, 어느 부분을 고쳐야 하는지 직관적으로 찾을 수 있는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;버그가 발생하지 않는 방향으로 코드를 작성하는 게 가장 바람직하겠지만, 코드를 작성하다보면 버그 발생은 불가피하다. 그래서 버그가 발생하지 않도록 하는 일만큼 중요한 게 &apos;버그를 얼마나 쉽게 고칠 수 있느냐&apos;이다.&lt;br&gt;
대개 해결하기 어려운 버그들의 공통점은 하나의 코드 안에서 여러 로직들이 이어폰줄처럼 엉켜있을 때 발생한다. 어떤 부분을 고치면 이곳에 의존하고 있던 또 다른 함수에게 사이드이펙트가 전파되어서 또 다른 버그가 발생하고 만다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;한 번에 한 가지만 신경쓰는 코드&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;세 번째 정의가 어쩌면 첫 번째, 두 번째 조건을 모두 만족시키기 위한 대전제일 수 있다.&lt;br&gt;
&lt;strong&gt;단일책임원칙&lt;/strong&gt;이라는 객체 지향 프로그래밍의 원칙 중 하나이기도 한데, 하나의 객체는 딱 한 가지의 역할만 담당해야 한다는 원칙이다. 프론트엔드 코드가 엄밀한 객체지향 코드라고 하긴 어렵지만, 이 원칙 하나만큼은 신경써서 개발하는 게 도움이 된다.&lt;/p&gt;
&lt;p&gt;그 점 때문인지 이번 프로젝트는 이전 프로젝트보다 파일의 개수,디렉토리의 개수, 함수의 개수 등이 월등히 많아지게 되었다. 이전 프로젝트에서는 귀찮다거나, 코드의 양을 줄이는 게 무조건적인 미학이라 생각해서 하나의 함수 안에서 여러가지 일을 동시에 처리하는 경우가 많았었는데, 이번에는 그런 로직은 철저히 배제하였다.&lt;/p&gt;
&lt;h2&gt;4. 효율적인 소통 방식&lt;/h2&gt;
&lt;p&gt;마지막은 개발 외적인 이야기이다. &lt;a href=&quot;https://juheon.dev/230625-project-review/&quot;&gt;첫 번재 프로젝트 회고&lt;/a&gt;에서도 언급했다시피 프로젝트에서 가장 어려운 문제는 개발이 아니라 사람과 사람간의 소통의 문제인 경우가 더 많다. 특히나 프론트엔드 개발자는 그 특성상 기획/디자인/백엔드 모든 분야에 다리를 걸치고 있다보니 소통의 중요성이 더욱 강조될 수밖에 없다.&lt;/p&gt;
&lt;p&gt;이 중요성을 간과하고 무지성 개발만 하다보면 참사가 일어나기도 하는데 예를 들어 일주일 동안 열심히 개발/디자인 해놓았는데 나중에 보니 필요없는 기능이었다던지, 동료에게 특정 기능 하나를 요청했는데 나중에 보니 내 요청사항을 이해하지 못해서 기대와 다른 결과물을 받기도 한다. 그래서 이번 프로젝트에서는 내가 어떻게해야 조금 더 효율적으로 일할 수 있을 지에 대해서 먼저 고민해보았다.&lt;/p&gt;
&lt;h4&gt;첫 번째는 기획자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;내가 기획자에게 가장 많이 물어본 질문은 아마 &apos;나중에 이 기능이 추가될 수도 있나요?&apos;일 것이다. 개발 초기에 특정 기능을 배제하고 만들어놓았는데, 프로젝트 중간에 기획자가 &apos;이 기능 추가해주세요&apos;하는 사태가 벌어지면 상당히 곤란해진다.&lt;br&gt;
그래서 기획자와 개발자 사이에 서로의 상황을 이해하고 있어야 한다. 개발자는 기획자가 어떤 기능을 넣고 싶어하는지 파악해야하고, 반대로 개발자는 기획자에게 어떤 기능은 넣을 수 있고, 어떤 기능은 넣기 어려운지 분명하게 알려야 한다. 각자의 상황을 잘 알고 있어야만 나중에 &lt;code class=&quot;language-text&quot;&gt;이거 빼기로 했잖아요&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;이거 넣기로 했잖아요&lt;/code&gt; 사태를 방지할 수 있다.&lt;/p&gt;
&lt;h4&gt;두 번째는 디자이너와의 소통이다.&lt;/h4&gt;
&lt;p&gt;이전 프로젝트에서는 대부분 디자이너가 디자인 작업과 퍼블리싱 작업까지 도맡아서 한 뒤에, 나는 퍼블리싱의 최종 결과물 위에서 프론트엔드 개발을 시작했었다. 이 방식의 경우 디자이너와 프론트 개발자의 역할 부담이 완전히 나뉘어져 있는 방식인데, 이 경우 내가 프론트 개발을 하다가 디자이너에게 돌아가서 다시 물어봐야 하거나, 아니면 퍼블리싱된 코드가 개발하기에는 적합하지 않아 코드를 지우고 처음부터 다시 짜야하는 경우가 있었다.&lt;/p&gt;
&lt;p&gt;따라서 이번 프로젝트에서는 기초적인 디자인 작업과 퍼블리싱 단계에서부터 같이 참여했다. 기본적인 페이지 구조부터 컴포넌트를 어떤 단위로 쪼갤 것인지부터 고민했다. 그리고 자주 사용될만한 컴포넌트는 퍼블리싱 단계부터 미리 공통화를 시켜놓고 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값에 따라서 다르게 동작하도록 하였다.&lt;br&gt;
이렇게 작업한 결과, 이전보다 프론트엔드를 개발하면서 느꼈었던 모호함이 사라지고 1달이라는 비교적 빠른 시일 내에 서비스의 프로토타입을 개발할 수 있게 되었다.&lt;/p&gt;
&lt;h4&gt;세 번째는 백엔드 개발자와의 소통이다.&lt;/h4&gt;
&lt;p&gt;예전에는 프론트에 어떤 API가 필요한 상황이면 백엔드 개발자에게 두루뭉실하게 &apos;이러이러한 기능하는 API 만들어주세요&apos;라고 전달했었다. 구체적으로 말하지 않더라도 &apos;무슨 말 하는지 이해하겠지?&apos;라는 마인드여서 그랬었는데 이는 역시 나의 착각이다.&lt;/p&gt;
&lt;p&gt;백엔드 개발자는 내가 무엇을 필요로 하는지 정확히 이해하기 힘들다. 반대의 경우도 마찬가지이다. 그래서 요청사항을 전달하는 방식을 바꿨다. 일단 &apos;프론트에 이런 기능이 필요한데&apos;로 시작하여 상대방에게 내가 해결하고자 하는 문제상황을 납득시켜야한다. 그 다음에 &apos;프론트에서 이 엔드포인트로 요청을 보내면, 반환값 형식 이렇게 해서 보내주세요&apos; 라고 전달한다.&lt;br&gt;
여기서 중요한 점은 반환값 형식은 내가 우선적으로 제안을 해야한다. 백엔드에서 다루는 데이터 형식이 프론트의 그것과 상당 부분 다르기 때문에, 내가 원치 않은 형식으로 받게 될 수도 있기 때문이다.&lt;/p&gt;
&lt;p&gt;그리고 상품별로, 혹은 주문별로 상태코드를 정의해야 했다. 백엔드는 물론이고 프론트에서도 상태에 따라서 화면에 보여줘야 할 데이터가 다르기 때문이다. 이 과정 또한 백엔드와 같이 상의하면서 &apos;어떤 상태에서는 어떤 데이터를 보내줘야 하는지&apos;에 대한 일종의 규약을 만들었다.&lt;/p&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;나느 매 프로젝트를 진행하면서 스스로에게 미션을 부여한다. 처음 프로젝트를 맡았을 때는 &lt;code class=&quot;language-text&quot;&gt;vue2&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;vue3&lt;/code&gt;로 마이그레이션 하는 미션을, 이번 프로젝트에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;를 도입하는 미션이었다.&lt;/p&gt;
&lt;p&gt;이런 식으로 조금씩 내가 도전해볼만한, 개척의 여지를 찾아나감으로써 스스로 레벨업하고 있다는 느낌을 찾고 싶어서다. 누가 시켜서 하는 게 아니다. 그냥 기존에 쓰던 기술스택 그대로 써도 아무 문제 없다. 오히려 당장 개발할 때는 익숙할테니 버그도 덜 발생하고, 개발 기간도 더 짧을 수도 있다. 하지만 장기적인 관점에서, 그리고 유지보수의 관점에서는 기술을 도입함으로써 얻을 수 있는 이점이 훨씬 더 크다고 믿고 있다.&lt;/p&gt;
&lt;p&gt;다음 프로젝트에는 꼭 &lt;code class=&quot;language-text&quot;&gt;Next.js&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;Nuxt.js&lt;/code&gt;를 이용해서 SSR을 도입하고 싶다. 얼마 전에 살짝 찍먹해봤는데 쉽지 않을 것 같다.서버에 대한 이해도가 어느정도 갖춰져 있어야 할 것으로 보인다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TS 개념 정리]]></title><description><![CDATA[인덱스 시그니쳐 객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다. 유니온타입 인터섹션 타입 타입 alias enum 숫자형 enum 문자형 enum const enum 기본적인 enum…]]></description><link>https://juheon.dev/js_ts/230703-index-signature/</link><guid isPermaLink="false">https://juheon.dev/js_ts/230703-index-signature/</guid><pubDate>Wed, 05 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;인덱스 시그니쳐&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  [name: string]: string
}

const phone: Phone = {
  cpu: &amp;quot;A15&amp;quot;,
  sim: &amp;quot;eSIM&amp;quot;,
  brand : &amp;quot;Apple&amp;quot;,
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;객체의 속성의 개수가 정해져 있지 않다면 인덱스 시그니쳐를 사용하는 게 좋다.&lt;/p&gt;
&lt;h2&gt;유니온타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone | Laptop) {
  // device는 Phone과 Laptop 중 어떤 타입인지 정해져있지 않기 때문에
  // 두 인터페이스가 공통으로 갖고 있는 속성만 접근 가능하다.

  console.log(device.cpu) // ✅
  console.log(device.sim) // ❌

  // typeof나 in 연산자를 이용하여 타입을 필터링해주면 접근이 가능해진다.
  if (&amp;quot;sim&amp;quot; in device) {
    console.log(device.sim)
  }
  if (&amp;quot;gpu&amp;quot; in device) {
    console.log(device.gpu)
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;인터섹션 타입&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}

function getDevice(device: Phone &amp;amp; Laptop) {
  // device는 Phone과 Laptop 의 속성을 모두 만족시켜야 한다.
  console.log(device.cpu) // ✅
  console.log(device.sim) // ✅
}

getDevice({ cpu: &amp;quot;Intel&amp;quot;, sim: &amp;quot;eSIM&amp;quot; }) // ❌, Laptop이 갖고 있는 속성도 만족시켜야함.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;타입 alias&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Phone = {
  cpu: string
  sim: string
}
const myPhone: Phone = {
  cpu: &amp;quot;A16&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
interface Laptop {
  cpu: string
  gpu: string
}
// type은 연산자를 이용한 확장 가능
type Device = Phone | Laptop&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;enum&lt;/h2&gt;
&lt;h4&gt;숫자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Count {
  ZERO,
  ONE,
  TWO,
}
// 별도로 값을 지정하지 않으면 0부터 1씩 증가하면서 값이 배정된다
console.log(Count.ZERO) // 0
console.log(Count.ONE) // 1
console.log(Count.TWO) // 2&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;문자형 enum&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enum Color {
  PRIMARY = &amp;quot;blue&amp;quot;,
  SECONDARY = &amp;quot;white&amp;quot;,
}
console.log(Color.PRIMARY) // blue
console.log(Color.SECONDARY) // white&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;const enum&lt;/h4&gt;
&lt;p&gt;기본적인 enum은 컴파일 시, &lt;code class=&quot;language-text&quot;&gt;[속성이름]=값&lt;/code&gt;을 연결해주는 별도의 객체를 생성한다.&lt;br&gt;
하지만 enum 앞에 const를 붙이면 컴파일 시 객체를 생성하지 않고 &lt;code class=&quot;language-text&quot;&gt;[속성이름]&lt;/code&gt;을 직접 &lt;code class=&quot;language-text&quot;&gt;값&lt;/code&gt;으로 치환해버리기 때문에 컴파일 코드의 양을 줄일 수 있다.&lt;/p&gt;
&lt;h2&gt;제네릭&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T&amp;gt;(value: T): T {
  return value
}
// 파라미터에 어떤 타입을 넣느냐에 따라 value의 타입이 정해짐
console.log(gatValue(10)) // number type
console.log(gatValue(&amp;quot;hello&amp;quot;)) // string type&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getValue&amp;lt;T extends string&amp;gt;(value: T) {
  return value.length
}
// extends 키워드를 통해 제네릭으로 받을 타입을 제한할 수 있음
const num = getValue(10) // ❌
const str = getValue(&amp;quot;hello&amp;quot;) // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;&lt;code class=&quot;language-text&quot;&gt;T extends keyof type&lt;/code&gt;&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  sim: string
}
type PhoneType = keyof Phone // &amp;quot;cpu&amp;quot; | &amp;quot;sim&amp;quot;

function getPhoneComponent&amp;lt;T extends keyof Phone&amp;gt;(component: T) {
  return component
}
const component1 = getPhoneComponent(&amp;quot;cpu&amp;quot;) //  ✅
const component2 = getPhoneComponent(&amp;quot;gpu&amp;quot;) // ❌&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Non-null assertion&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const elem = document.querySelector(&amp;quot;.elem&amp;quot;)
// elem : HTMLElement | null
elem.textContent = &amp;quot;Hello&amp;quot; // ❌, elem is possibly null;
elem!.textContent = &amp;quot;Hello&amp;quot; // ✅&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;유틸리티 타입&lt;/h2&gt;
&lt;h4&gt;Pick&lt;/h4&gt;
&lt;p&gt;특정 타입만 골라내서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type Cpu = Pick&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: Cpu = {
  cpu: &amp;quot;A15&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Omit&lt;/h4&gt;
&lt;p&gt;특정 타입만 제외해서 새로운 타입을 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type withoutCpu = Omit&amp;lt;Phone, &amp;quot;cpu&amp;quot;&amp;gt;
const myPhone: withoutCpu = {
  ram: &amp;quot;8GB&amp;quot;,
  sim: &amp;quot;physical&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Partial&lt;/h4&gt;
&lt;p&gt;모든 타입을 옵셔널 파라미터로 바꿔서 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PartialPhone = Partial&amp;lt;Phone&amp;gt;
/*
  PartialPhone = {
    cpu?:string
    ram?:string
    sim?:string
  }
*/
const myPhone: PartialPhone = {
  ram: &amp;quot;8GB&amp;quot;,
}
const yourPhone: PartialPhone = {
  cpu: &amp;quot;A16&amp;quot;,
  ram: &amp;quot;8GB&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Exclude&lt;/h4&gt;
&lt;p&gt;유니온 타입에서 특정 타입을 제외하여 새로운 타입으로 만듦&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type WithoutApple = Exclude&amp;lt;PhoneBrands, &amp;quot;Apple&amp;quot;&amp;gt; // &amp;#39;Samsung&amp;#39; | &amp;#39;LG&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Record&lt;/h4&gt;
&lt;p&gt;key-value 값 형태의 객체 타입을 만들어줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneComponent = Record&amp;lt;PhoneBrands, Phone&amp;gt;
/*
 type PhoneComponent = {
  Samsung: Phone
  Apple: Phone
  LG: Phone
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;맵드 타입&lt;/h2&gt;
&lt;p&gt;이미 정의된 타입을 가지고 새로운 타입을 만들어줌&lt;/p&gt;
&lt;h4&gt;in&lt;/h4&gt;
&lt;p&gt;유니온타입의 원소를 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type PhoneBrands = &amp;quot;Samsung&amp;quot; | &amp;quot;Apple&amp;quot; | &amp;quot;LG&amp;quot;
type Phone = {
  [brand in PhoneBrands]: string
}
/*
type Phone = {
    Samsung: string;
    Apple: string;
    LG: string;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;in keyof&lt;/h4&gt;
&lt;p&gt;객체의 각 속성을 하나씩 순회하면서 string 형태로 뽑아줌&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Phone {
  cpu: string
  ram: string
  sim: string
}
type PhoneIncluded = {
  [phone in keyof Phone]: boolean
}
/*
type PhoneIncluded = {
    cpu: boolean;
    ram: boolean;
    sim: boolean;
}
*/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yes24.com/Product/Goods/119410497&quot;&gt;쉽게 시작하는 타입스크립트(장기효)&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[pinia 소개 및 도입 후기]]></title><description><![CDATA[pinia란? 기존 vue의 전역 상태관리 라이브러리는 거의 가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 ,,,와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 9…]]></description><link>https://juheon.dev/vue/230704-start-pinia/</link><guid isPermaLink="false">https://juheon.dev/vue/230704-start-pinia/</guid><pubDate>Tue, 04 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;pinia란?&lt;/h2&gt;
&lt;p&gt;기존 vue의 전역 상태관리 라이브러리는 거의 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;가 독점하다시피 한 시장이었다. 옆 동네 react만 하더라도 &lt;code class=&quot;language-text&quot;&gt;redux&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;recoil&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;MobX&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;zustand&lt;/code&gt;와 같이 여러 라이브러리 중에서 선택할 수 있었지만, vue에서는 선택권 없이 사실상 99% &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 써야했다. 오히려 이 점이 학습에 대한 부담(여러 라이브러리 두루 알고 있어야 함)을 줄여주기도 했지만, vuex의 아쉬운 점을 대체할 수단이 없다는 단점을 껴안고 있었다.&lt;/p&gt;
&lt;p&gt;그러다가 2019년 11월에 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 experiment to redesign(리디자인 실험)으로서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;가 처음 출시되었고, 현재는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;를 대신하여 vue의 공식 상태관리 라이브러리로 자리잡았다. 이름은 달라졌다고는 해도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt; 개발팀이 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 개발했기 때문에 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 기능과 문법은 거의 바뀌지 않았고 새로 학습해야할 내용도 부담 없는 수준이다.(공식문서에서는 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;vuex 5&lt;/code&gt;의 다른 이름이라고 소개한다)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://npmtrends.com/pinia-vs-vuex&quot;&gt;npmtrends&lt;/a&gt;를 보더라도 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와의 격차가 점점 줄어들고 있음을 확인할 수 있다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983320/blog/assets/npm-trends-pinia_ccipfc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2&gt;vuex와 비교해 달라진 점&lt;/h2&gt;
&lt;h4&gt;1. 다중 store&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서 여러 종류의 store를 사용할 경우 일반적으로 modules 디렉토리 밑에 몰아넣고 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 하나로 합쳐주는 방식을 사용하였다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
src
└── store
    ├── index.js
    └── modules
        ├── counter.js
        ├── user.js
        ├── order.js
        └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 다중store를 지원하기 때문에 modules를 사용할 필요가 없어졌다. 따라서 stores 디렉토리 밑에 모든 store를 둘 수 있게 되었다. (개인 선호에 따라 &lt;code class=&quot;language-text&quot;&gt;stores/index.js&lt;/code&gt;를 두어서 기본 설정을 초기화하는 코드를 작성하기도 한다.)&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
src
└── stores
    ├── counter.js
    ├── user.js
    ├── order.js
    └── ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;2. mutation 없이 state의 직접 변경 가능&lt;/h4&gt;
&lt;p&gt;기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 state의 값을 변경하려면 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 통해야 했다.&lt;br&gt;
가령 &lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;라는 state와 이 값을 증가시키는 &lt;code class=&quot;language-text&quot;&gt;increment&lt;/code&gt;라는 함수가 있다고 하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
const store = createStore({
  state: {
    count: 1,
  },
  mutations: {
    increment(state) {
      state.count++
    },
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt;값을 증가시키기 위해서는 반드시 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;에 등록된 함수를 통해서만 접근해야 한다.
&lt;code class=&quot;language-text&quot;&gt;store.state.count++&lt;/code&gt;처럼 직접적으로 state를 변경시키는 건 허용되지 않았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ $store.state.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    // store.state.count++; // 직접 변형 불가
    store.commit(&amp;#39;increment&amp;#39;); // 반드시 mutation을 통해서만 변형
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 사라지고 값의 직접 변형이 가능해졌다. 따라서 매번 state값을 변경하기 위한 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;함수를 만들 필요가 없어졌기 때문에 상당히 편리해졌다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 1,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;counterStore&lt;/code&gt;로 받아오기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;template&amp;gt;
  &amp;lt;p&amp;gt;{{ counterStore.count }}&amp;lt;/p&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    counterStore.count++; // 직접 변경 가능
    return{
      counterStore,
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;변경해야 하는 값이 복잡하거나, 따로 함수로 분리하고 싶다면 &lt;code class=&quot;language-text&quot;&gt;actions&lt;/code&gt;에서 선언하거나 혹은 아래에서 설명할 &lt;code class=&quot;language-text&quot;&gt;$patch&lt;/code&gt; 라는 내장 메소드를 사용하면 된다.&lt;/p&gt;
&lt;h4&gt;3. Typescript 호환성 증가&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 도입하기 까다로웠던 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 쉽게 사용할 수 있게 되었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;typescript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
interface VueLib {
  state: &amp;quot;vuex&amp;quot; | &amp;quot;pinia&amp;quot;
}

export const useCounterStore = defineStore(&amp;quot;counter&amp;quot;, {
  state: () =&amp;gt; {
    return {
      count: 0 as number,
      library: {
        state: &amp;quot;pinia&amp;quot;,
      } as VueLib,
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;프로젝트 도입 후기&lt;/h2&gt;
&lt;h4&gt;1. mutation 이 없어서 정말 편리하다&lt;/h4&gt;
&lt;p&gt;위에서 언급했다시피 state값의 직접 변형이 가능하기 때문에 별도의 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;을 선언할 필요가 없다는 점이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;로 개발하면서 느꼈던 답답함을 한방에 뚫어주는듯한 기분이다. 덕분에 &lt;code class=&quot;language-text&quot;&gt;store&lt;/code&gt; 코드의 절반 가량을 차지하던 부분이 사라졌으니 코드가 상당히 가벼워지고 가독성도 나아졌다.&lt;/p&gt;
&lt;h4&gt;2. 생각보다 유용한 내장 메소드&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 Option API 기준으로 3개의 내장 메소드를 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$reset()&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt; 값들을 모두 초기화시킨다. 예를 들어 회원 로그인시 회원 데이터를 store에 갖고 있다가 로그아웃을 하면 값을 초기화해주어야 할 때 사용한다. 기존 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;에서는 개발자가 직접 reset함수를 만들어야 했는데 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 에서는 그럴 필요가 없어졌다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$patch(state)&lt;/code&gt; : state값을 변경시켜주는 함수이다. &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 값의 직접 변경이 가능한데 왜 굳이 필요한가 싶을 수 있는데, 여러 변수들의 값을 한번(함수 하나)에 변경하려고 할 때나 값의 변경 로직이 복잡해지면 오히려 &lt;code class=&quot;language-text&quot;&gt;mutation&lt;/code&gt;이 그리워 질 수도 있다. &lt;code class=&quot;language-text&quot;&gt;$patch()&lt;/code&gt;함수가 그 역할을 대신한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;counterStore.$patch({ count: 1 })
OR
counterStore.$patch(state =&amp;gt; {
  state.count = state.count + 1
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;$subscribe(mutation,state)&lt;/code&gt; : 현재 store의 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;watch&lt;/code&gt;하는 기능이라고 생각하면 된다. 프로젝트에서는 이 기능을 써보지 않아서 정확히 어떤 상황에 필요할 지는 잘 모르겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. modules가 없어져서 코드 양은 쪼금 늘어날 수 있다&lt;/h4&gt;
&lt;p&gt;개인적으로 한가지 아쉬운 점은 모든 store를 하나로 묶어주는 modules 기능의 부재로 인하여 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 가져올 때처럼 &lt;code class=&quot;language-text&quot;&gt;$store.state.[store이름]&lt;/code&gt; 식으로 접근할 수 없다는 점이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// vuex
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{$store.state.counter.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;에서는 반드시 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt;레벨에서 &lt;code class=&quot;language-text&quot;&gt;use*Store()&lt;/code&gt; 훅을 이용하여 &lt;code class=&quot;language-text&quot;&gt;*store&lt;/code&gt;를 한번 빼와야만 &lt;code class=&quot;language-text&quot;&gt;template&lt;/code&gt;레벨에서도 값을 전달할 수 있다. 그래서 코드의 양이 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;대비 늘어날 수도 있다. 그렇다고 이거 하나가 단점이라 지적하기엔 사소한 문제이고 1,2번에서 얻을 수 있는 이점이 훨씬 더 크다고 생각한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// pinia
&amp;lt;tempalate&amp;gt;
  &amp;lt;div&amp;gt;{{counterStore.count}}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  ...
  setup(){
    const counterStore = useCounterStore();
    return{
      counterStore,
    }
  }
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;총평&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 비교하여 typescript 지원, mutation 삭제, 다중 store지원 같은 기능으로 인하여 DX(개발 경험)을 상당히 개선시켜 주었다. 커뮤니티와 자료의 양이 아직 &lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;만큼은 아니지만 조금씩 쌓여나가고 있다는 점에서 &lt;code class=&quot;language-text&quot;&gt;pinia&lt;/code&gt; 도입을 주저하는 개발자가 있다면 주저하지 말고 한번 써보라고 추천하고 싶다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (2 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>https://juheon.dev/vue/230702-vmodel-and-custom-component-2/</link><guid isPermaLink="false">https://juheon.dev/vue/230702-vmodel-and-custom-component-2/</guid><pubDate>Sun, 02 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juheon.dev/vue/230701-vmodel-and-custom-component-1/&quot;&gt;지난 포스팅&lt;/a&gt;에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리와 커스텀 컴포넌트를 만드는 방법에 대해서 살펴보았다. 이번 포스팅에서는 만들어진 컴포넌트에다 각각의 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 특성에 맞는 로직을 구현해보도록 하겠다.&lt;/p&gt;
&lt;h2&gt;기본 구조&lt;/h2&gt;
&lt;p&gt;부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;와 전화번호를 위한 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;, 이메일을 위한 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 자식 컴포넌트로 구성한다. 자식 컴포넌트는 지난 포스팅에서 다루었던 &lt;code class=&quot;language-text&quot;&gt;MyInput.vue&lt;/code&gt;를 베이스로 작성했다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;App.vue
└── MainPage.vue
  ├── InputContact.vue
  └── InputEmail.vue&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;연락처와 이메일과 관련된 변수는 당연히 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서만 관리하고, 두 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에는 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 전달하여 데이터 처리 로직 수행 후, &lt;code class=&quot;language-text&quot;&gt;emit(&apos;update:modelValue&apos;)&lt;/code&gt;로 가공된 데이터를 넘겨주는 방식이다.&lt;/p&gt;
&lt;h2&gt;전화번호를 위한 input&lt;/h2&gt;
&lt;p&gt;전화번호를 입력하는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;을 생각해보자. 우선적으로 필요한 기능은 전화번호 사이마다 &apos;-&apos;를 넣어주는 기능이다. 예를 들어 사용자가 &lt;code class=&quot;language-text&quot;&gt;01012345678&lt;/code&gt;를 입력한다면 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;010-1234-5678&lt;/code&gt;로 표시되도록 해야한다.&lt;/p&gt;
&lt;p&gt;그래서 일단 전화번호 포맷팅을 수행하는 &lt;code class=&quot;language-text&quot;&gt;formatContact()&lt;/code&gt; 함수에 정규표현식을 사용하려고 한다. 전화번호 포맷팅 관련 정규표현식은 구글링을 해봐도 쉽게 찾을 수 있지만 내가 사용한 정규표현식은 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 &lt;code class=&quot;language-text&quot;&gt;formatContact&lt;/code&gt;함수를 &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt;의 콜백함수에 넣어주고, &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 호출할 때도 &lt;code class=&quot;language-text&quot;&gt;formatted&lt;/code&gt;된 값을 부모 컴포넌트(&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;)에 넘겨야한다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
    const formatted = formatContact(newValue);
    emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const formatContact = (rawString) =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3,4,4자리로 끊고 -로 구분
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;); //아직 숫자 입력되기 전의 -는 가려주기
  return formatted;
};
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;는 그냥 일반적인 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그를 다룰 때처럼만 작성하면 된다. 커스텀 컴포넌트로 변경했다고 한들, 부모 컴포넌트가 데이터 처리 로직에 관여해서 안되고 &lt;code class=&quot;language-text&quot;&gt;Input*.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;되는 이벤트에만 의존하고 있어야 한다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputContact v-model=&amp;quot;contact&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;contact : {{ contact }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputContact from &amp;quot;@/components/InputContact.vue&amp;quot;;

const contact = ref(&amp;quot;&amp;quot;);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;선택적으로 포맷팅하고 싶다면?&lt;/h4&gt;
&lt;p&gt;위 코드에서는 전화번호가 항상 포맷팅되지만, 상황에 따라서는 포맷팅되지 않는 걸 원할 수도 있다. &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;로 &lt;code class=&quot;language-text&quot;&gt;useFormat&lt;/code&gt; 을 받아서 이 값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;일 때만 포맷팅되도록 할 수도 있다.&lt;/p&gt;
&lt;h4&gt;InputContact.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const props = defineProps({
  modelValue: String,
  useFormat: {
    type: Boolean,
    default: true,
  },
})

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;])

const onInput = e =&amp;gt; {
  const newValue = e.target.value
  if (props.useFormat) {
    const formatted = formatContact(newValue)
    emit(&amp;quot;update:modelValue&amp;quot;, formatted)
  } else {
    emit(&amp;quot;update:modelValue&amp;quot;, newValue)
  }
}

const formatContact = rawString =&amp;gt; {
  const formatted = rawString
    .replace(/[^0-9]/g, &amp;quot;&amp;quot;) // 숫자만 필터링하기
    .replace(/^(\d{0,3})(\d{0,4})(\d{0,4})$/g, &amp;quot;$1-$2-$3&amp;quot;) // 3자리,4자리,4자리로 끊고 -로 구분하기
    .replace(/(\-{1,2})$/g, &amp;quot;&amp;quot;) //아직 숫자 입력되기 전의 -는 가려주기
  return formatted
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;InputContact :useFormat=&amp;quot;true&amp;quot; v-model=&amp;quot;contact&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;이메일을 위한 input&lt;/h2&gt;
&lt;p&gt;이번에는 이메일을 입력받는 &lt;code class=&quot;language-text&quot;&gt;InputEmail.vue&lt;/code&gt;를 살펴볼텐데, 전화번호와는 다르게 유효성을 검증하는 기능을 하나 추가하려고 한다. 이메일 유효성을 검증하는데에도 역시 구글링해보면 정규표현식이 많이 나오긴 하지만 여기서는 편하게 &lt;code class=&quot;language-text&quot;&gt;email-validator&lt;/code&gt;라는 npm 패키지를 사용했다.&lt;/p&gt;
&lt;p&gt;큰 틀에서는 &lt;code class=&quot;language-text&quot;&gt;InputContact.vue&lt;/code&gt;와 동일하나, &lt;code class=&quot;language-text&quot;&gt;@input&lt;/code&gt; 이벤트마다 유효성 검증을 거친 값을 부모 컴포넌트인 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 전달해주어야 한다. 따라서 나는 &lt;code class=&quot;language-text&quot;&gt;emit(&apos;is-valid&apos;,유효성여부)&lt;/code&gt;으로 지정했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&amp;quot;email&amp;quot; :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import * as EmailValidator from &amp;quot;email-validator&amp;quot;;

const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;, &amp;quot;is-valid&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  const isEmailValid = checkEmailValid(newValue);
  emit(&amp;quot;is-valid&amp;quot;, isEmailValid);
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};

const checkEmailValid = (email) =&amp;gt; {
  return EmailValidator.validate(email);
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러면 &lt;code class=&quot;language-text&quot;&gt;MainPage.vue&lt;/code&gt;에서는 &lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;으로 보낸 값을 &lt;code class=&quot;language-text&quot;&gt;@is-valid&lt;/code&gt;로 받고 콜백함수에서 유효성 여부를 인자로 받을 수 있다. 콜백함수를 위한 별도의 함수를 하나 만들어도 되긴 하는데, 예제 상에서는 만들지 않고 &lt;code class=&quot;language-text&quot;&gt;isEmailValid&lt;/code&gt;라는 변수에 직접 넣어주는 방식을 선택하였다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;InputEmail v-model=&amp;quot;email&amp;quot; @is-valid=&amp;quot;(data) =&amp;gt; (isEmailValid = data)&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;email : {{ email }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;valid : {{ isEmailValid }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import InputEmail from &amp;quot;@/components/InputEmail.vue&amp;quot;;

const email = ref(&amp;quot;&amp;quot;);

const isEmailValid = ref(null);
&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-2-mcx2wv?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input-2&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[v-model 원리와 커스텀 컴포넌트 만들기 (1 of 2)]]></title><description><![CDATA[2023-04-0…]]></description><link>https://juheon.dev/vue/230701-vmodel-and-custom-component-1/</link><guid isPermaLink="false">https://juheon.dev/vue/230701-vmodel-and-custom-component-1/</guid><pubDate>Sat, 01 Jul 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/226&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;반복되는 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그&lt;/h2&gt;
&lt;p&gt;사용자에게 입력을 받기 위해서는&lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그가 필요한데, 입력 받는 데이터의 종류와 특성에 따라 제공되는 기능이 달라질 수 있다. 예를 들어 &apos;오늘의 집&apos;의 주문 페이지를 살펴보자.&lt;/p&gt;
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737988384/blog/assets/input-tag-1_qewxeo.png&quot;&gt;
&lt;!--![](./input-tag-1.png)--&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이름이나 주소같은 단순한 텍스트 : &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;text&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;문자가 아닌 오직 숫자만 입력받을 경우(상품 수량) &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;number&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전화번호 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;tel&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이메일 형식 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&quot;email&quot;&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이처럼 같은 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt;태그라도 각각의 특성과 수행해야 될 기능이 다르다.&lt;br&gt;
이름이나 주소의 경우에는 빈 문자열이어서는 안된다거나 최소/최대 글자수 제한이 있을 수 있고, 전화번호나 이메일은 유효성 검증을 거쳐야 할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;속성으로으로도 어느정도 해결할 수는 있지만, 이러한 기능을 가진 &lt;code class=&quot;language-text&quot;&gt;input&lt;/code&gt; 태그들이 프로젝트에서 반복적으로 사용된다면 컴포넌트로 분리시켜 공통화하고 싶다는 생각이 든다. 그러면 각 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Input&gt;&lt;/code&gt; 컴포넌트별로 특정 기능에만 집중할 수 있다. 그렇다면 커스텀 컴포넌트화 시키려면 어떻게 해야하는지 살펴볼 건데, 그 전에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리에 대해서 알아보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;의 작동원리&lt;/h2&gt;
&lt;p&gt;vue의 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 양방향 데이터바인딩(two-way binding) 기능을 제공하는 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;br&gt;
양방향 바인딩이란, 화면상에 보이는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;에 데이터를 입력(수정)할 때마다 &lt;code class=&quot;language-text&quot;&gt;Javascript&lt;/code&gt;에서도 실시간으로 변화를 감지하여 값이 업데이트 되는 기능이다.&lt;/p&gt;
&lt;p&gt;SPA 라이브러리를 vue로 처음 입문한 사람에게는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 왜 편리한 기능인지 이해하기 어려울 수 있지만, react를 접한 뒤에 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 만난다면 그 편리함에 감탄할 것이다. 왜냐하면 react에서 양방향 바인딩을 구현하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;태그에 다음와 같이 작성해야만 했다.&lt;/p&gt;
&lt;h4&gt;react&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const [text, setText] = useState(&amp;quot;&amp;quot;)
const onInputChange = e =&amp;gt; {
  setText(e.target.value)
}
...
return &amp;lt;input onChange={onInputChange} value={text} /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 이를 vue에서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;로 구현한다면 간단하게 구현할 수 있다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input v-model=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;두 코드 사이에서 주목해야 할 점은 react의 경우에 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt; 태그에 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개가 필요한 반면에, vue에서는 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt; 단 하나만 필요하다는 점이다. 단순히 생각해보더라도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;onChange&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 2개의 역할을 동시에 수행하고 있으리라 예상할 수 있다.&lt;br&gt;
사실은 vue도 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;을 사용하지 않고 양방향 바인딩을 구현해보자면 아래와 같이 구현해야 했다.&lt;/p&gt;
&lt;h4&gt;vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// &amp;lt;template&amp;gt;
&amp;lt;input @change=&amp;quot;onChangeInput&amp;quot; :value=&amp;quot;text&amp;quot;&amp;gt;
// &amp;lt;script setup&amp;gt;
const text = ref(&amp;#39;&amp;#39;);
const onChangeInput = (e) =&amp;gt; {
  text.value = e.target.value
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 매번 두 개의 속성을 적어주는 건 성가신 일이기 때문에 이를 하나로 합쳐서 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 탄생하게 된 것이다.
vue에서는 이처럼 tag 레벨에서 자주 쓰이는 기능들은 하나의 공통 함수로 묶게 되었는데 이게 바로 vue의 &lt;code class=&quot;language-text&quot;&gt;directive&lt;/code&gt;이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;필자 개인의견 : &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;이 react와 vue가 추구하는 방향성의 다름을 가장 잘 보여주는 대목이다. react는 코드 뒷편에서 무슨 일이 일어나는지 최대한 개발자에게 숨기지 않고 드러내려는 반면, vue는 &apos;이 기능은 라이브러리에서 책임질테니, 무슨 일이 일어나는 지는 신경쓰지 마&apos;라고 말하는 인상이 들었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;커스텀 컴포넌트로 만들기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;input&gt;&lt;/code&gt;을 컴포넌트화 시켜서 부모-자식간의 관계가 형성되면 부모 컴포넌트에서 자식 컴포넌트로&lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;를 별도로 연결시켜주어야만 양방향 데이터 바인딩 기능을 유지할 수 있다.&lt;/p&gt;
&lt;p&gt;방법은 어렵지 않다. 부모 컴포넌트 입장에서는 컴포넌트화하기 이전 코드와 동일하게 &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;data&quot;&lt;/code&gt;를 걸어주기만 하면 된다. 이렇게만 하면 자식 컴포넌트의 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;에서 자동으로 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;라는 (미리 정해진)이름으로 받을 수 있게 된다.&lt;/p&gt;
&lt;p&gt;다만 자식 컴포넌트에서는 별도로 처리해줘야 한다. &lt;code class=&quot;language-text&quot;&gt;v-model=&quot;modelValue&quot;&lt;/code&gt;로 받을 수 있을 것 같지만 아쉽게도 불가능하다. 왜냐하면 &lt;code class=&quot;language-text&quot;&gt;v-model&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;@input=&quot;(e) =&gt; modelValue = e.target.value&quot;&lt;/code&gt;가 생략되어있는데, vue에서 자식 컴포넌트가 받은 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;값(여기서는 &lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;)의 직접 변형이 불가능하기 때문이다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 자식 컴포넌트에서는 input 이벤트가 발생하면 부모 컴포넌트에게 이를 알려야 한다.&lt;br&gt;
자식컴포넌트가 부모컴포넌트에게 이벤트를 발생시키고 싶을 때 호출하는&lt;code class=&quot;language-text&quot;&gt;emit&lt;/code&gt;함수를 통해&lt;br&gt;
&lt;em&gt;&quot;&lt;code class=&quot;language-text&quot;&gt;modelValue&lt;/code&gt;의 값이 &lt;code class=&quot;language-text&quot;&gt;e.target.value&lt;/code&gt;로 변했다&quot;&lt;/em&gt;&lt;br&gt;
는 정보만 전달하고, 실질적인 변경된 값을 반영하는 과정은 부모 컴포넌트에서 진행되야 한다. 다행히도 그 과정은 이미 &lt;code class=&quot;language-text&quot;&gt;update:modelValue&lt;/code&gt;라는 이벤트로 미리 등록되어 있기 때문에 우리가 직접 구현할 필요는 없다.&lt;/p&gt;
&lt;h4&gt;MainPage.vue (parent)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;MyInput v-model=&amp;quot;num&amp;quot; /&amp;gt;
    &amp;lt;p&amp;gt;text : {{ num }}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
import { ref } from &amp;quot;vue&amp;quot;;
import MyInput from &amp;quot;@/components/MyInput.vue&amp;quot;;

const num = ref(&amp;quot;Hello&amp;quot;);
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;MyInput.vue (child)&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;!-- 불가능 --&amp;gt;
  &amp;lt;!-- &amp;lt;input v-model=&amp;quot;modelValue&amp;quot; /&amp;gt;  --&amp;gt;

  &amp;lt;input :value=&amp;quot;modelValue&amp;quot; @input=&amp;quot;onInput&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script setup&amp;gt;
const props = defineProps({
  modelValue: String,
});

const emit = defineEmits([&amp;quot;update:modelValue&amp;quot;]);

const onInput = (e) =&amp;gt; {
  const newValue = e.target.value;
  emit(&amp;quot;update:modelValue&amp;quot;, newValue);
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-custom-input-3tnt3q?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-custom-input&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;
&lt;p&gt;&lt;em&gt;다음 포스팅에서 &apos;input 종류별로 기능 적용하기&apos;를 소개하겠습니다&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react에는 named-route 없나요?(Feat. vue에는 있는데..)]]></title><description><![CDATA[2023-05-05에 작성된 원문을 수정한 버전입니다 vue-router를 사용하는 두 가지 방법 vue…]]></description><link>https://juheon.dev/vue/230630-vue-named-route/</link><guid isPermaLink="false">https://juheon.dev/vue/230630-vue-named-route/</guid><pubDate>Fri, 30 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-05-05에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/229&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;vue-router를 사용하는 두 가지 방법&lt;/h2&gt;
&lt;p&gt;vue에서는 &lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서 제공하는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;router-link&gt;&lt;/code&gt; 컴포넌트로 페이지 이동을 하려면 크게 두 가지 방법이 있는데, 하나는 해당 페이지의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 직접 적는 방법과 다른 하나는 &lt;code class=&quot;language-text&quot;&gt;router&lt;/code&gt;에서 미리 정의해둔 &lt;code class=&quot;language-text&quot;&gt;route name&lt;/code&gt;을 적는 방법이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/about&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt;

// 그리고 vue-router에서 미리 route별로 name을 지정해주어야 한다
const routes = [
	{
		path: &amp;#39;/&amp;#39;,
		name: &amp;#39;Home&amp;#39;,
		component: ...,
	},
	{
		path: &amp;#39;/about&amp;#39;,
		name: &amp;#39;About&amp;#39;,
		component: ...,
	},
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;하지만 오타가 난다면?&lt;/h2&gt;
&lt;p&gt;나는 개발할 때 주로 방법 2를 선호하는데 그 이유는 방법 1의 경우에는 경로명을 잘못 입력하더라도 에러로 검출해내지 못하고 클릭하면 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동시켜버리는 반면에, 방법 2는 아래와 같이 개발자 도구의 콘솔창에서 에러를 띄워주기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 1
&amp;lt;router-link to=&amp;quot;/&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link to=&amp;quot;/abou&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생X&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 방법 2
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;홈&amp;lt;/router-link&amp;gt;
&amp;lt;router-link :to=&amp;quot;{name : &amp;#39;Abou&amp;#39;}&amp;quot;&amp;gt;어바웃&amp;lt;/router-link&amp;gt; // 오타, 에러 발생함&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983320/blog/assets/named-route-error_gzcpws.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;방법 1은 오타가 발생하더라도 해당 라우터를 클릭해서 404 페이지가 뜨는 걸 확인하기 전까지는 찾기가 어렵다. 왜냐하면 사용자가 오타를 낸 건지, 아니면 정말로 &lt;code class=&quot;language-text&quot;&gt;/abou&lt;/code&gt;페이지로 이동하길 원하는지 라우터에게는 알 수 있는 정보가 없기 때문이다.&lt;/p&gt;
&lt;p&gt;반면에 방법 2에서는 라우터를 클릭하기 전에도 콘솔창에서 에러를 검출할 수 있다. &lt;code class=&quot;language-text&quot;&gt;routes&lt;/code&gt;에 들어있는 원소를 하나씩 뒤져보면서 name이 &lt;code class=&quot;language-text&quot;&gt;Abou&lt;/code&gt;와 일치하는 라우트를 찾아본다. 일치하는 라우트가 없으면 에러로 판별해낼 수 있는 단서가 제공된다는 뜻이다.&lt;/p&gt;
&lt;p&gt;이런 식으로 vue 에서는 &lt;code class=&quot;language-text&quot;&gt;named-route&lt;/code&gt;기반으로 페이지 이동이 가능하기 때문에 예상치 못한 오타 발생시 에러로 검출할 수 있는 반면에 react에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link to={&apos;/about&apos;}&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;useNavigate&lt;/code&gt;훅의 &lt;code class=&quot;language-text&quot;&gt;navigate(&apos;/about&apos;)&lt;/code&gt;와 같이 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt; 기반으로만 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 위의 언급한 방법 1처럼 오타로 인한 route 이동을 막을 수 있는 방법은 아직까지는 찾지 못하였다. 타입스크립트로 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 &lt;code class=&quot;language-text&quot;&gt;enum&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;으로 변수화시키는 방법이라면 가능할 지도 모르겠다는 생각은 드는데, 실무에서도 그렇게 개발할 지는 모르겠다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;현재 페이지 판별&lt;/h2&gt;
&lt;p&gt;위 주제와 비슷한 궁금증.&lt;/p&gt;
&lt;p&gt;리액트에서는 현재 접속해있는 페이지를 판별하는 방법에 대해서이다.
예를 들어 현재 접속한 페이지와 일치하면 class에 &lt;code class=&quot;language-text&quot;&gt;isMatched&lt;/code&gt;를 붙여서 하이라이트 스타일을 주는 상황을 생각해보자.
vue로 구현한다면 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;router-link :to={name : &amp;quot;Home&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;Home&amp;#39;}&amp;quot;&amp;gt;
    Home
  &amp;lt;/router-link&amp;gt;
  &amp;lt;router-link :to={name : &amp;quot;About&amp;quot;} class=&amp;quot;{ matched : $route.name === &amp;#39;About&amp;#39;}&amp;quot;&amp;gt;
    About
  &amp;lt;/router-link&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실상 스크립트 코드를 하나도 작성하지 않고 template 레벨에서만 현재 라우트 일치 여부를 판별해낼 수 있다.&lt;/p&gt;
&lt;p&gt;이걸 react 로 작성해본다면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Header() {
  const { pathname: currentPath } = useLocation()
  const isMatch = (path: string) =&amp;gt; {
    if (currentPath === path) return &amp;quot;matched&amp;quot;
  }
  return (
    &amp;lt;Nav&amp;gt;
      &amp;lt;Link to=&amp;quot;/&amp;quot; className={currentPath === &amp;quot;/&amp;quot; ? &amp;quot;matched&amp;quot; : &amp;quot;&amp;quot;}&amp;gt;
        Home
      &amp;lt;/Link&amp;gt;
      &amp;lt;Link to=&amp;quot;/about&amp;quot; className={isMatch(&amp;quot;/about&amp;quot;)}&amp;gt;
        About
      &amp;lt;/Link&amp;gt;
    &amp;lt;/Nav&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-text&quot;&gt;useLocation&lt;/code&gt;훅을 통해서 현재의 &lt;code class=&quot;language-text&quot;&gt;pathname&lt;/code&gt;을 한번 뽑아와야하며, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;에서도 클래스를 동적으로 바인딩 할 때도 삼항연산자로 판별하거나, 코드를 줄이려면 &lt;code class=&quot;language-text&quot;&gt;isMatch&lt;/code&gt;함수를 하나 선언해서 인자로 현재 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;To&lt;/code&gt; 값을 그대로 넣어줘야 한다(물론 이건 vue도 마찬가지다).&lt;/p&gt;
&lt;p&gt;vue는 template 레벨에서 &lt;code class=&quot;language-text&quot;&gt;$route.name&lt;/code&gt; 으로 현재 라우트 정보를 한방에 가져올 수 있고, class-binding을 할 때에도 &lt;code class=&quot;language-text&quot;&gt;:class={isMatched : someValue}&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;someValue&lt;/code&gt;값이 true면 곧바로 클래스 이름으로 붙일 수 있어 편리하다.&lt;/p&gt;
&lt;p&gt;vue는 &lt;code class=&quot;language-text&quot;&gt;너한테-이런게-필요할거-같았어&lt;/code&gt; 기능(함수)들이 미리 제공되어있는 반면에 react는 &lt;code class=&quot;language-text&quot;&gt;너가-직접-구현하렴&lt;/code&gt;같은 느낌이다.&lt;br&gt;
react는 기능에 대한 부품들만 던져준다면, vue는 그 부품으로 조립까지 해주는 느낌이랄까? 각 라이브러리가 추구하는 방향성의 차이를 알 수 있는 대목이다.&lt;/p&gt;
&lt;p&gt;각자 장단점이 있겠지만, 나 같이 vue를 먼저 익히고 난 뒤에 react에서는 그 기능을 어떻게 구현해야 하는지 찾아보는 입장에서는 조금 답답함이 느껴지는 것도 사실이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[vue-router를 통한 페이지간 state 전달]]></title><description><![CDATA[2023-04-24에 작성된 원문을 수정한 버전입니다 페이지에 state를 전달하는 방법 react에서는 페이지 이동 시 state를 전달하기 위해서는 에서  컴포넌트 또는  훅을 통해 전달이 가능하다. 반면에 vue…]]></description><link>https://juheon.dev/vue/230629-vue-router-state/</link><guid isPermaLink="false">https://juheon.dev/vue/230629-vue-router-state/</guid><pubDate>Thu, 29 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-24에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/227&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;페이지에 state를 전달하는 방법&lt;/h2&gt;
&lt;p&gt;react에서는 페이지 이동 시 state를 전달하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;Link&gt;&lt;/code&gt; 컴포넌트 또는 &lt;code class=&quot;language-text&quot;&gt;useNaviate()&lt;/code&gt; 훅을 통해 전달이 가능하다.&lt;br&gt;
반면에 vue에서는 직접적인 전달 방법이 존재하지 않아 개발자 자체적으로 방법을 찾아야 했다. 생각해볼 수 있는 방법으로는&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;vuex&lt;/code&gt;와 같은 전역상태 저장소에 넣어두고 꺼내쓰기&lt;br&gt;
=&gt; 일회용 데이터를 위해서 전역상태에 임시 데이터를 넣고 싶지는 않았다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;router.push()&lt;/code&gt;를 하는 코드 직후에 &lt;code class=&quot;language-text&quot;&gt;window.pushState(state)&lt;/code&gt;를 추가해서 페이지가 이동되면 꺼내쓴다&lt;br&gt;
=&gt; 그나마 현실적인 방법이다. 다만 history를 두번으로 push하기 때문에 똑같은 페이지가 히스토리에 스택에 두번 들어가게 된다.&lt;/li&gt;
&lt;li&gt;이동하려는 URL에 쿼리스트링으로 데이터 값을 담아서 전달 하기&lt;br&gt;
=&gt; URL이 괜히 길어지는데다가, 보안상 민감한 데이터는 쿼리스트링에 담기 조심스럽다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이런 불편함 때문인지 vue git의 rfc에도 글이 몇 개 올라와 있었고, 드디어 2022년 7월에 &lt;code class=&quot;language-text&quot;&gt;vue-router@4.1.0&lt;/code&gt;버전에서 정식 기능으로 추가되었다(&lt;a href=&quot;https://github.com/vuejs/router/releases/tag/v4.1.0&quot;&gt;링크&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;방법은 간단하다. router에 params를 넣는 방식처럼 state도 객체 형태로 적어주기만 하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.push({name &amp;#39;NextPage&amp;#39;, state : { isDetailsOpen : true }})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;다만 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt;값을 &lt;code class=&quot;language-text&quot;&gt;useRoute()&lt;/code&gt;에서 뽑아내는 게 아니라, &lt;code class=&quot;language-text&quot;&gt;windiw.history.state&lt;/code&gt;에서 직접 꺼내야한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { isDetailsOpen } = window.history?.state || false&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사실 정식기능으로 추가되었다고는 하더라도 &lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt;객체의 state 힘을 빌리는 정도에 불과하기 때문에 위에서 언급한 임시 해결방법 2번과 거의 유사하다고 볼 수 있다. 또한 이 방법을 사용한다고 하더라도 보안에 민감한 데이터를 전달하기엔 역시나 찝찝한 구석이 있다. 그냥 다음 페이지에의 상태(모달 오픈 여부 등)만 전달하는 데 사용할 수 있을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[router-view 에서 DOM을 찾지 못하는 문제]]></title><description><![CDATA[2023-04-04에 작성된 원문을 수정한 버전입니다 router-view안에 있는 DOM은 왜 못 찾지? vue로 프론트엔드 개발을 하던 도중,  에서 안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class…]]></description><link>https://juheon.dev/vue/230628-router-view-find-dom/</link><guid isPermaLink="false">https://juheon.dev/vue/230628-router-view-find-dom/</guid><pubDate>Wed, 28 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-04-04에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/225&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;router-view안에 있는 DOM은 왜 못 찾지?&lt;/h2&gt;
&lt;p&gt;vue로 프론트엔드 개발을 하던 도중, &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;안에 들어있는 특정 DOM에 접근해야 할 일이 생겼다(정확히 말하자면 태그에 특정 class가 존재 유무를 확인해야 했다).&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;document.querySelector(&apos;.특정클래스&apos;)&lt;/code&gt;함수를 호출하여 해당 DOM에 접근하려고 시도했는데 결과는 예상과 달리 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt;로 반환되었다. (파일 구조는 아래와 같이 구성되어있다.)&lt;/p&gt;
&lt;h4&gt;NavBar.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;nav&amp;gt;
    &amp;lt;router-link :to=&amp;quot;{ name: &amp;#39;Home&amp;#39; }&amp;quot;&amp;gt;Home&amp;lt;/router-link&amp;gt;
  &amp;lt;/nav&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;Home.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;h1 class=&amp;quot;home&amp;quot;&amp;gt;This is home&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;NavBar /&amp;gt;
  &amp;lt;router-view /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
...
export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

      console.log(homeEl); // not found
      console.log(navEl); // found
    });
  },
};
&amp;lt;/script&amp;gt;

&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;내부에 있는 DOM요소(&apos;home&apos; 클래스)에 접근하는 건데 왜 못 찾는 걸까? 혹시나 하는 마음에 똑같이 글로벌 범위로 사용되는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;를 찾아보았을 때는 잘 찾고 있었다.&lt;/p&gt;
&lt;p&gt;내 경험상 vue에서 특정 DOM을 찾지 못하는 문제에 부딪혔을 때는 일단 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 딜레이를 걸어서 찾으면 해결되는 경우가 많았다. 그래서 일단 아래와 같이 코드를 수정해보았다.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;script&amp;gt;
export default {
  setup() {
    onMounted(() =&amp;gt; {
      setTimeout(()=&amp;gt;{
        const homeEl = document.querySelector(&amp;quot;.home&amp;quot;);
        const navEl = document.querySelector(&amp;quot;nav&amp;quot;);

        console.log(homeEl); // found
        console.log(navEl); // found
      },1000)
    });
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아니나 다를까, 시간을 두고 DOM을 찾았더니 성공하였다. 우선 가장 무식한(비효율적인) 방법으로는 문제를 해결하기는 했다.&lt;/p&gt;
&lt;p&gt;문제의 원인은 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt;가 &lt;strong&gt;mount 될 때까지 미세하게나마 시간이 소요되기 때문&lt;/strong&gt;이었다.&lt;br&gt;
따라서 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;onMounted()&lt;/code&gt;가 호출되는 시점에는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;Home.vue&lt;/code&gt; 는 아직 mount되기 이전이었기 때문에 DOM에 접근할 수 없었던 것이다. 그에 반해 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&gt;&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부에 있지 않고 &lt;code class=&quot;language-text&quot;&gt;App.vue&lt;/code&gt;에 독립적으로 존재하기 때문에 mount되는 시간이 훨씬 짧아 접근이 가능하다.&lt;/p&gt;
&lt;h2&gt;해결책은 router.isReady()&lt;/h2&gt;
&lt;p&gt;개발할 때는 워낙 빠릿하게 작동해서 눈치채기는 어렵지만 사실 router가 mount되기까지의 딜레이는 결코 무시할 수 없는 수준으로 꽤 긴 시간이다. 그렇다면 앞으로도 계속 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;으로 강제 딜레이를 넣어줘야 하는 걸까? 당연히 아니다.&lt;code class=&quot;language-text&quot;&gt;vue-router&lt;/code&gt;에서는 이런 문제가 발생할 줄 알고 미리 &lt;code class=&quot;language-text&quot;&gt;router.isReady()&lt;/code&gt;라는 비동기 함수를 만들어 놓았다.&lt;a href=&quot;https://router.vuejs.org/guide/migration/#replaced-onready-with-isready&quot;&gt;공식문서&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;문제를 해결한 코드를 먼저 보자.&lt;/p&gt;
&lt;h4&gt;App.vue&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export default {
  components: { NavBar },
  setup() {
    onMounted(async () =&amp;gt; {
      await router.isReady() // Added!
      const homeEl = document.querySelector(&amp;quot;.home&amp;quot;)
      const navEl = document.querySelector(&amp;quot;nav&amp;quot;)

      console.log(homeEl) // found
      console.log(navEl) // found
    })
  },
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;코드는 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 찾기 전에 &lt;code class=&quot;language-text&quot;&gt;await router.isReady()&lt;/code&gt; 딱 한 줄만 추가했다.&lt;/p&gt;
&lt;p&gt;이 함수는 쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;router-view&lt;/code&gt; 내부의 파일들이 DOM으로 mount 될 때 까지 기다려주는 역할이다. 모두 mount가 완료되었다면 resolve 해줌으로써 &lt;code class=&quot;language-text&quot;&gt;querySelector&lt;/code&gt;로 접근할 수 있게 된다.&lt;/p&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-router-isready-tlqd83?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-router-isReady&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[vue-chart에서 비동기 통신 후 화면에 반영하기]]></title><description><![CDATA[2023-03-09에 작성된 원문을 수정한 버전입니다 문제상황 vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue…]]></description><link>https://juheon.dev/vue/230627-vue-async-data/</link><guid isPermaLink="false">https://juheon.dev/vue/230627-vue-async-data/</guid><pubDate>Tue, 27 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/221&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;문제상황&lt;/h2&gt;
&lt;p&gt;vue3 환경에서 chart.js 라이브러리를 사용하여 차트 데이터를 화면에 그리려고 한다. 그냥 바닐라 JS를 활용할 수도 있겠지만, 더 편리한 방법으로는 vue 기반으로 래핑해놓은 &lt;a href=&quot;https://vue-chart-3.netlify.app/&quot;&gt;vue-chart-3&lt;/a&gt;를 활용하려고 한다. 그래서 공식문서 &lt;a href=&quot;https://codesandbox.io/s/demo-vue-chart-3-ugynm?from-embed=&amp;#x26;file=/src/App.vue&quot;&gt;데모 페이지&lt;/a&gt;에 나와있는 대로 따라하려고 하니 문제가 하나 생겼다.&lt;/p&gt;
&lt;p&gt;내가 화면에 보여줄 데이터는 서버와 비동기 통신을 통해서 받아온 다음에 그려야 한다. 그런데 데모 소스코드 상에서는 데이터가 아래와 같이 그냥 하드코딩 되어 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    // &amp;lt;template&amp;gt;
    &amp;lt;DoughnutChart :chartData=&amp;quot;testData&amp;quot; /&amp;gt;
    ...

    // &amp;lt;script&amp;gt;
    const dataValues = ref([30, 40, 60, 70, 5]);
    const dataLabels = ref([&amp;quot;Paris&amp;quot;, &amp;quot;Nîmes&amp;quot;, &amp;quot;Toulon&amp;quot;, &amp;quot;Perpignan&amp;quot;, &amp;quot;Autre&amp;quot;]);
    const testData =  {
      labels: dataLabels.value,
      datasets: [
        {
          data: dataValues.value,
        },
      ],
    };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제 chart.js를 활용하는 사례에서는 데이터를 하드코딩해서 넣는 경우보단, 비동기로 넣는 경우가 더 일반적이다. 하지만 chart.js는 차트를 그리는 데 필요한 데이터를 받으면 곧바로 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;canvas&gt;&lt;/code&gt;로 그려버리기 때문에, 그 이후에는 비동기로 데이터가 도착한다고 한들 차트가 변하지 않는다는 문제가 있다.&lt;/p&gt;
&lt;p&gt;예를 들어 아래 코드와 같이 비동기 통신을 가장한 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;함수가 &lt;code class=&quot;language-text&quot;&gt;onMounted&lt;/code&gt;에서 실행된다 하더라도 차트는 그려지지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const dataValues = ref([])
const dataLabels = ref([])

onMounted(() =&amp;gt; {
  fetchData().then(res =&amp;gt; {
    dataValues.value = res.map(item =&amp;gt; item.data)
    dataLabels.value = res.map(item =&amp;gt; item.label)
  })
})

const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

const fetchData = () =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      resolve([
        { data: 10, label: &amp;quot;a&amp;quot; },
        { data: 30, label: &amp;quot;b&amp;quot; },
        { data: 15, label: &amp;quot;c&amp;quot; },
        { data: 5, label: &amp;quot;d&amp;quot; },
        { data: 20, label: &amp;quot;e&amp;quot; },
      ])
    }, 1000)
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;이를 해결하기 위해서는 차트의 props에 해당하는 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 주입시켜야 한다. 그러면 &lt;code class=&quot;language-text&quot;&gt;fetchData&lt;/code&gt;에서 1초 뒤에 값을 받아오고 나서 &lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;도 받아온 값으로 업데이트된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;testData&lt;/code&gt;에 반응성을 부여하려면 &lt;code class=&quot;language-text&quot;&gt;computed&lt;/code&gt; 를 사용하여 감싸주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const testData = {
  labels: dataLabels.value,
  datasets: [
    {
      data: dataValues.value,
    },
  ],
}

// After
const testData = computed(() =&amp;gt; {
  return {
    labels: dataLabels.value,
    datasets: [
      {
        data: dataValues.value,
      },
    ],
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue-chart-3nbvlh?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;vue-chart&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Vue 에서 스크롤 위치 저장]]></title><description><![CDATA[2023-03-09 에 작성된 원문을 수정한 버전입니다 SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.…]]></description><link>https://juheon.dev/vue/230626-save-scroll/</link><guid isPermaLink="false">https://juheon.dev/vue/230626-save-scroll/</guid><pubDate>Mon, 26 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-03-09 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/220&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPA(Single Page Application)에서 이전 페이지의 스크롤 위치를 기억해두었다가 재방문 했을 때 그 자리에 위치해야 하는 경우가 있다. 이를 구현하기 위한 방법을 알아보자.&lt;/p&gt;
&lt;h2&gt;1. vue-router의 savedPosition 활용&lt;/h2&gt;
&lt;p&gt;vue-router의 &lt;code class=&quot;language-text&quot;&gt;createRouter()&lt;/code&gt;함수의 인자로 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수를 넣을 수 있다.&lt;/p&gt;
&lt;p&gt;이 함수에서 return 해주는 값에 따라서 페이지를 이동할 때마다 해당 값만큼 스크롤이 이동하게 된다. (쉽게 얘기하면 &lt;code class=&quot;language-text&quot;&gt;window.scrollTo&lt;/code&gt; 함수가 페이지 이동할 때마다 호출된다고 생각하면 된다.)&lt;br&gt;
예를 들어 아래 코드와 같이 &lt;code class=&quot;language-text&quot;&gt;{top : 100}&lt;/code&gt;을 리턴하다면 매 페이지 이동 시 수직 스크롤이 100px 내려져 있는 상태가 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior() {
    return { top: 100 }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;그렇다면 스크롤 위치를 저장하고 해당 위치로 돌아가려면 어떻게 해야할까?&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수는 아래와 같이 인자로 &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;savedPosistion&lt;/code&gt; 이렇게 3개를 받는다. &lt;code class=&quot;language-text&quot;&gt;to&lt;/code&gt;는 다음으로 이동할 페이지의 정보, &lt;code class=&quot;language-text&quot;&gt;from&lt;/code&gt;은 이전에 어느 페이지로부터 왔는지에 대한 정보이다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;에 우리가 원하는 정보가 들어있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,

  scrollBehavior(to, from, savedPosition) {
    // 기존 위치 존재하면 그 위치 반환
    if (savedPosition) {
      return savedPosition
    }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
영상으로 이 값의 정체를 직접 확인해보자.
&lt;br /&gt;
&lt;br /&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737988215/blog/assets/save-scroll-2_sgqote.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt;을 찍어보면 그 정체는 &lt;code class=&quot;language-text&quot;&gt;{top: number,left : number}&lt;/code&gt;형태라는 걸 알 수 있다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;savedPosition&lt;/code&gt; 값은 사용자가 &lt;strong&gt;뒤로가기/앞으로가기&lt;/strong&gt; 를 누를 때만 값이 활성화되고 vue-router를 활용하여 페이지 이동할 때는 값이 null값으로 반환되어서 위치를 저장할 수 없다. 만약 뒤로가기/앞으로가기 누를 때 뿐만 아니라 모든 경우에 대해서 스크롤 위치를 저장하기 위해서는 아래 2번 방법을 사용해야한다.&lt;/p&gt;
&lt;h2&gt;2. Web Storage(sessionStorage) 활용&lt;/h2&gt;
&lt;p&gt;두 번째 방법은 Web Storage를 활용하여 스크롤 위치를 동적으로 기억해 놓는 것이다. Web Storage는 크게 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;가 있는데 차이는 브라우저를 닫았을 때 데이터가 날리느냐 마냐의 차이이다. 보통 웹사이트의 특정 기간동안 &apos;로그인상태 유지&apos; 기능이 활성화한다면 브라우저가 꺼져도 유지되야 하므로 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;에 저장하는게 적합하다. 스크롤 위치 정보의 경우 브라우저를 껐다가 다시 실행했을 경우에는 초기화 시키는게 적합하므로 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 저장하기로 했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;페이지를 이동할 때마다 현재 페이지의 스크롤 위치를 저장해두어야 한다.
따라서 vue-router의 &lt;code class=&quot;language-text&quot;&gt;beforeEach()&lt;/code&gt;함수에서 떠나는 페이지(from)의 스크롤 위치인 &lt;code class=&quot;language-text&quot;&gt;window.scrollY&lt;/code&gt; 값을 &lt;code class=&quot;language-text&quot;&gt;sessionStorage&lt;/code&gt;에 key-value 형태로 저장한다. key값은 현재 페이지의 이름, value값은 스크롤 위치 값이다.&lt;/p&gt;
&lt;p&gt;이때 Web Storage에는 string형태의 데이터만 저장할 수 있으므로 저장할 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.stringify()&lt;/code&gt;로, 값을 꺼낼 때는 &lt;code class=&quot;language-text&quot;&gt;JSON.parse()&lt;/code&gt;함수를 거쳐야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;router.beforeEach((_, from) =&amp;gt; {
  const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))

  const key = from.name
  if (key) {
    const scrollObj = { [key]: window.scrollY }
    window.sessionStorage.setItem(
      &amp;quot;scrollInfo&amp;quot;,
      JSON.stringify({ ...prevInfo, ...scrollObj })
    )
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 페이지에 진입하면 &lt;code class=&quot;language-text&quot;&gt;scrollInfo&lt;/code&gt;에서 이전에 저장되어 있는 스크롤 위치가 있는지 확인한 후, 있다면 그 위치로 이동시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to) {
    const prevInfo = JSON.parse(window.sessionStorage.getItem(&amp;quot;scrollInfo&amp;quot;))
    if (!prevInfo) return
    const savedPosition = prevInfo[to.name] || 0

    return { top: savedPosition }
  },
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br /&gt;
&lt;p&gt;콘솔로 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;를 찍어보면 다음과 아래와 같이 나온다.&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737988215/blog/assets/save-scroll-1_ucdmmx.gif&quot; height=&quot;600&quot;&gt;
&lt;/div&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;prevInfo&lt;/code&gt;에 저장된 value값을 받아서 &lt;code class=&quot;language-text&quot;&gt;scrollBehavior&lt;/code&gt;함수의 top값으로 리턴해주게 되면 이전에 저장되었던 스크롤 위치로 복귀할 수 있게 되는 원리이다.&lt;/p&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;(&lt;a href=&quot;https://in0407.tistory.com/11&quot;&gt;https://in0407.tistory.com/11&lt;/a&gt;)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로젝트 회고]]></title><description><![CDATA[2023-02-18에 작성된 원문을 수정한 버전입니다 1. 프론트는 항상 맨 먼저 쳐맞는다. '어 이거 안되는데요? 프론트에서 확인 좀 해주세요' 이런 말을 프로젝트하면서 일주일에 1…]]></description><link>https://juheon.dev/essay/230625-project-review/</link><guid isPermaLink="false">https://juheon.dev/essay/230625-project-review/</guid><pubDate>Sun, 25 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2023-02-18에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/219&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;1. 프론트는 항상 맨 먼저 쳐맞는다.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&apos;어 이거 안되는데요? 프론트에서 확인 좀 해주세요&apos;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이런 말을 프로젝트하면서 일주일에 10번도 넘게 들었다. 에러의 원인이 차라리 내(프론트) 문제라면 오히려 낫다. 하지만 백엔드 문제, 혹은 네이티브 문제인 경우도 있다. 하지만 사용자에게 가장 앞단에 보이는 부분은 결국 프론트이다. 일단 누구의 문제이든간에 내가 먼저 버그 issue를 접수받고나서 어느 파트의 문제인지 파악한 다음, 다시 그 파트의 개발자에게 해당 이슈를 토스해야 하는 입장이다.&lt;/p&gt;
&lt;p&gt;프론트 개발자 입장에서는 좀 억울하지만 어쩔 수 없는 숙명이다. 사용자는 백엔드가 어떻건, 네이티브가 어떻건은 신경쓰지 않는다. 지금 당장 자신에게 보이는 화면이 에러로 나온다면 일단 프론트 문제처럼 비춰질 수밖에 없다.그래서 나는 이 상황에 대해 &apos;제 잘못이 아닌데요&apos;라고 책임회피를 하려기보다는 그냥 침착하게 &apos;파악해보고 알려드리겠습니다&apos; 라고 대응하는게 더 현명한 방법이라고 결론내렸다.&lt;/p&gt;
&lt;h3&gt;2. 에러처리(fallback)가 성가시지만 정말 중요하다.&lt;/h3&gt;
&lt;p&gt;백엔드 API에서 어떤 데이터를 받아온다고 하자.&lt;br&gt;
백엔드에서 보내주는 형식은 &lt;code class=&quot;language-text&quot;&gt;res.data.result.list&lt;/code&gt; 라는 구조안에 내가 원하는 데이터가 들어있다. 총 4겹으로 감싸져 있는 구조이다. 여기서 중요한 점은, 한 겹을 벗길 때마다 반드시 유효성 검증을 해줘야 한다는 점이다. 하지만 예전의 나같은 경우에는 단순무식하게&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Before
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;);
const myList = res.data.result.list;
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런 식으로 한 번에 꺼내오려고 했을 것이다. 하지만 위 코드는 서버가 100% 정상 작동할때만 보장되는 코드이다. 만약 서버가 잠시 에러가 났다거나, 아니면 데이터 구조가 바뀌게 되면 위 코드는 여지없이 에러를 내뿜고 말 것이다.&lt;/p&gt;
&lt;p&gt;예전의 나라면 &lt;code class=&quot;language-text&quot;&gt;그런-상황이-프론트개발자-잘못은-아닌거-같은데요&lt;/code&gt;라고 했겠지만, 지금은 생각이 바뀌었다. 설령 백엔드 단에서 에러가 발생했다 할지라도 그 문제 상황이 프론트(사용자가 보는 화면)단까지 역류해서는 안된다. 최소한 사용자가 보기에 에러가 발생해서 아무것도 없는 흰 화면만 보여주기보다는, &apos;에러가 발생했습니다&apos;라는 텍스트 한 줄이라도 적혀있는 페이지로 리다이렉트 시켜주는게 프론트 개발자가 해야하는 최소한의 예의이다.&lt;/p&gt;
&lt;p&gt;가장 훌륭한 방법은 백엔드에서 에러가 발생하여 데이터가 예상과는 다르게 오더라도 이를 잘 핸들링 할 수 있어야 한다. 다시 위의 예시를 들자면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// After
const res = await axios.get(&amp;quot;/someApiAddress&amp;quot;).catch(fail=&amp;gt;handleFail())
if (res) {
  const myList = res?.data?.result?.list
  if(myList){
    ...
  } else{
    handleFail();
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 데이터의 유효성 검증을 반드시 거쳐야 한다. 처음에는 이런 식의 코딩이 비효율적이고 미관상으로도 보기에 좋지 않다고 생각했었는데 ,이건 아무래도 내가 이전까지 코딩을 하던 습관이 주로 Problem solving에 머물러 있었기 때문이라고 생각한다.&lt;/p&gt;
&lt;p&gt;PS에서의 코딩을 할 때는 서버랑 통신하지 않고 데이터의 구조를 내가 직접 지정하다보니, 데이터의 유효성을 굳이 검증할 필요를 느끼지 못했다. 하지만 웹개발에서 프론트-백엔드가 맞물리는 작업에서는 반대쪽 진영에서 데이터를 어떻게 보낼 것인지에 대해서는 항상 보수적이고 안정적인 방향으로 코드를 짜야한다.&lt;/p&gt;
&lt;h3&gt;3. 사용자가 시도할 만한 모든 행동을 테스트하라.&lt;/h3&gt;
&lt;p&gt;휴대폰 본인인증을 위한 기능을 추가한다고 생각해보자.&lt;br&gt;
사용자가 문자를 받으면 번호를 입력하고 인증 버튼을 눌러주면 참 좋겠지만, 안타깝게도 사용자는 내가 의도한대로만 행동하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;첫 번째, 사용자가 전화번호를 잘못 입력했을 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황은 그나마 낫다. 문자를 보내기 전에 서버에서 유효하지 않은 정보라고 에러를 보내주기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;두 번째, 인증번호를 잘못 입력할 수도 있다.&lt;/strong&gt;&lt;br&gt;
이 상황도 충분히 일어날 수 있으며 서버에서도 에러를 띄워주기 때문에 처리하기엔 어렵지 않다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 세 번째, 사용자가 &apos;인증 요청&apos;버튼을 광클한다.&lt;/strong&gt;&lt;br&gt;
휴대폰 인증의 경우, 각 요청마다 고유한 인증 ID값이 부여되기 때문에 3번 클릭을 하면 3개의 별개의 인증 ID가 부여되고 3개의 문자가 전송되며 당연히 사용자에게 전송되는 인증번호도 다르다. 그리고 인증과정은 대개 가장 마지막 요청을 기준으로만 유효하기 때문에 사용자는 세 번째 인증번호를 입력해야 하는 상황이다.&lt;/p&gt;
&lt;p&gt;여기서 성질 급한 사용자는 세 번째 문자가 오기 전에 첫 번째 인증번호 문자를 입력하고 확인 버튼을 누를 것이다. 인증 결과는 당연히 실패. 당황한 사용자는 세 번째 문자를 기다리는게 아닌, &apos;인증 재요청&apos;버튼을 누를 것이다. 네 번째 문자 요청인 셈이다. 그 순간 사용자에게 두 번째, 혹은 세 번째 인증문자가 도착하고 사용자는 또 다시 인증에 실패한다. 그리고 사용자는 영문도 모르고 이 웹페이지를 만든 개발자(아마 나)를 욕하고 있을 것이다.&lt;/p&gt;
&lt;p&gt;누구의 잘못일까? 버튼을 세번 광클한 사용자인가, 그런 행동도 예측 못한 개발자인가. 프로젝트가 진행될수록 느끼는 점은 개발자가 더 신경써야 한다는 것이다. 사용자가 왜 그런 터무니없는 행동을 할까에 대해 원망을 하기 보다, 내가 한발 먼저 터무니없는 행동을 막아야 한다. 이 문제의 경우에는 &lt;code class=&quot;language-text&quot;&gt;debounce&lt;/code&gt;함수나 &lt;code class=&quot;language-text&quot;&gt;throttle&lt;/code&gt;함수를 이용하여 단 하나의 요청만 전송되도록 처리되도록 해야할 것이다.&lt;/p&gt;
&lt;p&gt;이 외에도 시간제한(3분)을 지나서 확인 버튼을 누른다거나 하는 등 내가 의도한 베스트 시나리오에서 벗어나는 행동을 얼마든지 있을 수 있다. 단순 베스트 시나리오만 처리한다면 코드를 단 30줄만 작성하면 된다. 하지만 위에서 언급한 예외적인 사용자의 행동까지 처리하기 위해서는 거의 300줄을 써야 한다. 예전에는 이런 에러 상황 처리로 인해 코드 길이가 길어지는게 현타가 오기도 했는데, 이제는 받아들이기로 했다. 그것이...프론트의 숙명이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추후에 나는 이 일을 계기로 TDD,테스트코드의 중요성을 깨닫게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4. 안드로이드와 iOS를 동시에 고려해야한다&lt;/h3&gt;
&lt;p&gt;웹뷰 기반의 하이브리드 앱을 개발하면 프론트 개발자는 반드시 안드로이드(AOS)와 iOS를 동시에 고려해야한다. 대부분의 기능은 하나의 코드로도 양쪽에서 잘 작동하지만, 일부 기능들은 AOS에서만 작동한다거나, 반대로 iOS에서만 작동하는 기능들도 있다.&lt;/p&gt;
&lt;p&gt;이런 경우에는 어쩔 수 없이 if문을 이용하여 사용자의 기기를 식별한 다음 분기처리 해주어야 한다. 나는 아이폰을 사용하기 때문에 앱을 만들면서 iOS에서는 정상 작동을 잘 확인하였으나 안드로이드(사실상 갤럭시)에서는 동작이 다르거나 아예 실행되지 않는 케이스도 있었다.&lt;/p&gt;
&lt;p&gt;예를 들어 Javascript web share API의 경우, ios에서는 &lt;code class=&quot;language-text&quot;&gt;window.navigator.share()&lt;/code&gt; 함수만 호출하면 되는 반면에, AOS에서는 별도의 네이티브 함수를 호출해야만 공유하기 기능을 활용할 수 있다. 게다가 javascript의 문제뿐만이 아니라 css에서도 레이아웃이 다르게 보이는 경우가 있다.&lt;br&gt;
(예를 들어 safari에서는 border-radius가 들어간 element에는 outline 속성이 먹지 않는 문제)&lt;/p&gt;
&lt;p&gt;그래서 개발할 때는 항상 chrome창과 safari창을 동시에 켜놓고 작업하면서 두 브라우저에서 모두 잘 나타는지 확인해야했다.&lt;/p&gt;
&lt;h3&gt;5. 데이터 가공은 가급적 백엔드에 맡겨라&lt;/h3&gt;
&lt;p&gt;이 문제의 원인 역시 PS에서의 습관이 묻어있었기 때문이다.&lt;/p&gt;
&lt;p&gt;PS에서는 문제를 풀 때 데이터를 정렬하는 일은 정말 비일비재하므로 웹개발에서 나도 모르게 sort()함수를 하고 있는 나 자신을 발견한다. 하지만 기본적인 시간순 정렬이나, 기간조회 같은 기능들은 프론트가 직접 필터링하기보다는 백엔드 API를 통해서 값을 받아오는게 낫다. 나는 백엔드 통신을 최소화해야만 극한의 최적화를 이룰 수 있다는 강박이 있었는데, 오히려 스크립트가 연산하는 작업이 더 큰 오버헤드 일 수도 있다.&lt;/p&gt;
&lt;p&gt;어차피 백엔드는 db에서 값을 꺼내오는 과정이 포함되어있고, 백엔드 자체적으로 가공을 거친 후 보내준다 해도 그렇게 큰 시간 손실은 아니다. 상황에 따라서 데이터 가공을 프론트가 해야할 지 백엔드가 해야할 지를 잘 정해야 한다.&lt;/p&gt;
&lt;h3&gt;6. 어디까지 나의 &apos;주관적 판단&apos;을 개입시켜야 하는가&lt;/h3&gt;
&lt;p&gt;내가 프론트 개발을 할 때는 보통 와이어프레임 형태로 되어있는 기획서와 디자이너가 퍼블리싱한 문서를 기반으로 작업한다. 이 둘을 참고해가며 개발하다보면 모호한 부분이 생길 때가 있다. 이를테면 프론트단에서 구현할 수 없는 기능이거나, 왜 필요한 지 알 수 없는 기능이거나 할 때가 있다.&lt;/p&gt;
&lt;p&gt;이런 상황에서 어떻게 대처할 지 난처해진다. 잘못된 것 같아도 기획서를 그대로 따라갈 것인지, 아니면 나의 주관을 개입시켜서 기획서와 다르게 개발을 해야할지 말이다. 나는 전자와 후자의 방법 모두를 시행해보았는데 결론적으로 두 번 모두 태클을 받았다.&lt;/p&gt;
&lt;p&gt;전자의 방법을 따를 경우,
&lt;code class=&quot;language-text&quot;&gt;&apos;기획서가 좀 잘못되더라도 개발하다가 이상하다 느꼈으면 융통성 있게 수정해주세요&apos;&lt;/code&gt;
라는 말을 듣고,&lt;br&gt;
후자의 방법을 따를 경우
&lt;code class=&quot;language-text&quot;&gt;&apos;그냥 기획서에 나와 있는 그대로만 개발해주세요&apos;&lt;/code&gt;
라는 말을 듣는다. 결국에는 정답이 없다. 나의 주관을 정말 &lt;strong&gt;&apos;적절하게&apos;&lt;/strong&gt; 개입시켜야 한다.&lt;/p&gt;
&lt;h3&gt;7. 개발 자체보다, 사람과의 소통이 더 어렵다&lt;/h3&gt;
&lt;p&gt;어쩌면 가장 중요한 교훈이다. 개발은 그냥 하면 된다. 모르면 구글링으로 찾아보기도 하고 버그가 발생하면 될 때까지 부딪히다 보면 된다.&lt;/p&gt;
&lt;p&gt;하지만 사람과의 소통은 그렇지 않다. 검색을 해도 나오지도 않고 계속 부딪힐 수도 없는 문제이다. 똑같은 의도를 전달하더라도, 내가 사용하는 단어에 따라서 상대방의 대답이 달라지기도 한다.&lt;/p&gt;
&lt;p&gt;나는 코드만 잘 짜기만 하면 사람들간의 트러블은 전혀 없을 줄 알았다. 하지만 이번 프로젝트를 통해서 깨닫게 된 점은 결국 프로그램을 만드는 것도 사람, 이용하는 것도 사람이다. 내가 아무리 환상적이게 작동하는 코드를 잘 짜놓았다고 한들 상대방이 납득하지 못한다면 아무 소용없는 일이다.&lt;/p&gt;
&lt;p&gt;내가 중점적으로 신경쓴 점은 &apos;나는 어떤 문제상황을 이렇게 받아 들였고, 이런 방식으로 해결하려고 했다.&apos;를 주장하고,&lt;br&gt;
상대방에게 업무를 요청할 때는 &apos;현재 프론트에 이러이러한 문제가 있는데, 이 부분이 원인인 것 같다. 백엔드에서 다른 방식으로 개선해달라&apos; 방식의 의사소통으로 다듬어가고 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CSS,JS를 이용한 룰렛 구현]]></title><description><![CDATA[2022-11-1…]]></description><link>https://juheon.dev/vue/230624-vue-roulette/</link><guid isPermaLink="false">https://juheon.dev/vue/230624-vue-roulette/</guid><pubDate>Sat, 24 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;2022-11-12 에 작성된 &lt;a href=&quot;https://ps-hjhj97.tistory.com/214&quot;&gt;원문&lt;/a&gt;을 수정한 버전입니다&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;룰렛 이벤트&lt;/h2&gt;
&lt;p&gt;다들 온라인이나 오프라인에서 룰렛(회전판)을 돌려서 나온 상품을 추첨받는 경험 한 번씩 있을 것이다. 현실에서의 룰렛은 공평한 물리법칙에 내 운명을 맡기면 되지만, 웹페이지(프론트엔드)상에서 구현할 때는 룰렛을 어떻게 돌아가게 만들고 어떤 영역을 가리키도록 해야할까? 마침 진행 중인 프로젝트에서 룰렛을 구현해야 했는데 구글링이나 오픈소스에는 내가 원하는 기능이 없어서 직접 구현하게 되었다.&lt;/p&gt;
&lt;h4&gt;요구조건&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;사용자가 버튼을 누르면 백엔드 API가 호출되고 리턴값으로 당첨영역을 받는다. 이 영역의 위치에 따라 회전 각도를 조절해야한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;현실에서 룰렛이 회전하는 것처럼, 처음에는 천천히 돌다가 점점 가속도가 붙어서 빨라지고 마지막에는 느려지다 멈춘다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;구현 방식&lt;/h4&gt;
&lt;p&gt;가장 쉽게 생각해볼 수 있는 방법은 css animation을 활용하여 rotate시키는 방법이다.
아래와 같이 &lt;code class=&quot;language-text&quot;&gt;spin&lt;/code&gt;이라는 keyframs를 정의하고 &lt;code class=&quot;language-text&quot;&gt;rotate(360deg)&lt;/code&gt;를 부여하면 한 element를 한바퀴 돌릴 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;strong&gt;요구조건 1&lt;/strong&gt;에서 언급했다시피 당첨영역, 즉 회전 각도는 고정된 값이 아니라 서버에서 리턴받는 값에 따라서 동적으로 변해야 한다. 그래서 나는 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 css keyframes에 접근하여 rotate각도를 직접 수정할 수 있는지를 찾아보았다. 예를 들어 DOM element의 &lt;code class=&quot;language-text&quot;&gt;backgroundColor&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;fontSize&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;querySelector()&lt;/code&gt;함수를 이용해 접근할 수 있는 것처럼 animation도 그런 작업이 가능한 지 궁금했다.&lt;/p&gt;
&lt;p&gt;결론부터 얘기하자면, 가능은 하지만 방법이 너무 복잡했다.&lt;a href=&quot;https://stackoverflow.com/questions/59573722/how-can-i-set-a-css-keyframes-in-javascript&quot;&gt;(링크)&lt;/a&gt;&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;insertRule()&lt;/code&gt;함수를 이용해서 넣는 방식이었는데 keyframe부분을 직접 문자열로 하드코딩해야하기 때문에 너무 억지인 것 같아서 다른 방법을 찾아보기로 하였다.&lt;/p&gt;
&lt;h4&gt;css var()를 활용한 방식&lt;/h4&gt;
&lt;p&gt;다른 방법으로 생각해낸 건 아래와 같이 css의 var()를 활용해서 :root에서 선언해놓은 변수 값을 keyframes에서 갖다 쓰는 방식이다. root 영역의 값은 &lt;code class=&quot;language-text&quot;&gt;js&lt;/code&gt;단에서 &lt;code class=&quot;language-text&quot;&gt;setProperty()&lt;/code&gt;함수를 활용해서 조작할 수 있기 때문에 이 방식이 더 낫다고 판단하였다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/*roulette.css*/
.roulette_content {
  animation-name: spin;
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(var(--roulette-angle));
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4&gt;룰렛의 파라미터&lt;/h4&gt;
&lt;p&gt;룰렛을 돌리기 전에 결정되어야 할 파라미터가 몇 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;룰렛을 최소 몇 바퀴 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛을 몇 초 동안 돌릴 것인지&lt;/li&gt;
&lt;li&gt;룰렛 안에 채워져 있는 컨텐츠&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 3가지가 채워지고나면 룰렛을 돌릴 수 있게 된다.&lt;/p&gt;
&lt;p&gt;원리는 간단하다. 룰렛의 중심각이 360도이다. 따라서 &lt;code class=&quot;language-text&quot;&gt;360/(영역의 개수)&lt;/code&gt; 를 계산하면 룰렛의 각 영역당 중심각의 크기&lt;code class=&quot;language-text&quot;&gt;(=degPerSection)&lt;/code&gt;를 구할 수 있다.&lt;br&gt;
그리고 당첨된 영역&lt;code class=&quot;language-text&quot;&gt;(=pick)&lt;/code&gt;이 (반시계방향 기준)몇 번째인지 구하여 &lt;code class=&quot;language-text&quot;&gt;degPerSection * pick&lt;/code&gt; 값이 룰렛을 회전시켜야하는 각도 값&lt;code class=&quot;language-text&quot;&gt;(=rouletteAngle)&lt;/code&gt;이 된다.
이 값을 root에 &lt;code class=&quot;language-text&quot;&gt;--roulette-angle&lt;/code&gt;로 저장시키면 &lt;code class=&quot;language-text&quot;&gt;var()&lt;/code&gt;함수를 이용하여 keyframes에서도 이 값을 가져다 쓸 수 있는 방식이다.&lt;/p&gt;
&lt;p&gt;그래서 &lt;code class=&quot;language-text&quot;&gt;startRoulette()&lt;/code&gt;함수를 실행시키면 &lt;code class=&quot;language-text&quot;&gt;rouletteAngle&lt;/code&gt;값이 정해지고 이 값은 다시 :root의 &lt;code class=&quot;language-text&quot;&gt;roulette-angle&lt;/code&gt;으로 채워져서 spin animation이 작동하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const useRoulette = () =&amp;gt; {
  const POINT_ARRAY = [&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;yellow&amp;quot;]
  // 룰렛의 내용, 12시 방향부터 반시계방향
  const MIN_ROTATION = 3
  // 룰렛을 최소 몇 바퀴 돌릴 것인지
  const ROTATION_SECOND = 2
  // 몇 초동안 돌릴 것인지

  const numberOfSection = POINT_ARRAY.length
  // 룰렛에 적힌 영역의 개수
  const degPerSection = 360 / numberOfSection
  // 하나의 섹션당 각도가 몇 도인지 계산함.
  let pickedSection
  // 당첨된 영역

  const setRouletteProperty = () =&amp;gt; {
    const pick = Math.floor(Math.random() * numberOfSection)
    // [0, section - 1]범위에 랜덤한 인덱스를 뽑음, 서버에서 영역을 정해준다면 필요없음
    pickedSection = POINT_ARRAY[pick]
    // 당첨된 영역 값 대입
    const rouletteAngle = 360 * MIN_ROTATION + degPerSection * pick
    // 최소 MIN_ROTATION만큼은 돌고난 후에, pick 영역을 가르키도록 함

    document.documentElement.style.setProperty(
      &amp;quot;--roulette-angle&amp;quot;,
      rouletteAngle + &amp;quot;deg&amp;quot;
    )
    //css의 root에 선언해놓은 변수에 값 할당함.

    const rouletteEl = document.querySelector(&amp;quot;.roulette_content&amp;quot;)
    rouletteEl.style.animationDuration = `${ROTATION_SECOND * 1000}ms`
    // 애니메이션(룰렛회전) 지속시간 적용
  }

  const startRoulette = () =&amp;gt; {
    setRouletteProperty()

    const toId = setTimeout(() =&amp;gt; {
      alert(pickedSection)
      clearTimeout(toId)
    }, ROTATION_SECOND * 1000)
  }
  return {
    startRoulette,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* roulette.css */
.roulette_content {
  animation-name: spin;
  animation-timing-function: ease-in-out;
  animation-fill-mode: forwards;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(var(--roulette-angle));
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;구현&lt;/h2&gt;
&lt;iframe src=&quot;https://codesandbox.io/embed/vue3-roulette-cu4617?fontsize=14&amp;hidenavigation=1&amp;theme=dark&quot;
     style=&quot;width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;&quot;
     title=&quot;Vue3-roulette&quot;
     allow=&quot;accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking&quot;
     sandbox=&quot;allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts&quot;
   &gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[블로그 꾸미기 일지]]></title><description><![CDATA[블로그 템플릿 블로그를 이제 막 개설해서인지 아직은  프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium…]]></description><link>https://juheon.dev/etc/230622-blog-decoration/</link><guid isPermaLink="false">https://juheon.dev/etc/230622-blog-decoration/</guid><pubDate>Thu, 22 Jun 2023 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 템플릿&lt;/h2&gt;
&lt;p&gt;블로그를 이제 막 개설해서인지 아직은 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt; 프레임워크가 어떻게 동작하는지 파악하고 있는 단계다. 그러면서도 블로그 꾸미기는 빼먹을 수 없는데, 이는 역시 내가 프론트엔드 개발자이기도 하고 velog나 medium 같은 플랫폼보다 커스텀할 수 있는 폭이 넓은 gatsby를 기술 블로그로 선택한 이상 꾸미기는 선택이 아닌 거의 필수라고 생각한다.&lt;/p&gt;
&lt;p&gt;첫 글에서도 언급했다시피 다른 개발자분들의 gatsby 블로그를 구경다니면서도 한 가지 의아했던 점 중 하나는, UI가 하나같이 매우 흡사하다는 점이었다. 상단에는 full-width의 top-fixed-header가 존재하고 바로 밑에는 자신의 프로필과 간단한 소개글, 그 밑에 포스팅이 나열되는 방식이었다. 이게 무슨 정해진 규칙같은 게 있는 건 지, 아니면 이런 형식으로 제공되는 템플릿이 있는 지는 모르겠는데 일단 나는 나만의 방식으로 꾸미기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(나중에 알게된 사실인데, &lt;a href=&quot;https://jbee.io&quot;&gt;Jbee&lt;/a&gt;님이 배포하시는 &lt;a href=&quot;https://github.com/JaeYeopHan/gatsby-starter-bee&quot;&gt;gatsby-starter-bee&lt;/a&gt;가 있었다. 아마 내가 구경한 블로그의 상당수는 이를 fork한 것으로 보인다. 이 블로그도 fork해서 만드는 걸 고려해보긴 했지만, 일단은 제로베이스부터 만들고 싶었다. 대신에 각종 기능을 어떻게 구현했는지에 대한 코드는 많이 참고하고 있다. Jbee님 감사합니다.)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;어떻게 꾸밀까&lt;/h2&gt;
&lt;p&gt;나는 &lt;code class=&quot;language-text&quot;&gt;gatsby-starter-blog&lt;/code&gt;를 fork해서 갖고왔다. 처음 &lt;code class=&quot;language-text&quot;&gt;npm run develop&lt;/code&gt; 커맨드로 실행하게 되면 뿌듯함과 함께 어떻게 꾸며야할까에 대한 막막함이 몰려온다.
&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983313/blog/assets/blog-history-1_jn3vyd.png&quot; alt=&quot;첫 상태&quot;&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;em&gt;
처음으로 블로그를 실행하면 마주하게 되는 화면.사실상 허허벌판 상태이다.
&lt;/em&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;p&gt;일단 해야할 일을 정해보자.&lt;/p&gt;
&lt;h4&gt;1. primary-color 정하기&lt;/h4&gt;
&lt;p&gt;UI의 통일성을 위해서는 꼭 필요하다. 내가 평소에 좋아하는 색인 &lt;code class=&quot;language-text&quot;&gt;DodgerBlue&lt;/code&gt; 계열의 색을 rgb-picker로 찍어왔다.&lt;/p&gt;
&lt;h4&gt;2. 내 소개글(profile) 작성하기&lt;/h4&gt;
&lt;p&gt;이건 간단하다. 한두줄 정도의 소개글과 프로필사진만 업로드하면 된다.&lt;/p&gt;
&lt;h4&gt;3. 헤더 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;다른 사람들의 블로그의 헤더가 모두 top-fixed에 full-width인 걸 보아하니, 나도 왠지 그래야만 할 것 같은 기분이 들었다. background-color는 primary-color로 적용하니 꽤 볼만해졌다. 그렇지만 점점 갈수록 다른 블로그들이랑 너무 비슷해져가는데...? 이럴거면 그냥 처음부터 &lt;code class=&quot;language-text&quot;&gt;gatsby-start-bee&lt;/code&gt;를 받아서 쓸 걸 그랬나...&lt;/p&gt;
&lt;p&gt;여기까지 적용해본 결과, 아래와 같이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737983314/blog/assets/blog-history-2_ymf24b.png&quot; alt=&quot;두 번째 상태&quot;&gt;&lt;/p&gt;
&lt;p&gt;참고 볼 만한 수준은 되었지만, 아직 이정도로는 부족하다.&lt;/p&gt;
&lt;h4&gt;4. 댓글 작성 기능&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;utterance&lt;/code&gt;를 활용하면 된다. 블로그 댓글을 위한 별도의 public 레포지토리를 만들고나서 연동을 하면 해당 레포지토리의 issue에 글이 올라가게 되고, 이를 댓글처럼 활용할 수 있는 방식이다.&lt;/p&gt;
&lt;h4&gt;5. 폰트 변경하기&lt;/h4&gt;
&lt;p&gt;기본으로 깔려있는 폰트는 별로 예쁘지가 않았다. 구글링으로 폰트 변경하는 법을 찾아보니, &lt;code class=&quot;language-text&quot;&gt;@fontsource&lt;/code&gt;에서 제공해주는 폰트를 &lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;기반으로 설치할 수 있다고 하더라. 기본 제공되는 한글 폰트는 가짓수가 그리 많지는 않지만 나는 가장 무난한 &lt;code class=&quot;language-text&quot;&gt;Noso Sans&lt;/code&gt;를 선택했다.&lt;/p&gt;
&lt;h4&gt;6. 코드블럭 스타일 변경하기&lt;/h4&gt;
&lt;p&gt;코드블럭 역시 기본으로 제공되는 스타일이 마음에 들지 않았다. 구글링해보니 &lt;code class=&quot;language-text&quot;&gt;gatsby-remark-highlight-code&lt;/code&gt;라는 플러그인을 제공해주고 있더라. 이런 문제들을 미리 만나고 해결해주시고 블로그에 글을 남겨주신 모든 분들께 감사드린다.&lt;/p&gt;
&lt;h4&gt;7. 모바일 환경도 신경쓰기&lt;/h4&gt;
&lt;p&gt;PC 환경에서는 잘 보이는데, 모바일에서 확인해보니 스타일이 깨지는 부분이 많았다. 사실 기술블로그를 주로 읽는 독자들의 대다수는 PC로 접속할 것으로 예상은 되지만, 그렇다고 모바일을 소홀히 할 변명이 되지는 않는다. 당연히 모바일에서도 잘 보여야한다. 헤더의 z-index나 element들의 간격을 조정해서 해결하였다.&lt;/p&gt;
&lt;h4&gt;8. 나만의 독특함(?)은 뭐가 있을까&lt;/h4&gt;
&lt;p&gt;사실 여기까지만 진행해도 나름 그럴싸한 UI가 완성되었다. 그렇지만 뭔가 좀 아쉽다. 다른 블로그를 너무 열심히 참고하는 바람에 내 블로그만의 특색이 사라졌다고나 할까? 그래도 나름 뭔가 좀 hooking 한 무언가 있었으면 좋겠다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;음, 생각을 해보자... 나만의 무언가....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러다가 문득 나의 닉네임이 Neon 이니, 네온사인같은 효과를 적용해보면 좋겠다는 생각이 떠올랐다. 바로 &lt;code class=&quot;language-text&quot;&gt;neon sign effect in css&lt;/code&gt;로 검색해보니 아니나 다를까, 수많은 구현 방법이 나와있었다. 기본적으로 text-shadow를 활용해서 뒤에 어두운 배경을 갖다대면 네온사인처럼 주변을 밝히는 효과를 낼 수 있었다. 더 참신한 건 animation,keyframes을 이용해서 네온사인이 깜빡이는 효과까지 만들 수 있다!&lt;br&gt;
처음 이걸 본 순간 확 꽂혀서 바로 내 블로그에 도입해보고 싶다는 생각이 들었다. 어려운 테크닉이 들어간 방식도 아니어서 단번에 보고 따라할 수 있었다. 혹시나 코드가 궁금하신 분들은 &lt;code class=&quot;language-text&quot;&gt;header-effect.css&lt;/code&gt;를 참고하면 된다.&lt;br&gt;
대신에 깜빡이는 효과는 눈이 아프거나 정신 사납다고 느낄 수도 있으니 독자에게 비활성화할 수 있는 방법은 제공해야되겠다고 생각했다. 상태관리 라이브러리를 써야하나 고민했는데 그렇게 복잡할 필요는 없을 것 같다고 판단하여 그냥 localStorage단에서 boolean값을 저장하여 제어하는 방식을 선택했다.&lt;/p&gt;
&lt;h2&gt;앞으로 적용해 볼 기능들&lt;/h2&gt;
&lt;h4&gt;카테고리&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;gatsby-starter-bee&lt;/code&gt;에서는 기본으로 제공해주는 기능인데, 나는 직접 구현해야한다. 구현 원리는 슥 봤는데 어느정도는 이해하긴 했다. 카테고리 목록을 &lt;code class=&quot;language-text&quot;&gt;string[]&lt;/code&gt;형태의 constant로 미리 선언해놓고, &lt;code class=&quot;language-text&quot;&gt;content/blog/&lt;/code&gt;밑의 경로에 선언해둔 카테고리를 디렉토리로 만들어서 포스팅을 집어 넣는다. 그리고 &lt;code class=&quot;language-text&quot;&gt;useCategory&lt;/code&gt; hook을 호출해서 특정 카테고리 밑에 있는 포스팅들을 다 묶어주는 방식인 것 같다. 머리로는 이해했는데 구현은 한번 해봐야 할 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2023.06.23 적용&lt;/strong&gt;&lt;br&gt;
오늘 하루를 꼬박 투자해서 카테고리 기능을 구현해냈다. 위에 적은 예상 구현 방법은 반은 맞고 반은 틀렸다. 카테고리 리스트는 constant로 미리 선언해둘 필요 없이, 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;category&lt;/code&gt;라는 속성을 적어주기만 하면 된다. 그러면 &lt;code class=&quot;language-text&quot;&gt;index.js&lt;/code&gt;에서 모든 글의 &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt;정보를 긁어와서 map형태로 만들고 &lt;code class=&quot;language-text&quot;&gt;unique&lt;/code&gt;함수를 거쳐서 유일하게 만들어주면 된다.&lt;br&gt;
여기까지는 &lt;em&gt;Jbee&lt;/em&gt; 님이 구현한 방식을 참고했는데, 나는 여기서 더 나아가 카테고리별 글의 &apos;개수&apos;까지 보여주고 싶었다. 기존 방식은 post의 카테고리를 &lt;code class=&quot;language-text&quot;&gt;map()&lt;/code&gt;함수로 뽑아낸 다음, &lt;code class=&quot;language-text&quot;&gt;lodash&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;uniq&lt;/code&gt;함수를 실행하기 때문에 글의 개수와 관련된 정보는 날라가버린다. 그래서 나는 글의 개수를 보존하기 위해 자료구조 &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt;을 활용하여 key값은 카테고리 이름, value값은 해당 카테고리 글의 개수를 저장했다.&lt;/p&gt;
&lt;h4&gt;다크모드&lt;/h4&gt;
&lt;p&gt;카테고리 기능만큼 우선순위가 높은 기능은 아니라고 생각한다. 이 역시도 gatsby-theme과 관련된 플러그인이 있는 것 같던데, 나중에 적용할 마음이 생기면 찾아보려고 한다.&lt;/p&gt;
&lt;h4&gt;오픈그래프(검색최적화)&lt;/h4&gt;
&lt;p&gt;이 부분에 관해서는 나도 아직 모르는 부분이 많아서 차차 공부해가면서 적용해보려고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 번째 글]]></title><description><![CDATA[블로그 이사 기존에 4년 반 동안 운영하던 티스토리 블로그에서 이곳 Gatsby 블로그로 이사하였다. 이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 '개발과 관련된' 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL…]]></description><link>https://juheon.dev/essay/230621-first-article/</link><guid isPermaLink="false">https://juheon.dev/essay/230621-first-article/</guid><pubDate>Wed, 21 Jun 2023 22:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;블로그 이사&lt;/h2&gt;
&lt;p&gt;기존에 4년 반 동안 운영하던 &lt;a href=&quot;https://ps-hjhj97.tistory.com&quot;&gt;티스토리 블로그&lt;/a&gt;에서 이곳 Gatsby 블로그로 이사하였다.&lt;/p&gt;
&lt;p&gt;이사하게된 배경에는 여러가지가 있지만, 가장 중요한 이유는 &apos;개발과 관련된&apos; 포스팅에 더 집중하기 위해서다. 티스토리 블로그는 이름과 URL에서부터 짐작되다시피, PS(Problem Solving)를 하면서 얻은 지식이나 문제 풀이 위주의 글들로 이루어져 있다. 처음 블로그를 개설할 당시만 하더라도 나는 아주 PS만 공부하고 있었으므로 추후에 개발 블로그로서 발전될 가능성을 염두에 두지 않았다.&lt;/p&gt;
&lt;p&gt;그러다 시간이 흘러 내가 취업전선에 뛰어들게 되면서 점점 PS보다는 개발 공부에 투자하는 비중이 더 많아졌다. 처음에는 개발 공부에서 얻은 지식들도 기존 티스토리 블로그에 포스팅할 예정이었으나, 그 당시에는 익숙치 않아서인지 개발 포스팅은 글을 어떻게 써야할 지 감이 잡히지 않았다.&lt;br&gt;
문제풀이 글의 경우에는 &apos;문제요약&apos; &gt; &apos;문제접근&apos; &gt; &apos;나의 생각&apos; &gt;&apos;코드구현&apos; 이라는 명확한 기승전결 포맷이 갖춰져 있음에 비해, 개발관련 글은 주제가 자유분방하다보니 이걸 어떻게 설명해야할지 도무지 갈피를 못잡았던 것 같다. 그래서 개발 포스팅은 차일피일 계속 미뤄지다가 작년에 회사 인턴을 시작하면서 &apos;이제는 진짜 해야한다&apos;라는 위기감을 느껴서 개발 포스트 몇 개 정도는 발행할 수 있었다.&lt;br&gt;
하지만 그럼에도 문제는 여전히 있었다. 일단 개발 포스팅을 스스로가 습관화하지는 못해서 업로드 주기가 불규칙하였으며(당초 목표는 한달에 약 3개 발행), 어쩌다가 의무감때문에 글을 쓰더라도 (지금 다시 읽어보면) 글의 퀄리티가 영 마음에 들지 않았기 때문이다.&lt;/p&gt;
&lt;p&gt;마음 속에는 &apos;열심히 글 써야지&apos;라는 추상화된 생각이 자리잡고 있는데, 현실 속에서 이를 구현하고 있지 못하는 상황이었다. 고민 끝에 내린 해결책이 바로 &apos;기술 블로그는 따로 분리하자&apos; 였다. 아무래도 티스토리 블로그에는 이미 PS 글들로 가득 차 있었고, 자잘한 블로그 테마나 스킨들도 이에 맞춰져 있었기 때문인지 개발 글을 써도 뭔가 기술 블로그처럼 보이지가 않았다. 고민에 고민을 거듭한 끝에 결국 내가 떠올린 해결책은 바로..&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이건...블로그를 옮겨야 해...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;완전히 새로운 마음으로 제로베이스부터 다시 시작해야 되겠다고 마음을 먹었다. PS를 위한 티스토리 블로그는 PS를 위한 글만 작성하도록 스스로 원칙을 정했다. 블로그 운영에도 &lt;code class=&quot;language-text&quot;&gt;단일 책임 원칙&lt;/code&gt;을 적용했다고 보면 된다.&lt;/p&gt;
&lt;h2&gt;왜 하필 Gatsby?&lt;/h2&gt;
&lt;p&gt;새로운 개발 블로그를 개설할 때에는 여러가지 옵션이 있었다. 가장 간단한 방법은 다른 도메인의 개발용 티스토리 블로그를 개설할 수도 있었다. 하지만 또 다시 티스토리에서 운영하면 똑같은 나태함의 수순을 반복할 것 같아서 완전히 다른 플랫폼으로 옮겨야되겠다고 마음먹었다. 그래서 티스토리를 제외하고 보통 사람들이 운영하는 개발 블로그의 종류에는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brunch&lt;/li&gt;
&lt;li&gt;velog&lt;/li&gt;
&lt;li&gt;medium&lt;/li&gt;
&lt;li&gt;github page&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;등이 있는데, 앞의 3가지는 플랫폼에서 미리 제공해주는 템플릿이 있고, 유저는 오직 글 작성에만 집중하면 되는 방식이다.
하지만 나는.... 나름 명색이 &lt;strong&gt;프론트엔드 개발자&lt;/strong&gt;이다. 그렇다면 내가 직접 커스텀하고 개발할 수 있는 폭이 넓은 &apos;github page&apos;를 선택해야 하지 않을까? 하는 &lt;code class=&quot;language-text&quot;&gt;근거는-없지만-당연히-그래야-할-것-같은-기분&lt;/code&gt;이 들었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;좋아, 그러면 일단 github page로 결정!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github page에서도 크게 선택이 두 가지로 나뉘는데 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;이다. 둘 다 정적 웹사이트 생성기이지만 약간의 차이는 있다. 내가 차이점에 대해서 정확히 조사한 건 아니지만 대략 찾아보고 느낀 점은 &lt;code class=&quot;language-text&quot;&gt;jekyll&lt;/code&gt;은 좀 불편하고, &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt;기반이면서 커스텀할 수 있는 여지도 더 넓다는 것이다. 그리고 무엇보다 결정적인 요인은, 내가 다른 개발자분들의 기술 블로그를 &lt;del&gt;염탐&lt;/del&gt; 구경해보면서 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;기반의 기술블로그가 훨씬 더 많았다는 점이다. 이쯤 되니 아, 나는 어쩔 수없이 &lt;code class=&quot;language-text&quot;&gt;gatsby&lt;/code&gt;를 선택해야 할 운명이야- 가 되어 버렸다.&lt;br&gt;
그래서 이틀 전에 구글링으로 &apos;gatsby 블로그 만드는 방법&apos; 찾아보면서 후다닥 만들고 git에 배포까지 완료했다. 게다가 야심차게 가비아에서 &lt;code class=&quot;language-text&quot;&gt;juheon.dev&lt;/code&gt; 도메인까지 구입해서 연결했다. 1년에 3만원 남짓한 금액이지만 아무튼 내 돈주고 운영하는 블로그인만큼 조금의 강제성은 부여되지 않을까 기대해본다.&lt;/p&gt;
&lt;h2&gt;앞으로 어떻게 운영해야할까&lt;/h2&gt;
&lt;p&gt;우선 나 스스로 블로그에 글을 쓴다는 심리적인 허들을 낮출 필요가 있다. 현재 나는 은근히 글을 쓰는 데에 부담감을 짋어지고 있는 듯 하다. 좋은 글을 써야 한다는 압박 때문인지 주제는 정해놓고서도 쉽사리 글을 적지는 못하고 있다.&lt;br&gt;
사실 다른 개발자분들의 기술블로그를 구경하면서 다들 글을 너무 잘 쓰길래 스스로 기가 죽은 것 같은 기분을 느낀다. 그렇지만 처음부터 잘 쓰는 사람이 어디 있을까, 짧고 간결한 글이라도 좋으니깐 일단 글을 쓰는 일을 &apos;습관화&apos;하는 일이 1순위이다.&lt;/p&gt;</content:encoded></item></channel></rss>