{"componentChunkName":"component---src-templates-blog-post-js","path":"/python/250128-selenium-automation/","result":{"data":{"site":{"siteMetadata":{"title":"하주헌 개발 블로그"}},"markdownRemark":{"id":"fb09c39f-8c30-5661-9a33-65bded8fe28d","excerpt":"이미지 마이그레이션 계획 Cloudinary 관련 컨텐츠로 글을 무지막지하게 뽑아내고 있다. 처음에는 소소하게 시작했는데, 하다보니깐 재미가 붙어서 계속 살을 덧붙이고 싶어진다. 지금까지 내가 블로그에 올린 asset…","html":"<h2>이미지 마이그레이션 계획</h2>\n<p>Cloudinary 관련 컨텐츠로 글을 무지막지하게 뽑아내고 있다. 처음에는 소소하게 시작했는데, 하다보니깐 재미가 붙어서 계속 살을 덧붙이고 싶어진다.</p>\n<p>지금까지 내가 블로그에 올린 asset 파일들은 <a href=\"https://juheon.dev/react/250123-cloudinary-next-image-uploader-1/\">이 포스팅</a>에서도 설명했다시피 두 가지 방식으로 저장했었는데, 이제는 이 파일들을 모두 Cloudinary로 마이그레이션 하고자 한다. 이를 위해 웹 스크래핑 라이브러리 <code class=\"language-text\">Selenium</code>을 사용해보기로 했다. 나도 <code class=\"language-text\">Selenium</code>은 이번에 처음 접해보기 때문에 Cursor의 힘을 빌려서 자동화 코드를 작성해보려 한다. 마이그레이션은 총 4단계로 이뤄진다.</p>\n<ol>\n<li>블로그에 올린 이미지 파일의 경로 추출</li>\n<li>추출한 경로를의 이미지를 모두 다운로드</li>\n<li>다운로드한 이미지를 Cloudinary에 업로드</li>\n<li>업로드된 경로를 바탕으로 기존 경로 수정</li>\n</ol>\n<h3>1. 블로그에 올린 이미지 파일의 경로 추출</h3>\n<p>우선 내 블로그(juheon.dev)에 접속하여 존재하는 모든 게시물에 있는 <code class=\"language-text\">&lt;img></code>태그 안의 <code class=\"language-text\">src</code> 속성을 추출해내야 한다. 추출한 이미지는 별도의 txt 파일로 저장해두고 이후 다운로드 과정에서 사용할 것이다.</p>\n<p>코드는 Cursor가 열심히 만들어줬다. Cusor는 정말 최고다...짜릿하다....</p>\n<details>\n<summary>코드 보기</summary>\n<deckgo-highlight-code language=\"python\"  >\n          <code slot=\"code\">from selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom webdriver_manager.chrome import ChromeDriverManager\nimport time\nfrom datetime import datetime\n\ndef get_all_image_sources(driver, post_url):\n    # 게시물 페이지 접속\n    driver.get(post_url)\n    time.sleep(2)  # 페이지 로딩 대기\n\n    # 이미지 태그 찾기\n    images = driver.find_elements(By.TAG_NAME, &quot;img&quot;)\n    image_sources = []\n\n    # 이미지 소스 URL 추출\n    for img in images:\n        src = img.get_attribute(&#39;src&#39;)\n        if src:\n            image_sources.append(src)\n\n    return image_sources\n\ndef save_to_file(image_sources):\n    # 현재 시간을 파일명에 포함\n    timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S&quot;)\n    filename = f&quot;image_sources_{timestamp}.txt&quot;\n\n    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:\n        f.write(f&quot;추출 시간: {datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}\\n&quot;)\n        f.write(f&quot;총 이미지 수: {len(image_sources)}\\n&quot;)\n        f.write(&quot;-&quot; * 50 + &quot;\\n\\n&quot;)\n\n        for i, src in enumerate(image_sources, 1):\n            f.write(f&quot;{i}. {src}\\n&quot;)\n\n    return filename\n\ndef main():\n    # Chrome 드라이버 설정\n    service = Service(ChromeDriverManager().install())\n    driver = webdriver.Chrome(service=service)\n\n    try:\n        # 메인 페이지 접속\n        driver.get(&quot;https://juheon.dev&quot;)\n        time.sleep(3)  # 페이지 로딩 대기\n\n        # 모든 게시물 링크 수집\n        post_links = []\n        articles = driver.find_elements(By.TAG_NAME, &quot;article&quot;)\n\n        for article in articles:\n            try:\n                link = article.find_element(By.TAG_NAME, &quot;a&quot;).get_attribute(&#39;href&#39;)\n                if link:\n                    post_links.append(link)\n            except:\n                continue\n\n        print(f&quot;총 {len(post_links)}개의 게시물을 찾았습니다.&quot;)\n\n        # 각 게시물 방문하여 이미지 소스 추출\n        all_image_sources = []\n        for i, post_url in enumerate(post_links, 1):\n            print(f&quot;\\n게시물 {i}/{len(post_links)} 처리 중...&quot;)\n            image_sources = get_all_image_sources(driver, post_url)\n            print(f&quot;발견된 이미지 수: {len(image_sources)}&quot;)\n\n            for src in image_sources:\n                print(f&quot;이미지 소스: {src}&quot;)\n                all_image_sources.append(src)\n\n        # 결과를 파일로 저장\n        filename = save_to_file(all_image_sources)\n        print(f&quot;\\n총 {len(all_image_sources)}개의 이미지를 찾았습니다.&quot;)\n        print(f&quot;결과가 {filename} 파일에 저장되었습니다.&quot;)\n\n    finally:\n        driver.quit()\n\nif __name__ == &quot;__main__&quot;:\n    main()</code>\n        </deckgo-highlight-code>\n</details>\n<h3>2. 추출한 경로를의 이미지를 모두 다운로드</h3>\n<p>1번을 실행하면 아래와 같은 형태의 텍스트 파일이 생성된다. 그럼 이제 이 파일을 모두 다운로드해야 한다. 여기서 주의해야할 점은 jpg 파일과 gif 파일이 혼재되어 있기 때문에 파일 확장자를 확인하여 다운로드해야 한다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">추출 시간: 2025-01-27 21:43:56\n총 이미지 수: 104\n--------------------------------------------------\n\n4. https://juheon.dev/static/d059a7dc2274b3319003d03e50db9fcd/bbf83/profile-graduate.jpg\n14. https://github.com/user-attachments/assets/4d1c7159-9a23-4473-a039-7bfe3375bf2c\n18. https://github.com/user-attachments/assets/d9ad8b41-fb62-4469-a1bd-0f278b6d13f4\n...\n</code>\n        </deckgo-highlight-code>\n<p>Response 헤더를 통해 확장자가 gif인지 jpg인지 확인할 수 있다. 또한 경로가 <code class=\"language-text\">juheon.dev/static/</code> 이거나 <code class=\"language-text\">github.com/user-attachments/</code> 인 경우에만 다운로드하도록 하면 된다. 다운로드한 파일은 <code class=\"language-text\">/images</code> 디렉토리에 저장된다.</p>\n<details>\n<summary>코드 보기</summary>\n<deckgo-highlight-code language=\"python\"  >\n          <code slot=\"code\">import os\nimport requests\nfrom urllib.parse import urlparse\nimport re\nfrom pathlib import Path\n\ndef get_image_format(response):\n    &quot;&quot;&quot;\n    이미지 데이터를 분석하여 실제 이미지 포맷을 반환\n    &quot;&quot;&quot;\n    # 처음 바이트를 확인하여 이미지 포맷 판별\n    header = response.content[:8]\n\n    # GIF 시그니처 확인\n    if header.startswith(b&#39;GIF89a&#39;) or header.startswith(b&#39;GIF87a&#39;):\n        return &#39;gif&#39;\n    # JPEG 시그니처 확인\n    elif header.startswith(b&#39;\\xFF\\xD8\\xFF&#39;):\n        return &#39;jpg&#39;\n\n    return &#39;jpg&#39;  # 기본값은 jpg\n\ndef download_image(url, save_dir):\n    try:\n        # URL에서 파일명 추출\n        parsed_url = urlparse(url)\n        filename = os.path.basename(parsed_url.path)\n\n        # 파일명에서 모든 확장자 제거\n        name = filename.lower().replace(&#39;.jpg&#39;, &#39;&#39;).replace(&#39;.jpeg&#39;, &#39;&#39;).replace(&#39;.gif&#39;, &#39;&#39;)\n\n        # 이미지 다운로드 및 포맷 확인\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n\n        # 실제 이미지 포맷 확인\n        image_format = get_image_format(response)\n        filename = name + &#39;.&#39; + image_format\n\n        # 저장 경로 설정\n        save_path = os.path.join(save_dir, filename)\n\n        # 파일 저장\n        with open(save_path, &#39;wb&#39;) as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    f.write(chunk)\n\n        print(f&quot;다운로드 완료: {filename} ({image_format} 포맷)&quot;)\n        return True\n    except Exception as e:\n        print(f&quot;다운로드 실패 ({url}): {str(e)}&quot;)\n        return False\n\ndef main():\n    # images 디렉토리 생성\n    save_dir = &#39;images&#39;\n    os.makedirs(save_dir, exist_ok=True)\n\n    # 가장 최근의 image_sources 파일 찾기\n    image_sources_files = list(Path(&#39;.&#39;).glob(&#39;image_sources_*.txt&#39;))\n    if not image_sources_files:\n        print(&quot;image_sources 파일을 찾을 수 없습니다.&quot;)\n        return\n\n    latest_file = max(image_sources_files, key=os.path.getctime)\n    print(f&quot;파일 처리 중: {latest_file}&quot;)\n\n    # 파일에서 URL 읽기\n    with open(latest_file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:\n        lines = f.readlines()\n\n    # URL 필터링 및 다운로드\n    patterns = [\n        r&#39;juheon\\.dev/static/&#39;,\n        r&#39;github\\.com/user-attachments/&#39;\n    ]\n\n    success_count = 0\n    total_count = 0\n\n    for line in lines:\n        # URL 추출 (번호. URL 형식에서)\n        match = re.search(r&#39;\\d+\\.\\s*(http[^\\s]+)&#39;, line)\n        if not match:\n            continue\n\n        url = match.group(1)\n\n        # 지정된 패턴과 일치하는 URL만 처리\n        if any(re.search(pattern, url) for pattern in patterns):\n            total_count += 1\n            if download_image(url, save_dir):\n                success_count += 1\n\n    print(f&quot;\\n다운로드 완료: {success_count}/{total_count} 파일&quot;)\n    print(f&quot;저장 위치: {os.path.abspath(save_dir)}&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    main()</code>\n        </deckgo-highlight-code>\n<p>dd</p>\n</details>\n<p>실행해보면 파일들이 모두 저장된 것을 확인할 수 있다!\n<img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737985320/blog/assets/download-result.png\" alt=\"download-result\"></p>\n<h3>3. 다운로드한 이미지를 Cloudinary에 업로드</h3>\n<p>이제 이 파일들을 Cloudinary에 업로드해야 한다. 이 단계는 Drag &#x26; Drop 방식으로 옮기기만 하면 되기 때문에 매우 간단하다.</p>\n<p><img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737985542/blog/assets/%08Upload.png\" alt=\"upload-result\"></p>\n<h3>4. 업로드된 경로를 바탕으로 기존 경로 수정</h3>\n<p>이제 Cloudinary에 업로드된 이미지들을 바탕으로 기존 경로를 수정해야 한다. 이 단계는 모두 수작업으로 해야 한다. 때문에 이전 3개의 단계를 합친 시간보다도 더 품이 드는 작업이다. Cursor로도 자동화를 해보려고 했는데, 잘 인식이 안되는 것 같다.</p>\n<h2>마이그레이션 결과</h2>\n<p>빌드 결과물을 확인해본 결과, asset 파일의 용량이 기존 28.4 MB에서 70% 이상 줄어든 6.3MB가 된 것을 확인할 수 있다. 앞으로 블로그에 올린 이미지들은 모두 Cloudinary에 저장될 것이다.</p>\n<p><img src=\"https://res.cloudinary.com/dxnnrbhbk/image/upload/v1737989498/blog/assets/migration-result.png\" alt=\"migration-result\"></p>","frontmatter":{"title":"Selenium으로 블로그 이미지 마이그레이션 (Feat.Cursor)","date":"2025-01-28","keywords":null,"description":"Cursor의 힘을 빌려서 이미지 파일을 옮겨보자","category":"Python"}},"previous":{"fields":{"slug":"/react/250126-cloudinary-next-image-uploader-3/"},"frontmatter":{"title":"이미지 업로드 자동화 에러 핸들링/개선 사항"}},"next":{"fields":{"slug":"/essay/250701-review-2025-half/"},"frontmatter":{"title":"2025년 상반기 회고"}}},"pageContext":{"id":"fb09c39f-8c30-5661-9a33-65bded8fe28d","previousPostId":"95ee1392-a967-547d-bd03-fc0e147053f7","nextPostId":"35d7544d-52b1-54ff-8ad3-36d0180b34ca"}},"staticQueryHashes":["2841359383","3821306223"],"slicesMap":{}}